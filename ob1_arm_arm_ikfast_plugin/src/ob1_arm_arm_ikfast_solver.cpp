/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2022-09-20 21:03:10.999996
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[0]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[2]);
x6=((0.21115)*x2);
x7=(x0*x1);
x8=(x2*x3);
x9=(x0*x3);
x10=(x1*x2);
eetrans[0]=((((6.6e-7)*x7))+(((-1.1e-6)*x0))+(((-0.21115)*x9))+(((-0.15)*x2))+(((-1.0)*x1*x6))+((x4*(((((-0.08281387)*x7))+(((0.08281387)*x8))))))+((x5*(((((0.00244659)*x7))+(((-0.00244659)*x8))))))+(((-6.6e-7)*x8)));
eetrans[1]=((-0.001)+(((-0.08281387)*x5))+(((-0.00244659)*x4)));
eetrans[2]=((0.06)+(((6.6e-7)*x9))+(((-1.1e-6)*x2))+(((0.21115)*x7))+(((0.15)*x0))+((x5*(((((0.00244659)*x9))+(((0.00244659)*x10))))))+((x4*(((((-0.08281387)*x9))+(((-0.08281387)*x10))))))+(((-1.0)*x3*x6))+(((6.6e-7)*x10)));
if( (((((((((-1.0)*x9))+(((-1.0)*x10))))*(IKcos(j[3]))))+((((((x5*(((((-0.999563891228661)*x8))+(((0.999563891228661)*x7))))))+((x4*(((((0.0295301092415339)*x7))+(((-0.0295301092415339)*x8))))))))*(IKsin(j[3])))))) < -1-IKFAST_SINCOS_THRESH || (((((((((-1.0)*x9))+(((-1.0)*x10))))*(IKcos(j[3]))))+((((((x5*(((((-0.999563891228661)*x8))+(((0.999563891228661)*x7))))))+((x4*(((((0.0295301092415339)*x7))+(((-0.0295301092415339)*x8))))))))*(IKsin(j[3])))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
eerot[0]=IKacos(((((((((-1.0)*x9))+(((-1.0)*x10))))*(IKcos(j[3]))))+((((((x5*(((((-0.999563891228661)*x8))+(((0.999563891228661)*x7))))))+((x4*(((((0.0295301092415339)*x7))+(((-0.0295301092415339)*x8))))))))*(IKsin(j[3]))))));
return;
}
IKFAST_ASSERT(0);
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {4}; return freeparams; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x4400000b; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1;  _ij4[0] = -1; _ij4[1] = -1; _nj4 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

j4=pfree[0]; cj4=cos(pfree[0]); sj4=sin(pfree[0]);
r00 = eerot[0];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_px=px;
new_py=py;
new_pz=pz;
new_r00=r00;
r00 = new_r00; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
{
IkReal verifyeval[1];
verifyeval[0]=0;
if( IKabs(verifyeval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
if( (((0.0120700057123287)+(((12.0700057123287)*py)))) < -1-IKFAST_SINCOS_THRESH || (((0.0120700057123287)+(((12.0700057123287)*py)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x11=IKasin(((0.0120700057123287)+(((12.0700057123287)*py))));
j2array[0]=((-1.54126167788295)+(((-1.0)*x11)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((1.60033097570684)+x11);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[4];
IkReal x12=px*px;
IkReal x13=pz*pz;
IkReal x14=((33.3333333333333)*pz);
IkReal x15=((277.777777777778)*x13);
j0eval[0]=3.6000000001936e-5;
j0eval[1]=px;
j0eval[2]=((1.0)+(((-1.0)*x14))+x15+(((277.777777777778)*x12)));
j0eval[3]=((((277.777777777778)*(x12*x12)))+x12+((x12*x15))+(((-1.0)*x12*x14)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x16=px*px;
IkReal x17=pz*pz;
IkReal x18=(px*pz);
j0eval[0]=((1.0)+(((77160.4938271605)*(x17*x17)))+(((1666.66666666667)*x17))+(((-66.6666666666667)*pz))+(((77160.4938271605)*x16*x17))+(((-18518.5185185185)*(pz*pz*pz)))+(((-9259.25925925926)*pz*x16))+(((277.777777777778)*x16)));
j0eval[1]=((IKabs(((-7.92e-9)+(((0.018)*px))+(((2.64e-7)*pz))+(((-0.3)*x18))+(((-2.2e-6)*x17)))))+(IKabs(((0.00108)+(((0.3)*x17))+(((1.32e-7)*px))+(((-0.036)*pz))+(((-2.2e-6)*x18))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(px);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0eval[0]=((1.0)+(((-66.6666666666667)*pz))+(((77160.4938271605)*(pz*pz*pz*pz)))+(((-18518.5185185185)*(pz*pz*pz)))+(((1666.66666666667)*(pz*pz))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
pp=((py*py)+(pz*pz));
IkReal x19=pz*pz;
IkReal x20=py*py;
IkReal x21=pz*pz*pz*pz;
IkReal x22=pz*pz*pz;
IkReal x23=(py*pz);
IkReal x24=(pz*sj2);
IkReal x25=((4.0)*(pz*pz*pz*pz*pz));
IkReal x26=((1.98e-5)*x21);
IkReal x27=(pz*x20);
IkReal x28=(sj2*x19);
IkReal x29=(py*x19);
IkReal x30=((4.37638873026782e-7)*sj2*x22);
IkReal x31=((0.00800015598830486)*py*x22);
IkReal x32=((2.4070138016473e-13)*x28);
IkReal x33=((4.40008579356767e-9)*x29);
IkReal x34=(x19*x20);
IkReal x35=((4.0)*x20*x22);
IkReal x36=((2.2e-6)*x34);
IkReal x37=(x31+x30+x35+x25);
IkReal x38=(x33+x32+x36+x26);
j0eval[0]=((IKabs(((5.14967650487534e-10)+(((-1.29978745288954e-15)*sj2))+(((1.3200257380703e-10)*x23))+(((7.2210414049419e-15)*x24))+(((-4.99933139159741e-9)*pz))+(((4.62e-7)*x22))+(((2.2e-6)*x21))+(((-2.37604632852654e-11)*py))+x33+x32+x36+(((-9.53643797199138e-8)*x19))+(((6.6e-8)*x27))+(((-1.188e-8)*x20)))))+(IKabs(((-2.22186746622361e-5)+(((0.0417093721712462)*x19))+(((1.32)*x34))+(((-0.00023040449246318)*x23))+(((3.30854988008247e-10)*sj2))+(((-1.26039995431713e-8)*x24))+(((-1.0)*x37))+(((0.0026400514761406)*x29))+(((3.0)*x21))+(((6.04811792715847e-6)*py))+(((1.44420828098838e-7)*x28))+(((-0.1152)*x27))+(((-0.000423654298581482)*pz))+(((0.003024)*x20))+(((-0.640210218700746)*x22)))))+(IKabs(((-0.000140604963803194)+(((-1.57549994289641e-8)*x24))+(((0.00432)*x20))+(((-0.144)*x27))+(((8.64016846736925e-6)*py))+(((-1.2)*x21))+(((-0.000288005615578975)*x23))+(((-0.0606569343897762)*x19))+(((1.31291661908034e-7)*x28))+(((4.72649982868924e-10)*sj2))+(((0.00520523212677315)*pz))+(((1.2)*x34))+(((0.288)*x22))+(((0.00240004679649146)*x29)))))+(IKabs(((1.46170248544598e-9)+(((-5.63241229585468e-15)*sj2))+(((-5.148e-8)*x20))+(((-1.02962007569484e-10)*py))+(((7.26e-7)*x27))+(((7.94314554543609e-14)*x24))+(((1.45202831187733e-9)*x23))+x38+(((-1.79270453075715e-8)*pz))+(((-7.16043797199137e-8)*x19))+(((-1.782e-6)*x22)))))+(IKabs(((6.94214019429361e-10)+(((-1.0)*x38))+(((-7.36546223304073e-15)*sj2))+(((1.37199786693896e-13)*x24))+(((-6.732e-8)*x20))+(((7.722e-6)*x22))+(((1.254e-6)*x27))+(((-9.97595620280086e-7)*x19))+(((-1.34642625283171e-10)*py))+(((2.47631035596492e-8)*pz))+(((2.50804890233357e-9)*x23)))))+(IKabs(((-5.61782891409583e-5)+(((-0.223789781299254)*x22))+(((-3.15099988579283e-9)*x24))+(((-0.0288)*x27))+(((0.00131369343897762)*x19))+(((2.59205054021077e-6)*py))+x37+(((-0.12)*x34))+(((0.001296)*x20))+(((-1.31291661908034e-8)*x28))+(((-5.7601123115795e-5)*x23))+(((-0.000240004679649146)*x29))+(((0.6)*x21))+(((1.41794994860677e-10)*sj2))+(((0.00148168642535463)*pz))))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j1, j3]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal x39=py*py;
IkReal x40=pz*pz;
IkReal x41=pz*pz*pz;
IkReal x42=pz*pz*pz*pz;
IkReal x43=(py*pz);
IkReal x44=(pz*sj2);
IkReal x45=((1.98e-5)*x42);
IkReal x46=((4.0)*(pz*pz*pz*pz*pz));
IkReal x47=((2.2e-6)*x42);
IkReal x48=(pz*x39);
IkReal x49=(py*x40);
IkReal x50=(sj2*x40);
IkReal x51=((2.4070138016473e-13)*x50);
IkReal x52=((4.40008579356767e-9)*x49);
IkReal x53=((4.37638873026782e-7)*sj2*x41);
IkReal x54=((0.00800015598830486)*py*x41);
IkReal x55=(x39*x40);
IkReal x56=((2.2e-6)*x55);
IkReal x57=((4.0)*x39*x41);
IkReal x58=(x56+x51+x52);
IkReal x59=(x46+x54+x57+x53);
op[0]=((5.14967650487534e-10)+(((-1.29978745288954e-15)*sj2))+(((-4.99933139159741e-9)*pz))+(((-9.53643797199138e-8)*x40))+(((7.2210414049419e-15)*x44))+(((4.62e-7)*x41))+(((-1.188e-8)*x39))+(((-2.37604632852654e-11)*py))+x47+x58+(((1.3200257380703e-10)*x43))+(((6.6e-8)*x48)));
op[1]=((-5.61782891409583e-5)+(((-5.7601123115795e-5)*x43))+(((-1.31291661908034e-8)*x50))+(((-0.000240004679649146)*x49))+(((0.00131369343897762)*x40))+(((-0.12)*x55))+(((0.6)*x42))+(((-3.15099988579283e-9)*x44))+(((2.59205054021077e-6)*py))+x59+(((-0.223789781299254)*x41))+(((-0.0288)*x48))+(((1.41794994860677e-10)*sj2))+(((0.001296)*x39))+(((0.00148168642535463)*pz)));
op[2]=((1.46170248544598e-9)+(((-5.63241229585468e-15)*sj2))+(((-1.02962007569484e-10)*py))+(((1.45202831187733e-9)*x43))+(((7.26e-7)*x48))+(((-7.16043797199137e-8)*x40))+(((-5.148e-8)*x39))+x45+x58+(((-1.79270453075715e-8)*pz))+(((-1.782e-6)*x41))+(((7.94314554543609e-14)*x44)));
op[3]=((-0.000140604963803194)+(((8.64016846736925e-6)*py))+(((1.31291661908034e-7)*x50))+(((0.00432)*x39))+(((-1.2)*x42))+(((4.72649982868924e-10)*sj2))+(((0.00520523212677315)*pz))+(((-1.57549994289641e-8)*x44))+(((1.2)*x55))+(((-0.000288005615578975)*x43))+(((0.00240004679649146)*x49))+(((-0.144)*x48))+(((0.288)*x41))+(((-0.0606569343897762)*x40)));
op[4]=((6.94214019429361e-10)+(((-9.97595620280086e-7)*x40))+(((1.254e-6)*x48))+(((7.722e-6)*x41))+(((-6.732e-8)*x39))+(((-1.0)*x45))+(((-7.36546223304073e-15)*sj2))+(((2.50804890233357e-9)*x43))+(((-1.34642625283171e-10)*py))+(((2.47631035596492e-8)*pz))+(((-1.0)*x58))+(((1.37199786693896e-13)*x44)));
op[5]=((-2.22186746622361e-5)+(((-0.640210218700746)*x41))+(((0.0026400514761406)*x49))+(((3.30854988008247e-10)*sj2))+(((0.0417093721712462)*x40))+(((1.32)*x55))+(((3.0)*x42))+(((6.04811792715847e-6)*py))+(((1.44420828098838e-7)*x50))+(((0.003024)*x39))+(((-0.00023040449246318)*x43))+(((-0.1152)*x48))+(((-1.26039995431713e-8)*x44))+(((-0.000423654298581482)*pz))+(((-1.0)*x59)));
op[6]=((2.03671184470913e-10)+(((1.18802316426327e-9)*x43))+(((-2.772e-8)*x39))+(((7.27801747562329e-9)*pz))+(((1.518e-6)*x41))+(((-1.0)*x47))+(((-3.0328373900756e-15)*sj2))+(((5.94e-7)*x48))+(((-2.61035620280086e-7)*x40))+(((6.49893726444771e-14)*x44))+(((-1.0)*x58))+(((-5.54410809989527e-11)*py)));
polyroots6(op,zeror,numroots);
IkReal j0array[6], cj0array[6], sj0array[6], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[6]={true,true,true,true,true,true};
_nj0 = 6;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j1eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x60=pz*pz;
IkReal x61=(pz*sj0);
IkReal x62=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+(((-16.6666666666667)*x61))+sj0+(((-7575757.57575758)*x60))+(((2272727.27272727)*x62))+(((909090.909090909)*pz)));
j1eval[1]=IKsign(((-522.0000000242)+(((2400.0)*pz))+(((0.00264)*sj0))+(((6000.0)*x62))+(((-360.0)*cj0))+(((-0.044)*x61))+(((-20000.0)*x60))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x63=((1.0)+(((-16.6666666666667)*pz)));
IkReal x64=pz*pz;
IkReal x65=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x66=((-197727.272736439)+(((-7575757.57575758)*x64))+(((909090.909090909)*pz)));
IkReal x67=((x63*x63)+(x65*x65));
if((((18595041323.314)+(((5165289256476.13)*x64))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x68=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x64))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x75=IKPowWithIntegerCheck(x68,-1);
if(!x75.valid){
continue;
}
IkReal x69=x75.value;
IkReal x76 = x67;
if(IKabs(x76)==0){
continue;
}
IkReal x70=pow(x76,-0.5);
IkReal x71=(x63*x70);
IkReal x72=((1.0)*x65*x70);
IkReal x73=(x66*x69);
if((((1.0)+(((-1.0)*(x73*x73))))) < -0.00001)
continue;
IkReal x74=IKsqrt(((1.0)+(((-1.0)*(x73*x73)))));
if((x67) < -0.00001)
continue;
CheckValue<IkReal> x77=IKPowWithIntegerCheck(IKabs(IKsqrt(x67)),-1);
if(!x77.valid){
continue;
}
if( ((x66*(x77.value))) < -1-IKFAST_SINCOS_THRESH || ((x66*(x77.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x78 = IKatan2WithCheck(IkReal(x65),IkReal(x63),IKFAST_ATAN2_MAGTHRESH);
if(!x78.valid){
continue;
}
IkReal gconst34=((((-1.0)*(IKasin((x66*(x77.value))))))+(((-1.0)*(x78.value))));
IkReal gconst35=((((-1.0)*x71*x73))+(((-1.0)*x72*x74)));
IkReal gconst36=((((-1.0)*x72*x73))+((x71*x74)));
IkReal x79=pz*pz;
if((((18595041323.314)+(((5165289256476.13)*x79))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x81=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x79))+(((-619834710777.135)*pz))))),-1);
if(!x81.valid){
continue;
}
IkReal x80=x81.value;
CheckValue<IkReal> x82 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x82.valid){
continue;
}
CheckValue<IkReal> x83 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x83.valid){
continue;
}
if( (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) < -1-IKFAST_SINCOS_THRESH || (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x84 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x84.valid){
continue;
}
if( (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) < -1-IKFAST_SINCOS_THRESH || (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) < -1-IKFAST_SINCOS_THRESH || (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x85 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x85.valid){
continue;
}
if( (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) < -1-IKFAST_SINCOS_THRESH || (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x86 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x86.valid){
continue;
}
if( (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) < -1-IKFAST_SINCOS_THRESH || (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) < -1-IKFAST_SINCOS_THRESH || (((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x87 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x87.valid){
continue;
}
if((((((x82.value)*(x83.value)))+((j0*(j0)))+(((-1.0)*j0*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))))+(((-1.0)*(x84.value)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))))+(((-1.0)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))*(j0)))+((j0*(x85.value)))+(((-1.0)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))*(x86.value)))+(((1.0)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))))+(((x87.value)*(j0))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((((x82.value)*(x83.value)))+((j0*(j0)))+(((-1.0)*j0*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))))+(((-1.0)*(x84.value)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))))+(((-1.0)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))*(j0)))+((j0*(x85.value)))+(((-1.0)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))*(x86.value)))+(((1.0)*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))*(IKasin(((((197727.272736439)*x80))+(((-909090.909090909)*pz*x80))+(((7575757.57575758)*x79*x80)))))))+(((x87.value)*(j0))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x88=gconst35*gconst35;
IkReal x89=gconst36*gconst36;
IkReal x90=pz*pz;
IkReal x91=(gconst36*pz);
IkReal x92=((590.86479112738)*py);
IkReal x93=(gconst35*pz);
IkReal x94=((99.4633802333595)*sj2);
IkReal x95=((2400.0)*pz);
IkReal x96=((1657.72300388932)*sj2);
IkReal x97=((35.4518874676428)*py);
IkReal x98=((20000.0)*x90);
CheckValue<IkReal> x99 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst35))+(((4223.0)*x93))+(((-1.0)*gconst36*x94))+(((-1.0)*gconst36*x97))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst36))+(((0.57766479112738)*x91))+((x91*x96))+((x91*x92)))),IkReal(((633.450000635431)+(((-1.0)*gconst35*x97))+(((-1.0)*gconst35*x94))+((x92*x93))+(((253.38)*gconst36))+(((-4223.0)*x91))+(((-0.0346598874676428)*gconst35))+(((0.00182349530427826)*sj2))+((x93*x96))+(((0.57766479112738)*x93))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x99.valid){
continue;
}
CheckValue<IkReal> x100=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x89*x95))+(((0.00264)*gconst35))+(((-72.0)*x88))+(((-72.0)*x89))+(((-0.044)*x93))+(((-360.0)*gconst36))+((x88*x95))+(((6000.0)*x91))+(((-1.0)*x88*x98))+(((-1.0)*x89*x98)))),-1);
if(!x100.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x99.value)+(((1.5707963267949)*(x100.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x101=IKcos(j1);
IkReal x102=IKsin(j1);
IkReal x103=((0.12)*pz);
IkReal x104=pz*pz;
IkReal x105=gconst36*gconst36;
IkReal x106=((1.32e-7)*gconst35);
IkReal x107=((0.3)*pz);
IkReal x108=(gconst35*pz);
IkReal x109=(gconst35*gconst36);
IkReal x110=(gconst36*pz);
IkReal x111=((0.018)*gconst36);
IkReal x112=x101*x101;
IkReal x113=((1.0)*x104);
IkReal x114=((2.2e-6)*x108);
IkReal x115=((0.06)*x101);
IkReal x116=(gconst35*x102);
IkReal x117=(gconst36*x102);
IkReal x118=(x106+x103);
IkReal x119=(x101*x102);
IkReal x120=(x104*x112);
IkReal x121=(x105*x112);
IkReal x122=(x113+x114);
evalcond[0]=((-0.21115)+(((-1.0)*x102*x108))+(((-1.1e-6)*x102))+(((-1.0)*gconst36*x115))+(((0.06)*x116))+(((-0.15)*x101))+((x101*x110)));
evalcond[1]=((-2.8883239556369e-5)+((gconst35*x115))+(((-1.0)*x102*x110))+(((-1.1e-6)*x101))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((0.06)*x117))+(((-1.0)*x101*x108))+(((0.15)*x102)));
evalcond[2]=((0.0253474453653594)+((gconst36*x107))+(((-1.98e-7)*x102))+(((-1.0)*x111))+(((-7.92e-8)*x117))+(((-1.0)*x122))+x118+(((1.32e-6)*x102*x110))+(((-7.92e-8)*gconst35*x101))+(((-1.0)*(py*py)))+(((1.32e-6)*x101*x108))+(((1.452e-12)*x101))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-0.24)*x101*x108*x117))+(((-1.0)*x111*x112))+(((2.2e-6)*x110*x119))+(((-0.0072)*x121))+((x112*x114))+(((-3.3e-7)*x119))+(((0.018)*x101*x116))+(((-1.32e-7)*x101*x117))+(((-2.0)*x105*x120))+(((-1.0)*x122))+x120+x118+(((-1.0)*x106*x112))+(((-0.01889999999879)*x112))+(((-1.0)*x101*x107*x116))+((gconst36*x107*x112))+(((-1.0)*x103*x105))+((x104*x105))+(((0.0036)*x105))+(((-1.0)*x103*x112))+(((0.24)*pz*x121))+(((2.0)*x104*x109*x119))+(((0.0072)*x109*x119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x123=(gconst35*sj1);
IkReal x124=((0.0295301092415339)*sj2);
IkReal x125=((0.999563891228661)*cj2);
IkReal x126=(cj1*gconst36);
IkReal x127=((((-1.0)*cj1*gconst35))+(((-1.0)*gconst36*sj1)));
IkReal x128=((((-1.0)*x123*x124))+(((-1.0)*x123*x125))+((x125*x126))+((x124*x126)));
CheckValue<IkReal> x131 = IKatan2WithCheck(IkReal(x127),IkReal(x128),IKFAST_ATAN2_MAGTHRESH);
if(!x131.valid){
continue;
}
IkReal x129=((1.0)*(x131.value));
if((((x127*x127)+(x128*x128))) < -0.00001)
continue;
CheckValue<IkReal> x132=IKPowWithIntegerCheck(IKabs(IKsqrt(((x127*x127)+(x128*x128)))),-1);
if(!x132.valid){
continue;
}
if( (((x132.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x132.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x130=IKasin(((x132.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x129))+x130);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x129))+(((-1.0)*x130)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x133=((1.0)+(((-16.6666666666667)*pz)));
IkReal x134=pz*pz;
IkReal x135=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x136=((-197727.272736439)+(((-7575757.57575758)*x134))+(((909090.909090909)*pz)));
IkReal x137=((x135*x135)+(x133*x133));
if((((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x134)))) < -0.00001)
continue;
IkReal x138=IKabs(IKsqrt(((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x134)))));
CheckValue<IkReal> x145=IKPowWithIntegerCheck(x138,-1);
if(!x145.valid){
continue;
}
IkReal x139=x145.value;
IkReal x146 = x137;
if(IKabs(x146)==0){
continue;
}
IkReal x140=pow(x146,-0.5);
IkReal x141=((1.0)*x135*x140);
IkReal x142=((1.0)*x133*x140);
IkReal x143=(x136*x139);
if((((1.0)+(((-1.0)*(x143*x143))))) < -0.00001)
continue;
IkReal x144=IKsqrt(((1.0)+(((-1.0)*(x143*x143)))));
CheckValue<IkReal> x147 = IKatan2WithCheck(IkReal(x135),IkReal(x133),IKFAST_ATAN2_MAGTHRESH);
if(!x147.valid){
continue;
}
if((x137) < -0.00001)
continue;
CheckValue<IkReal> x148=IKPowWithIntegerCheck(IKabs(IKsqrt(x137)),-1);
if(!x148.valid){
continue;
}
if( ((x136*(x148.value))) < -1-IKFAST_SINCOS_THRESH || ((x136*(x148.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst37=((3.14159265358979)+(((-1.0)*(x147.value)))+(IKasin((x136*(x148.value)))));
IkReal gconst38=((((-1.0)*x142*x143))+((x141*x144)));
IkReal gconst39=((((-1.0)*x142*x144))+(((-1.0)*x141*x143)));
IkReal x149=((1.0)+(((-16.6666666666667)*pz)));
IkReal x150=((-136363.636363636)+(((2272727.27272727)*pz)));
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x151=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x151.valid){
continue;
}
if( (((x151.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x151.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x152 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x152.valid){
continue;
}
CheckValue<IkReal> x153 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x153.valid){
continue;
}
CheckValue<IkReal> x154 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x154.valid){
continue;
}
CheckValue<IkReal> x155 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x155.valid){
continue;
}
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x156=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x156.valid){
continue;
}
if( (((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x157 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x157.valid){
continue;
}
CheckValue<IkReal> x158 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x158.valid){
continue;
}
CheckValue<IkReal> x159 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x159.valid){
continue;
}
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x160=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x160.valid){
continue;
}
if( (((x160.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x160.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x161=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x161.valid){
continue;
}
if( (((x161.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x161.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x162=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x162.valid){
continue;
}
if( (((x162.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x162.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x163 = IKatan2WithCheck(IkReal(x150),IkReal(x149),IKFAST_ATAN2_MAGTHRESH);
if(!x163.valid){
continue;
}
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x164=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x164.valid){
continue;
}
if( (((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x165=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x165.valid){
continue;
}
if( (((x165.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x165.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x150*x150)+(x149*x149))) < -0.00001)
continue;
CheckValue<IkReal> x166=IKPowWithIntegerCheck(IKabs(IKsqrt(((x150*x150)+(x149*x149)))),-1);
if(!x166.valid){
continue;
}
if( (((x166.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x166.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((9.86960440108936)+(((3.14159265358979)*(IKasin(((x151.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+((j0*(j0)))+(((x152.value)*(x153.value)))+((j0*(x154.value)))+(((-3.14159265358979)*(x155.value)))+(((-1.0)*(IKasin(((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x157.value)))+(((x158.value)*(j0)))+(((-3.14159265358979)*(j0)))+(((-3.14159265358979)*(x159.value)))+(((-3.14159265358979)*j0))+(((3.14159265358979)*(IKasin(((x160.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x161.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x162.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((-1.0)*(x163.value)*(IKasin(((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((1.0)*(IKasin(((x165.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x166.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz))))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+(((3.14159265358979)*(IKasin(((x151.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+((j0*(j0)))+(((x152.value)*(x153.value)))+((j0*(x154.value)))+(((-3.14159265358979)*(x155.value)))+(((-1.0)*(IKasin(((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x157.value)))+(((x158.value)*(j0)))+(((-3.14159265358979)*(j0)))+(((-3.14159265358979)*(x159.value)))+(((-3.14159265358979)*j0))+(((3.14159265358979)*(IKasin(((x160.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x161.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x162.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((-1.0)*(x163.value)*(IKasin(((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((1.0)*(IKasin(((x165.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x166.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz))))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x167=gconst38*gconst38;
IkReal x168=gconst39*gconst39;
IkReal x169=pz*pz;
IkReal x170=(gconst38*pz);
IkReal x171=((99.4633802333595)*sj2);
IkReal x172=(gconst39*pz);
IkReal x173=((35.4518874676428)*py);
IkReal x174=((2400.0)*pz);
IkReal x175=((590.86479112738)*py);
IkReal x176=((1657.72300388932)*sj2);
IkReal x177=((20000.0)*x169);
CheckValue<IkReal> x178 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst38))+((x172*x175))+((x172*x176))+(((0.57766479112738)*x172))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst39))+(((4223.0)*x170))+(((-1.0)*gconst39*x171))+(((-1.0)*gconst39*x173)))),IkReal(((633.450000635431)+(((-4223.0)*x172))+(((253.38)*gconst39))+(((0.57766479112738)*x170))+(((-0.0346598874676428)*gconst38))+(((-1.0)*gconst38*x173))+(((-1.0)*gconst38*x171))+(((0.00182349530427826)*sj2))+((x170*x175))+((x170*x176))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x178.valid){
continue;
}
CheckValue<IkReal> x179=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((-0.044)*x170))+(((6000.0)*x172))+((x168*x174))+(((0.00264)*gconst38))+((x167*x174))+(((-360.0)*gconst39))+(((-1.0)*x168*x177))+(((-72.0)*x168))+(((-72.0)*x167))+(((-1.0)*x167*x177)))),-1);
if(!x179.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x178.value)+(((1.5707963267949)*(x179.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x180=IKsin(j1);
IkReal x181=IKcos(j1);
IkReal x182=((0.12)*pz);
IkReal x183=pz*pz;
IkReal x184=gconst39*gconst39;
IkReal x185=((1.32e-7)*gconst38);
IkReal x186=((0.3)*pz);
IkReal x187=((0.018)*gconst39);
IkReal x188=(gconst38*pz);
IkReal x189=((1.0)*pz);
IkReal x190=((1.32e-6)*pz);
IkReal x191=(gconst38*gconst39);
IkReal x192=x181*x181;
IkReal x193=((2.2e-6)*x188);
IkReal x194=((1.0)*x183);
IkReal x195=(gconst38*x181);
IkReal x196=(gconst39*x181);
IkReal x197=((2.0)*x183);
IkReal x198=((0.06)*x180);
IkReal x199=(gconst39*x180);
IkReal x200=(x185+x182);
IkReal x201=(x180*x181);
IkReal x202=(x184*x192);
IkReal x203=(x193+x194);
evalcond[0]=((-0.21115)+(((-0.06)*x196))+(((-1.0)*x180*x188))+((gconst38*x198))+(((-0.15)*x181))+(((-1.1e-6)*x180))+((pz*x196)));
evalcond[1]=((-2.8883239556369e-5)+(((0.06)*x195))+(((-1.0)*x189*x199))+(((0.15)*x180))+((gconst39*x198))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((-1.0)*x181*x188))+(((-1.1e-6)*x181)));
evalcond[2]=((0.0253474453653594)+(((-1.98e-7)*x180))+(((1.32e-6)*x181*x188))+(((-1.0)*x187))+(((1.452e-12)*x181))+(((-1.0)*x203))+((gconst39*x186))+x200+((x190*x199))+(((-1.0)*(py*py)))+(((-7.92e-8)*x199))+(((-7.92e-8)*x195))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-0.24)*x180*x188*x196))+(((0.0036)*x184))+((x191*x197*x201))+(((2.2e-6)*pz*x180*x196))+(((-1.0)*x197*x202))+(((-1.0)*x180*x186*x195))+(((-0.01889999999879)*x192))+(((-1.0)*x187*x192))+(((-1.0)*x203))+x200+((x192*x193))+(((-1.32e-7)*x180*x196))+(((0.24)*pz*x202))+(((-1.0)*x185*x192))+((gconst39*x186*x192))+(((-1.0)*x182*x192))+(((-0.0072)*x202))+(((0.018)*x180*x195))+((x183*x184))+(((-1.0)*x182*x184))+(((-3.3e-7)*x201))+((x183*x192))+(((0.0072)*x191*x201)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x204=(cj1*gconst39);
IkReal x205=((0.0295301092415339)*sj2);
IkReal x206=((0.999563891228661)*cj2);
IkReal x207=(gconst38*sj1);
IkReal x208=((((-1.0)*gconst39*sj1))+(((-1.0)*cj1*gconst38)));
IkReal x209=((((-1.0)*x206*x207))+((x204*x206))+((x204*x205))+(((-1.0)*x205*x207)));
CheckValue<IkReal> x212 = IKatan2WithCheck(IkReal(x208),IkReal(x209),IKFAST_ATAN2_MAGTHRESH);
if(!x212.valid){
continue;
}
IkReal x210=((1.0)*(x212.value));
if((((x208*x208)+(x209*x209))) < -0.00001)
continue;
CheckValue<IkReal> x213=IKPowWithIntegerCheck(IKabs(IKsqrt(((x208*x208)+(x209*x209)))),-1);
if(!x213.valid){
continue;
}
if( (((x213.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x213.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x211=IKasin(((x213.value)*(IKcos(r00))));
j3array[0]=(x211+(((-1.0)*x210)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x211))+(((-1.0)*x210)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x214=(pz*sj0);
IkReal x215=((590.86479112738)*py);
IkReal x216=((99.4633802333595)*sj2);
IkReal x217=(cj0*pz);
IkReal x218=((1657.72300388932)*sj2);
IkReal x219=((35.4518874676428)*py);
CheckValue<IkReal> x220 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*sj0))+((x215*x217))+(((0.57766479112738)*x217))+(((-248.658450583399)*sj2))+(((4223.0)*x214))+(((-1.0)*cj0*x216))+(((-1.0)*cj0*x219))+((x217*x218))+(((-0.0346598874676428)*cj0)))),IkReal(((633.450000635431)+((x214*x218))+((x214*x215))+(((253.38)*cj0))+(((-0.0346598874676428)*sj0))+(((0.57766479112738)*x214))+(((-1.0)*sj0*x216))+(((-1.0)*sj0*x219))+(((0.00182349530427826)*sj2))+(((-4223.0)*x217))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x220.valid){
continue;
}
CheckValue<IkReal> x221=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((6000.0)*x217))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-0.044)*x214))+(((-360.0)*cj0)))),-1);
if(!x221.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x220.value)+(((1.5707963267949)*(x221.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x222=IKcos(j1);
IkReal x223=IKsin(j1);
IkReal x224=((0.12)*pz);
IkReal x225=cj0*cj0;
IkReal x226=pz*pz;
IkReal x227=((1.32e-7)*sj0);
IkReal x228=((2.2e-6)*pz);
IkReal x229=((0.06)*sj0);
IkReal x230=((0.3)*pz);
IkReal x231=((1.0)*pz);
IkReal x232=x222*x222;
IkReal x233=(sj0*x228);
IkReal x234=((1.0)*x226);
IkReal x235=(cj0*x223);
IkReal x236=(cj0*x222);
IkReal x237=(sj0*x222);
IkReal x238=((2.0)*x226);
IkReal x239=(x224+x227);
IkReal x240=(x222*x223);
IkReal x241=(sj0*x232);
IkReal x242=(cj0*x232);
IkReal x243=(pz*x237);
IkReal x244=(x225*x232);
IkReal x245=(x233+x234);
evalcond[0]=((-0.21115)+(((-1.1e-6)*x223))+((x223*x229))+((pz*x236))+(((-1.0)*sj0*x223*x231))+(((-0.06)*x236))+(((-0.15)*x222)));
evalcond[1]=((-2.8883239556369e-5)+(((0.15)*x223))+(((-1.1e-6)*x222))+((x222*x229))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((-1.0)*x231*x237))+(((-1.0)*x231*x235))+(((0.06)*x235)));
evalcond[2]=((0.0253474453653594)+(((1.32e-6)*pz*x235))+(((1.32e-6)*x243))+x239+(((-1.98e-7)*x223))+(((1.452e-12)*x222))+(((-7.92e-8)*x235))+(((-7.92e-8)*x237))+(((-1.0)*x245))+((cj0*x230))+(((-1.0)*(py*py)))+(((-0.018)*cj0))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((0.0072)*x235*x237))+((x230*x242))+(((-0.0072)*x244))+((x225*x226))+(((-1.0)*x227*x232))+(((-1.0)*x224*x232))+(((-1.0)*x224*x225))+(((-0.018)*x242))+(((-1.32e-7)*x222*x235))+((x232*x233))+(((-0.24)*x235*x243))+((x226*x232))+((x235*x237*x238))+(((-0.01889999999879)*x232))+(((-1.0)*x223*x230*x237))+x239+((x222*x228*x235))+(((0.018)*x223*x237))+(((-1.0)*x238*x244))+(((-3.3e-7)*x240))+(((0.0036)*x225))+(((-1.0)*x245))+(((0.24)*pz*x244)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x246=sj0*sj0;
IkReal x247=sj1*sj1;
IkReal x248=cj0*cj0;
IkReal x249=cj2*cj2;
IkReal x250=cj1*cj1;
IkReal x251=sj2*sj2;
IkReal x252=(cj2*sj2);
IkReal x253=((1145.753020896)*x249);
IkReal x254=(cj0*cj1*sj0*sj1);
IkReal x255=(x248*x250);
IkReal x256=(x246*x247);
j3eval[0]=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
j3eval[1]=((((-135.39589482084)*x252*x254))+(((1146.753020896)*x247*x248))+((x251*x255))+((x251*x256))+(((-2.0)*x251*x254))+((x253*x255))+((x253*x256))+(((2293.50604179201)*x254))+(((67.6979474104201)*x252*x255))+(((67.6979474104201)*x252*x256))+(((1146.753020896)*x246*x250))+(((-2291.50604179201)*x249*x254)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x257=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x257.valid){
continue;
}
sj3array[0]=((x257.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x258=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x258.valid){
continue;
}
sj3array[0]=((x258.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x259=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x259.valid){
continue;
}
sj3array[0]=((x259.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x260=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x260.valid){
continue;
}
sj3array[0]=((x260.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x261=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x261.valid){
continue;
}
sj3array[0]=((x261.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x262=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x262.valid){
continue;
}
sj3array[0]=((x262.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x263=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x263.valid){
continue;
}
sj3array[0]=((x263.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x264=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x264.valid){
continue;
}
sj3array[0]=((x264.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x265=(sj0*sj1);
IkReal x266=((0.999563891228661)*cj2);
IkReal x267=((0.0295301092415339)*sj2);
IkReal x268=(cj0*cj1);
IkReal x269=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
IkReal x270=(((x267*x268))+((x266*x268))+(((-1.0)*x265*x266))+(((-1.0)*x265*x267)));
CheckValue<IkReal> x273 = IKatan2WithCheck(IkReal(x269),IkReal(x270),IKFAST_ATAN2_MAGTHRESH);
if(!x273.valid){
continue;
}
IkReal x271=((1.0)*(x273.value));
if((((x270*x270)+(x269*x269))) < -0.00001)
continue;
CheckValue<IkReal> x274=IKPowWithIntegerCheck(IKabs(IKsqrt(((x270*x270)+(x269*x269)))),-1);
if(!x274.valid){
continue;
}
if( (((x274.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x274.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x272=IKasin(((x274.value)*(IKcos(r00))));
j3array[0]=(x272+(((-1.0)*x271)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x272))+(((-1.0)*x271)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
    }

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x275=pz*pz;
IkReal x276=py*py;
IkReal x277=((0.00108)+(((0.3)*x275))+(((-0.036)*pz)));
IkReal x278=((-7.92e-9)+(((2.64e-7)*pz))+(((-2.2e-6)*x275)));
CheckValue<IkReal> x281 = IKatan2WithCheck(IkReal(x277),IkReal(x278),IKFAST_ATAN2_MAGTHRESH);
if(!x281.valid){
continue;
}
IkReal x279=((1.0)*(x281.value));
if((((x278*x278)+(x277*x277))) < -0.00001)
continue;
CheckValue<IkReal> x282=IKPowWithIntegerCheck(IKabs(IKsqrt(((x278*x278)+(x277*x277)))),-1);
if(!x282.valid){
continue;
}
if( (((x282.value)*(((-0.00152084671963401)+(((0.0181474453272335)*pz))+(((6.56458309540172e-9)*sj2))+(((-1.09409718256695e-7)*pz*sj2))+(((-1.0)*(pz*pz*pz)))+(((-1.0)*pz*x276))+(((0.000120002339824573)*py))+(((0.18)*x275))+(((-0.00200003899707621)*py*pz))+(((0.06)*x276)))))) < -1-IKFAST_SINCOS_THRESH || (((x282.value)*(((-0.00152084671963401)+(((0.0181474453272335)*pz))+(((6.56458309540172e-9)*sj2))+(((-1.09409718256695e-7)*pz*sj2))+(((-1.0)*(pz*pz*pz)))+(((-1.0)*pz*x276))+(((0.000120002339824573)*py))+(((0.18)*x275))+(((-0.00200003899707621)*py*pz))+(((0.06)*x276)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x280=IKasin(((x282.value)*(((-0.00152084671963401)+(((0.0181474453272335)*pz))+(((6.56458309540172e-9)*sj2))+(((-1.09409718256695e-7)*pz*sj2))+(((-1.0)*(pz*pz*pz)))+(((-1.0)*pz*x276))+(((0.000120002339824573)*py))+(((0.18)*x275))+(((-0.00200003899707621)*py*pz))+(((0.06)*x276))))));
j0array[0]=((((-1.0)*x280))+(((-1.0)*x279)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x280+(((-1.0)*x279)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x283=py*py;
IkReal x284=pz*pz;
IkReal x285=pz*pz*pz*pz;
IkReal x286=IKcos(j0);
IkReal x287=IKsin(j0);
IkReal x288=pz*pz*pz;
IkReal x289=pz*pz*pz*pz*pz;
IkReal x290=((2.16004211684231e-6)*py);
IkReal x291=((1.18162495717231e-10)*sj2);
IkReal x292=((1.58403088568436e-11)*py);
IkReal x293=((8.66524968593028e-16)*sj2);
IkReal x294=((4.72649982868924e-11)*sj2);
IkReal x295=((8.64016846736925e-7)*py);
IkReal x296=((3.8016e-9)*pz);
IkReal x297=((0.0005184)*pz);
IkReal x298=(pz*sj2);
IkReal x299=(py*pz);
IkReal x300=((4.4e-6)*x285);
IkReal x301=((1.056e-6)*x288);
IkReal x302=x286*x286;
IkReal x303=((0.6)*x285);
IkReal x304=((0.3)*x285);
IkReal x305=((0.00108)*x283);
IkReal x306=((3.93874985724103e-9)*x298);
IkReal x307=((7.20014038947437e-5)*x299);
IkReal x308=((5.28010295228121e-10)*x299);
IkReal x309=((2.88841656197676e-14)*x298);
IkReal x310=((7.92e-9)*x283);
IkReal x311=((0.000432)*x283);
IkReal x312=((2.36324991434462e-9)*x298);
IkReal x313=((4.32008423368462e-5)*x299);
IkReal x314=((2.0)*x289);
IkReal x315=x287*x287;
IkReal x316=((9.504e-8)*x284);
IkReal x317=((0.01296)*x284);
IkReal x318=((0.144)*x288);
IkReal x319=(py*x284);
IkReal x320=(sj2*x288);
IkReal x321=(sj2*x284);
IkReal x322=(pz*x283);
IkReal x323=(py*x288);
IkReal x324=((0.000600011699122864)*x319);
IkReal x325=((3.28229154770086e-8)*x321);
IkReal x326=((0.036)*x322);
IkReal x327=((2.64e-7)*x322);
IkReal x328=((2.4070138016473e-13)*x321);
IkReal x329=((4.40008579356767e-9)*x319);
IkReal x330=((0.000720014038947437)*x319);
IkReal x331=((3.93874985724103e-8)*x321);
IkReal x332=((0.0216)*x322);
IkReal x333=((2.18819436513391e-7)*x320);
IkReal x334=((0.00400007799415243)*x323);
IkReal x335=(x283*x288);
IkReal x336=(x283*x284);
IkReal x337=((0.3)*x336);
IkReal x338=((2.2e-6)*x336);
IkReal x339=((0.36)*x336);
IkReal x340=((2.0)*x335);
IkReal x341=(x301+x296);
IkReal x342=(x318+x297);
IkReal x343=(x287*x302);
IkReal x344=(x300+x316);
IkReal x345=(x303+x317);
IkReal x346=((-1.4256e-10)+(((6.6e-7)*x288))+(((7.128e-9)*pz))+(((-1.188e-7)*x284)));
IkReal x347=(x308+x309+x327);
IkReal x348=(x306+x307+x326);
IkReal x349=(x338+x328+x329+x310+x292+x293);
IkReal x350=(x305+x337+x324+x325+x290+x291);
IkReal x351=(x303+x339+x331+x330+x311+x294+x295);
IkReal x352=(x333+x332+x334+x314+x313+x312+x340);
evalcond[0]=((2.87440029992426e-5)+(((1.96937492862052e-8)*x321))+((x286*(((6.96324095471901e-6)+(((-1.0)*x350))+x348+(((-0.000232108031823967)*pz))+(((0.00193423359853306)*x284))))))+(((-0.00200003899707621)*x323))+(((0.0154474453260235)*x288))+(((-2.26804422253922e-6)*py))+(((0.18)*x336))+(((0.000360007019473719)*x319))+(((-1.24070620495149e-10)*sj2))+(((0.01169999999879)*x322))+x304+(((-1.0)*x335))+(((-1.0)*x289))+((x287*(((3.50439766982106e-10)+(((-9.78052556607021e-9)*pz))+x301+x347+(((1.81443797172518e-8)*x284))+(((-1.0)*x349))+(((-1.0)*x300))))))+((x315*(((1.04544e-15)+(((-4.84e-12)*x288))+(((8.712e-13)*x284))+(((-5.2272e-14)*pz))))))+((x343*(((5.7024e-11)+x344+(((-1.0)*x341))))))+(((-0.0011339999999274)*x283))+(((1.28009370347095e-9)*x298))+((x302*(((-8.48990361863512e-6)+(((0.104105109345533)*x288))+(((-1.0)*x351))+(((-0.0100989196821959)*x284))+x352+(((0.000476335180931756)*pz))))))+(((-0.00710054015868423)*x284))+(((x286*x286*x286)*(((-7.776e-6)+x342+(((-1.0)*x345))))))+(((2.34004562633717e-5)*x299))+(((-0.000160485110306674)*pz))+(((-1.09409718256695e-7)*x320)));
evalcond[1]=((5.01879417479224e-10)+(((-1.98e-8)*x283))+(((-2.16631242148257e-15)*sj2))+(((-5.94e-8)*x284))+((x343*(((7.776e-6)+x345+(((-1.0)*x342))))))+((x286*x315*(((-5.7024e-11)+x341+(((-1.0)*x344))))))+((x302*x346))+((x315*x346))+(((3.3e-7)*x288))+(((-5.98865695798706e-9)*pz))+(((3.3e-7)*x322))+(((6.60012869035151e-10)*x299))+((x286*(((-1.5564823300831e-10)+(((-2.2e-6)*x285))+(((-8.28356202800863e-8)*x284))+x347+(((-1.0)*x349))+(((5.28e-7)*x288))+(((6.13867443361035e-9)*pz))))))+(((-3.9600772142109e-11)*py))+((x286*x287*(((8.48990361968056e-6)+(((-1.0)*x352))+x351+(((-0.000476335180984028)*pz))+(((0.0100989196830671)*x284))+(((-0.104105109350373)*x288))))))+((x287*(((-2.73752409507986e-5)+(((-0.072)*x288))+(((0.000782908031693287)*pz))+x304+x350+(((-0.00220423359744406)*x284))+(((-1.0)*x348))))))+(((3.61052070247095e-14)*x298)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x353=pz*pz;
IkReal x354=(pz*sj0);
IkReal x355=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+sj0+(((-16.6666666666667)*x354))+(((909090.909090909)*pz))+(((-7575757.57575758)*x353))+(((2272727.27272727)*x355)));
j1eval[1]=IKsign(((-522.0000000242)+(((2400.0)*pz))+(((6000.0)*x355))+(((-0.044)*x354))+(((0.00264)*sj0))+(((-360.0)*cj0))+(((-20000.0)*x353))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x356=((1.0)+(((-16.6666666666667)*pz)));
IkReal x357=pz*pz;
IkReal x358=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x359=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x357)));
IkReal x360=((x356*x356)+(x358*x358));
if((((18595041323.314)+(((5165289256476.13)*x357))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x361=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x357))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x368=IKPowWithIntegerCheck(x361,-1);
if(!x368.valid){
continue;
}
IkReal x362=x368.value;
IkReal x369 = x360;
if(IKabs(x369)==0){
continue;
}
IkReal x363=pow(x369,-0.5);
IkReal x364=(x356*x363);
IkReal x365=((1.0)*x358*x363);
IkReal x366=(x359*x362);
if((((1.0)+(((-1.0)*(x366*x366))))) < -0.00001)
continue;
IkReal x367=IKsqrt(((1.0)+(((-1.0)*(x366*x366)))));
if((x360) < -0.00001)
continue;
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKabs(IKsqrt(x360)),-1);
if(!x370.valid){
continue;
}
if( ((x359*(x370.value))) < -1-IKFAST_SINCOS_THRESH || ((x359*(x370.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x371 = IKatan2WithCheck(IkReal(x358),IkReal(x356),IKFAST_ATAN2_MAGTHRESH);
if(!x371.valid){
continue;
}
IkReal gconst34=((((-1.0)*(IKasin((x359*(x370.value))))))+(((-1.0)*(x371.value))));
IkReal gconst35=((((-1.0)*x364*x366))+(((-1.0)*x365*x367)));
IkReal gconst36=(((x364*x367))+(((-1.0)*x365*x366)));
IkReal x372=pz*pz;
if((((18595041323.314)+(((5165289256476.13)*x372))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x374=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x372))+(((-619834710777.135)*pz))))),-1);
if(!x374.valid){
continue;
}
IkReal x373=x374.value;
CheckValue<IkReal> x375 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x375.valid){
continue;
}
CheckValue<IkReal> x376 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x376.valid){
continue;
}
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x377 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x377.valid){
continue;
}
CheckValue<IkReal> x378 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x378.valid){
continue;
}
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x379 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x379.valid){
continue;
}
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x380 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x380.valid){
continue;
}
if((((((x375.value)*(x376.value)))+((j0*(j0)))+(((1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(x377.value)))+((j0*(x378.value)))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(j0)))+(((-1.0)*j0*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(x379.value)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((x380.value)*(j0))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((((x375.value)*(x376.value)))+((j0*(j0)))+(((1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(x377.value)))+((j0*(x378.value)))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(j0)))+(((-1.0)*j0*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(x379.value)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((x380.value)*(j0))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x381=gconst35*gconst35;
IkReal x382=gconst36*gconst36;
IkReal x383=pz*pz;
IkReal x384=(gconst36*pz);
IkReal x385=((590.86479112738)*py);
IkReal x386=(gconst35*pz);
IkReal x387=((99.4633802333595)*sj2);
IkReal x388=((2400.0)*pz);
IkReal x389=((1657.72300388932)*sj2);
IkReal x390=((35.4518874676428)*py);
IkReal x391=((20000.0)*x383);
CheckValue<IkReal> x392=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((6000.0)*x384))+(((0.00264)*gconst35))+(((-1.0)*x382*x391))+(((-0.044)*x386))+(((-360.0)*gconst36))+((x382*x388))+(((-1.0)*x381*x391))+(((-72.0)*x382))+(((-72.0)*x381))+((x381*x388)))),-1);
if(!x392.valid){
continue;
}
CheckValue<IkReal> x393 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((4223.0)*x386))+((x384*x385))+((x384*x389))+(((-253.38)*gconst35))+(((0.57766479112738)*x384))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst36))+(((-1.0)*gconst36*x387))+(((-1.0)*gconst36*x390)))),IkReal(((633.450000635431)+(((-1.0)*gconst35*x390))+(((253.38)*gconst36))+(((0.57766479112738)*x386))+((x386*x389))+(((-0.0346598874676428)*gconst35))+(((-4223.0)*x384))+(((-1.0)*gconst35*x387))+(((0.00182349530427826)*sj2))+((x385*x386))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x393.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x392.value)))+(x393.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x394=IKcos(j1);
IkReal x395=IKsin(j1);
IkReal x396=((0.12)*pz);
IkReal x397=pz*pz;
IkReal x398=gconst36*gconst36;
IkReal x399=((1.32e-7)*gconst35);
IkReal x400=((0.3)*pz);
IkReal x401=(gconst35*pz);
IkReal x402=(gconst35*gconst36);
IkReal x403=(gconst36*pz);
IkReal x404=((0.018)*gconst36);
IkReal x405=x394*x394;
IkReal x406=((1.0)*x397);
IkReal x407=((2.2e-6)*x401);
IkReal x408=((0.06)*x394);
IkReal x409=(gconst35*x395);
IkReal x410=(gconst36*x395);
IkReal x411=(x396+x399);
IkReal x412=(x394*x395);
IkReal x413=(x397*x405);
IkReal x414=(x398*x405);
IkReal x415=(x407+x406);
evalcond[0]=((-0.21115)+(((-0.15)*x394))+(((0.06)*x409))+(((-1.1e-6)*x395))+(((-1.0)*x395*x401))+(((-1.0)*gconst36*x408))+((x394*x403)));
evalcond[1]=((-2.8883239556369e-5)+(((0.15)*x395))+(((0.06)*x410))+(((-0.029543239556369)*py))+(((-1.1e-6)*x394))+(((-1.0)*x395*x403))+(((-0.0828861501944662)*sj2))+(((-1.0)*x394*x401))+((gconst35*x408)));
evalcond[2]=((0.0253474453653594)+(((1.32e-6)*x394*x401))+(((1.32e-6)*x395*x403))+(((-7.92e-8)*gconst35*x394))+x411+((gconst36*x400))+(((-1.98e-7)*x395))+(((1.452e-12)*x394))+(((-7.92e-8)*x410))+(((-1.0)*(py*py)))+(((-1.0)*x415))+(((-1.0)*x404))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-2.0)*x398*x413))+((x405*x407))+(((-0.0072)*x414))+(((0.018)*x394*x409))+(((0.24)*pz*x414))+x413+x411+(((-1.0)*x404*x405))+(((2.0)*x397*x402*x412))+(((-1.0)*x399*x405))+((gconst36*x400*x405))+(((-3.3e-7)*x412))+((x397*x398))+(((0.0072)*x402*x412))+(((-1.0)*x396*x398))+(((0.0036)*x398))+(((2.2e-6)*x403*x412))+(((-1.0)*x396*x405))+(((-0.24)*x394*x401*x410))+(((-1.0)*x415))+(((-1.0)*x394*x400*x409))+(((-0.01889999999879)*x405))+(((-1.32e-7)*x394*x410)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x416=(gconst35*sj1);
IkReal x417=((0.0295301092415339)*sj2);
IkReal x418=((0.999563891228661)*cj2);
IkReal x419=(cj1*gconst36);
IkReal x420=((((-1.0)*cj1*gconst35))+(((-1.0)*gconst36*sj1)));
IkReal x421=(((x417*x419))+(((-1.0)*x416*x418))+(((-1.0)*x416*x417))+((x418*x419)));
CheckValue<IkReal> x424 = IKatan2WithCheck(IkReal(x420),IkReal(x421),IKFAST_ATAN2_MAGTHRESH);
if(!x424.valid){
continue;
}
IkReal x422=((1.0)*(x424.value));
if((((x420*x420)+(x421*x421))) < -0.00001)
continue;
CheckValue<IkReal> x425=IKPowWithIntegerCheck(IKabs(IKsqrt(((x420*x420)+(x421*x421)))),-1);
if(!x425.valid){
continue;
}
if( (((x425.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x425.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x423=IKasin(((x425.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x422))+x423);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x423))+(((-1.0)*x422)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x426=((1.0)+(((-16.6666666666667)*pz)));
IkReal x427=pz*pz;
IkReal x428=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x429=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x427)));
IkReal x430=((x426*x426)+(x428*x428));
if((((18595041323.314)+(((5165289256476.13)*x427))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x431=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x427))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x438=IKPowWithIntegerCheck(x431,-1);
if(!x438.valid){
continue;
}
IkReal x432=x438.value;
IkReal x439 = x430;
if(IKabs(x439)==0){
continue;
}
IkReal x433=pow(x439,-0.5);
IkReal x434=((1.0)*x428*x433);
IkReal x435=((1.0)*x426*x433);
IkReal x436=(x429*x432);
if((((1.0)+(((-1.0)*(x436*x436))))) < -0.00001)
continue;
IkReal x437=IKsqrt(((1.0)+(((-1.0)*(x436*x436)))));
CheckValue<IkReal> x440 = IKatan2WithCheck(IkReal(x428),IkReal(x426),IKFAST_ATAN2_MAGTHRESH);
if(!x440.valid){
continue;
}
if((x430) < -0.00001)
continue;
CheckValue<IkReal> x441=IKPowWithIntegerCheck(IKabs(IKsqrt(x430)),-1);
if(!x441.valid){
continue;
}
if( ((x429*(x441.value))) < -1-IKFAST_SINCOS_THRESH || ((x429*(x441.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst37=((3.14159265358979)+(((-1.0)*(x440.value)))+(IKasin((x429*(x441.value)))));
IkReal gconst38=((((-1.0)*x435*x436))+((x434*x437)));
IkReal gconst39=((((-1.0)*x435*x437))+(((-1.0)*x434*x436)));
IkReal x442=((1.0)+(((-16.6666666666667)*pz)));
IkReal x443=((-136363.636363636)+(((2272727.27272727)*pz)));
CheckValue<IkReal> x444 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x444.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x445=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x445.valid){
continue;
}
if( (((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x446 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x446.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x447=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x447.valid){
continue;
}
if( (((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x448 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x448.valid){
continue;
}
CheckValue<IkReal> x449 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x449.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x450=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x450.valid){
continue;
}
if( (((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x451 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x451.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x452=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x452.valid){
continue;
}
if( (((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x453 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x453.valid){
continue;
}
CheckValue<IkReal> x454 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x454.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x455=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x455.valid){
continue;
}
if( (((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x456.valid){
continue;
}
if( (((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x457 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x457.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x458=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x458.valid){
continue;
}
if( (((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x459=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x459.valid){
continue;
}
if( (((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((9.86960440108936)+((j0*(j0)))+(((-3.14159265358979)*(x444.value)))+(((-1.0)*(IKasin(((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x446.value)))+(((3.14159265358979)*(IKasin(((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+((j0*(x448.value)))+(((-3.14159265358979)*(j0)))+(((-3.14159265358979)*(x449.value)))+(((-1.0)*(IKasin(((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((-1.0)*(x451.value)*(IKasin(((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x453.value)*(x454.value)))+(((-3.14159265358979)*j0))+(((-1.0)*j0*(IKasin(((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x457.value)*(j0)))+(((1.0)*(IKasin(((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz))))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((j0*(j0)))+(((-3.14159265358979)*(x444.value)))+(((-1.0)*(IKasin(((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x446.value)))+(((3.14159265358979)*(IKasin(((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+((j0*(x448.value)))+(((-3.14159265358979)*(j0)))+(((-3.14159265358979)*(x449.value)))+(((-1.0)*(IKasin(((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((-1.0)*(x451.value)*(IKasin(((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x453.value)*(x454.value)))+(((-3.14159265358979)*j0))+(((-1.0)*j0*(IKasin(((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x457.value)*(j0)))+(((1.0)*(IKasin(((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz))))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x460=gconst38*gconst38;
IkReal x461=gconst39*gconst39;
IkReal x462=pz*pz;
IkReal x463=(gconst38*pz);
IkReal x464=((99.4633802333595)*sj2);
IkReal x465=(gconst39*pz);
IkReal x466=((35.4518874676428)*py);
IkReal x467=((2400.0)*pz);
IkReal x468=((590.86479112738)*py);
IkReal x469=((1657.72300388932)*sj2);
IkReal x470=((20000.0)*x462);
CheckValue<IkReal> x471 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst38))+((x465*x468))+((x465*x469))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst39))+(((4223.0)*x463))+(((0.57766479112738)*x465))+(((-1.0)*gconst39*x464))+(((-1.0)*gconst39*x466)))),IkReal(((633.450000635431)+(((-4223.0)*x465))+(((253.38)*gconst39))+((x463*x468))+((x463*x469))+(((-0.0346598874676428)*gconst38))+(((0.00182349530427826)*sj2))+(((0.57766479112738)*x463))+(((-1.0)*gconst38*x466))+(((-1.0)*gconst38*x464))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x471.valid){
continue;
}
CheckValue<IkReal> x472=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x461*x467))+(((-1.0)*x460*x470))+(((0.00264)*gconst38))+(((6000.0)*x465))+(((-0.044)*x463))+(((-72.0)*x461))+(((-72.0)*x460))+(((-360.0)*gconst39))+((x460*x467))+(((-1.0)*x461*x470)))),-1);
if(!x472.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x471.value)+(((1.5707963267949)*(x472.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x473=IKsin(j1);
IkReal x474=IKcos(j1);
IkReal x475=((0.12)*pz);
IkReal x476=pz*pz;
IkReal x477=gconst39*gconst39;
IkReal x478=((1.32e-7)*gconst38);
IkReal x479=((0.3)*pz);
IkReal x480=((0.018)*gconst39);
IkReal x481=(gconst38*pz);
IkReal x482=((1.0)*pz);
IkReal x483=((1.32e-6)*pz);
IkReal x484=(gconst38*gconst39);
IkReal x485=x474*x474;
IkReal x486=((2.2e-6)*x481);
IkReal x487=((1.0)*x476);
IkReal x488=(gconst38*x474);
IkReal x489=(gconst39*x474);
IkReal x490=((2.0)*x476);
IkReal x491=((0.06)*x473);
IkReal x492=(gconst39*x473);
IkReal x493=(x475+x478);
IkReal x494=(x473*x474);
IkReal x495=(x477*x485);
IkReal x496=(x487+x486);
evalcond[0]=((-0.21115)+((pz*x489))+(((-0.15)*x474))+(((-0.06)*x489))+(((-1.1e-6)*x473))+((gconst38*x491))+(((-1.0)*x473*x481)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x482*x492))+(((0.06)*x488))+(((-1.0)*x474*x481))+(((-0.029543239556369)*py))+(((0.15)*x473))+((gconst39*x491))+(((-0.0828861501944662)*sj2))+(((-1.1e-6)*x474)));
evalcond[2]=((0.0253474453653594)+(((-1.0)*x496))+(((-1.0)*x480))+(((1.452e-12)*x474))+(((1.32e-6)*x474*x481))+((x483*x492))+x493+(((-7.92e-8)*x492))+((gconst39*x479))+(((-1.0)*(py*py)))+(((-7.92e-8)*x488))+(((-1.98e-7)*x473))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+((x485*x486))+(((-0.0072)*x495))+(((0.24)*pz*x495))+(((-0.01889999999879)*x485))+(((-1.0)*x496))+(((-1.0)*x475*x485))+(((0.018)*x473*x488))+((x476*x485))+(((-1.32e-7)*x473*x489))+(((-0.24)*x473*x481*x489))+(((-1.0)*x475*x477))+((gconst39*x479*x485))+(((0.0072)*x484*x494))+(((2.2e-6)*pz*x473*x489))+((x484*x490*x494))+(((0.0036)*x477))+(((-1.0)*x490*x495))+(((-3.3e-7)*x494))+(((-1.0)*x473*x479*x488))+x493+(((-1.0)*x480*x485))+((x476*x477))+(((-1.0)*x478*x485)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x497=(cj1*gconst39);
IkReal x498=((0.0295301092415339)*sj2);
IkReal x499=((0.999563891228661)*cj2);
IkReal x500=(gconst38*sj1);
IkReal x501=((((-1.0)*gconst39*sj1))+(((-1.0)*cj1*gconst38)));
IkReal x502=((((-1.0)*x499*x500))+((x497*x499))+((x497*x498))+(((-1.0)*x498*x500)));
CheckValue<IkReal> x505 = IKatan2WithCheck(IkReal(x501),IkReal(x502),IKFAST_ATAN2_MAGTHRESH);
if(!x505.valid){
continue;
}
IkReal x503=((1.0)*(x505.value));
if((((x501*x501)+(x502*x502))) < -0.00001)
continue;
CheckValue<IkReal> x506=IKPowWithIntegerCheck(IKabs(IKsqrt(((x501*x501)+(x502*x502)))),-1);
if(!x506.valid){
continue;
}
if( (((x506.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x506.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x504=IKasin(((x506.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x503))+x504);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x503))+(((-1.0)*x504)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x507=(pz*sj0);
IkReal x508=((590.86479112738)*py);
IkReal x509=((99.4633802333595)*sj2);
IkReal x510=(cj0*pz);
IkReal x511=((1657.72300388932)*sj2);
IkReal x512=((35.4518874676428)*py);
CheckValue<IkReal> x513 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+((x510*x511))+(((-253.38)*sj0))+(((-1.0)*cj0*x509))+(((4223.0)*x507))+(((-248.658450583399)*sj2))+(((0.57766479112738)*x510))+((x508*x510))+(((-1.0)*cj0*x512))+(((-0.0346598874676428)*cj0)))),IkReal(((633.450000635431)+(((0.57766479112738)*x507))+((x507*x511))+(((-1.0)*sj0*x509))+(((253.38)*cj0))+(((-0.0346598874676428)*sj0))+((x507*x508))+(((-4223.0)*x510))+(((0.00182349530427826)*sj2))+(((-1.0)*sj0*x512))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x513.valid){
continue;
}
CheckValue<IkReal> x514=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((-0.044)*x507))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-360.0)*cj0))+(((6000.0)*x510)))),-1);
if(!x514.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x513.value)+(((1.5707963267949)*(x514.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x515=IKcos(j1);
IkReal x516=IKsin(j1);
IkReal x517=((0.12)*pz);
IkReal x518=cj0*cj0;
IkReal x519=pz*pz;
IkReal x520=((1.32e-7)*sj0);
IkReal x521=((2.2e-6)*pz);
IkReal x522=((0.06)*sj0);
IkReal x523=((0.3)*pz);
IkReal x524=((1.0)*pz);
IkReal x525=x515*x515;
IkReal x526=(sj0*x521);
IkReal x527=((1.0)*x519);
IkReal x528=(cj0*x516);
IkReal x529=(cj0*x515);
IkReal x530=(sj0*x515);
IkReal x531=((2.0)*x519);
IkReal x532=(x520+x517);
IkReal x533=(x515*x516);
IkReal x534=(sj0*x525);
IkReal x535=(cj0*x525);
IkReal x536=(pz*x530);
IkReal x537=(x518*x525);
IkReal x538=(x526+x527);
evalcond[0]=((-0.21115)+((pz*x529))+(((-0.15)*x515))+((x516*x522))+(((-1.0)*sj0*x516*x524))+(((-0.06)*x529))+(((-1.1e-6)*x516)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x524*x528))+(((-1.0)*x524*x530))+(((0.06)*x528))+((x515*x522))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((-1.1e-6)*x515))+(((0.15)*x516)));
evalcond[2]=((0.0253474453653594)+(((-1.98e-7)*x516))+((cj0*x523))+(((1.452e-12)*x515))+(((1.32e-6)*pz*x528))+(((-1.0)*x538))+x532+(((-7.92e-8)*x528))+(((-7.92e-8)*x530))+(((-1.0)*(py*py)))+(((1.32e-6)*x536))+(((-0.018)*cj0))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+((x519*x525))+((x515*x521*x528))+(((-1.0)*x520*x525))+(((-0.24)*x528*x536))+(((0.018)*x516*x530))+(((0.0036)*x518))+(((-1.0)*x531*x537))+(((-1.0)*x538))+(((-0.01889999999879)*x525))+(((-3.3e-7)*x533))+(((-1.32e-7)*x515*x528))+(((-0.018)*x535))+(((-1.0)*x517*x518))+((x525*x526))+(((-1.0)*x517*x525))+((x528*x530*x531))+((x518*x519))+(((-1.0)*x516*x523*x530))+x532+(((-0.0072)*x537))+((x523*x535))+(((0.0072)*x528*x530))+(((0.24)*pz*x537)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x539=sj0*sj0;
IkReal x540=sj1*sj1;
IkReal x541=cj0*cj0;
IkReal x542=cj2*cj2;
IkReal x543=cj1*cj1;
IkReal x544=sj2*sj2;
IkReal x545=(cj2*sj2);
IkReal x546=((1145.753020896)*x542);
IkReal x547=(cj0*cj1*sj0*sj1);
IkReal x548=(x541*x543);
IkReal x549=(x539*x540);
j3eval[0]=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
j3eval[1]=((((-135.39589482084)*x545*x547))+((x544*x549))+((x544*x548))+(((-2291.50604179201)*x542*x547))+(((2293.50604179201)*x547))+(((67.6979474104201)*x545*x548))+(((67.6979474104201)*x545*x549))+(((-2.0)*x544*x547))+(((1146.753020896)*x540*x541))+(((1146.753020896)*x539*x543))+((x546*x549))+((x546*x548)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x550=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x550.valid){
continue;
}
sj3array[0]=((x550.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x551=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x551.valid){
continue;
}
sj3array[0]=((x551.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x552=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x552.valid){
continue;
}
sj3array[0]=((x552.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x553=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x553.valid){
continue;
}
sj3array[0]=((x553.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x554=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x554.valid){
continue;
}
sj3array[0]=((x554.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x555=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x555.valid){
continue;
}
sj3array[0]=((x555.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x556=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x556.valid){
continue;
}
sj3array[0]=((x556.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x557=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x557.valid){
continue;
}
sj3array[0]=((x557.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x558=(sj0*sj1);
IkReal x559=((0.999563891228661)*cj2);
IkReal x560=((0.0295301092415339)*sj2);
IkReal x561=(cj0*cj1);
IkReal x562=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
IkReal x563=((((-1.0)*x558*x560))+((x560*x561))+(((-1.0)*x558*x559))+((x559*x561)));
CheckValue<IkReal> x566 = IKatan2WithCheck(IkReal(x562),IkReal(x563),IKFAST_ATAN2_MAGTHRESH);
if(!x566.valid){
continue;
}
IkReal x564=((1.0)*(x566.value));
if((((x563*x563)+(x562*x562))) < -0.00001)
continue;
CheckValue<IkReal> x567=IKPowWithIntegerCheck(IKabs(IKsqrt(((x563*x563)+(x562*x562)))),-1);
if(!x567.valid){
continue;
}
if( (((x567.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x567.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x565=IKasin(((x567.value)*(IKcos(r00))));
j3array[0]=(x565+(((-1.0)*x564)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x565))+(((-1.0)*x564)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x568=pz*pz;
IkReal x569=py*py;
IkReal x570=px*px;
IkReal x571=((1.0)*pz);
IkReal x572=(px*pz);
IkReal x573=((0.00108)+(((-2.2e-6)*x572))+(((1.32e-7)*px))+(((-0.036)*pz))+(((0.3)*x568)));
IkReal x574=((-7.92e-9)+(((0.018)*px))+(((2.64e-7)*pz))+(((-2.2e-6)*x568))+(((-0.3)*x572)));
CheckValue<IkReal> x577 = IKatan2WithCheck(IkReal(x573),IkReal(x574),IKFAST_ATAN2_MAGTHRESH);
if(!x577.valid){
continue;
}
IkReal x575=((1.0)*(x577.value));
if((((x573*x573)+(x574*x574))) < -0.00001)
continue;
CheckValue<IkReal> x578=IKPowWithIntegerCheck(IKabs(IKsqrt(((x573*x573)+(x574*x574)))),-1);
if(!x578.valid){
continue;
}
if( (((x578.value)*(((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((-1.0)*x569*x571))+(((6.558858504e-9)*sj2))+(((-1.0)*x570*x571))+(((0.06)*x570))+(((-1.93769928e-10)*cj2))+(((0.18)*x568))+(((0.06)*x569))+(((0.00012)*py))+(((-1.0)*x571*(pz*pz)))+(((-1.093143084e-7)*pz*sj2))+(((3.2294988e-9)*cj2*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x578.value)*(((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((-1.0)*x569*x571))+(((6.558858504e-9)*sj2))+(((-1.0)*x570*x571))+(((0.06)*x570))+(((-1.93769928e-10)*cj2))+(((0.18)*x568))+(((0.06)*x569))+(((0.00012)*py))+(((-1.0)*x571*(pz*pz)))+(((-1.093143084e-7)*pz*sj2))+(((3.2294988e-9)*cj2*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x576=IKasin(((x578.value)*(((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((-1.0)*x569*x571))+(((6.558858504e-9)*sj2))+(((-1.0)*x570*x571))+(((0.06)*x570))+(((-1.93769928e-10)*cj2))+(((0.18)*x568))+(((0.06)*x569))+(((0.00012)*py))+(((-1.0)*x571*(pz*pz)))+(((-1.093143084e-7)*pz*sj2))+(((3.2294988e-9)*cj2*pz))))));
j0array[0]=((((-1.0)*x576))+(((-1.0)*x575)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x575))+x576);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x579=px*px;
IkReal x580=(px*pz);
evalcond[0]=((((((((0.018)*px))+(((-0.3)*x580))+(((2.2e-6)*x579))))*(IKcos(j0))))+(((0.002)*px*py))+(px*px*px)+(((((((2.2e-6)*x580))+(((0.3)*x579))+(((-1.32e-7)*px))))*(IKsin(j0))))+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-0.12)*x580))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x580)));
IkReal x581=IKcos(j0);
IkReal x582=IKsin(j0);
IkReal x583=IKcos(j0);
IkReal x584=IKsin(j0);
IkReal x585=IKcos(j0);
evalcond[1]=((2.87440030434653e-5)+(((-0.06)*(px*px)*(py*py)))+(((0.01169999999879)*pz*(py*py)))+(((-5.81309784e-10)*cj2*(pz*pz)))+(((-0.06)*(px*px*px*px)))+(((((((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.000282996786761127)*px))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((0.0111612262253709)*px*pz))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-0.150610218544758)*px*(pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))))*(IKcos(j0))*(IKsin(j0))))+(((((6.96324099683585e-6)+(((7.92e-7)*px*(pz*pz)))+(((-0.0006)*py*(pz*pz)))+(((-1.18059453072e-10)*sj2))+(((0.00193423361023218)*(pz*pz)))+(((-0.00216)*(px*px)))+(((-1.162619568e-10)*cj2*pz))+(((-3.279429252e-8)*sj2*(pz*pz)))+(((3.487858704e-12)*cj2))+(((-0.3)*(py*py)*(pz*pz)))+(((-0.00108)*(py*py)))+(((-5.84066278818272e-9)*px))+(((-2.16e-6)*py))+(((0.036)*pz*(py*py)))+(((-0.6)*(px*px)*(pz*pz)))+(((1.44294887088e-14)*px*sj2))+(((7.2e-5)*py*pz))+(((-2.2e-6)*px*pz*(py*py)))+(((0.072)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((6.56643798030453e-8)*px*pz))+(((3.9353151024e-9)*pz*sj2))+(((2.64e-10)*px*py))+(((-0.000232108033227862)*pz))+(((-2.4049147848e-13)*px*pz*sj2))+(((1.32e-7)*px*(py*py)))+(((-4.262938416e-16)*cj2*px))+(((9.6884964e-10)*cj2*(pz*pz)))+(((7.10489736e-15)*cj2*px*pz))+(((-4.4e-9)*px*py*pz))))*(IKcos(j0))))+(((-1.23962425717664e-10)*sj2))+(((-0.0064474453674406)*pz*(px*px)))+(((0.00036)*py*(pz*pz)))+(((-3.2294988e-9)*cj2*pz*(px*px)))+(((0.3)*(pz*pz*pz*pz)))+(((-1.0)*(py*py)*(pz*pz*pz)))+((pz*(px*px*px*px)))+(((x581*x581)*(((-8.48990360178838e-6)+(((-2.186286168e-7)*pz*sj2*(px*px)))+(((-0.36)*(py*py)*(pz*pz)))+(((0.00024)*py*(px*px)))+(((2.0)*(py*py)*(pz*pz*pz)))+(((0.104105109267539)*(pz*pz*pz)))+(((0.0578948907276212)*pz*(px*px)))+(((-3.87539856e-10)*cj2*(px*px)))+(((-3.9353151024e-8)*sj2*(pz*pz)))+(((-8.64e-7)*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((0.0216)*pz*(py*py)))+(((1.162619568e-9)*cj2*(pz*pz)))+(((1.3117717008e-8)*sj2*(px*px)))+(((2.186286168e-7)*sj2*(pz*pz*pz)))+(((-0.00072)*py*(pz*pz)))+(((-2.0)*pz*(px*px*px*px)))+(((4.32e-5)*py*pz))+(((-0.00347369344365727)*(px*px)))+(((-6.4589976e-9)*cj2*(pz*pz*pz)))+(((1.3951434816e-12)*cj2))+(((-0.010098919668157)*(pz*pz)))+(((0.004)*py*(pz*pz*pz)))+(((2.0)*(pz*pz*pz*pz*pz)))+(((0.12)*(px*px)*(py*py)))+(((-2.0)*pz*(px*px)*(py*py)))+(((-6.975717408e-11)*cj2*pz))+(((0.000476335180089419)*pz))+(((-0.000432)*(py*py)))+(((0.12)*(px*px*px*px)))+(((-4.72237812288e-11)*sj2))+(((-0.004)*py*pz*(px*px)))+(((-0.6)*(pz*pz*pz*pz)))+(((2.36118906144e-9)*pz*sj2))))))+(((-0.002)*py*(pz*pz*pz)))+(((-0.0011339999999274)*(py*py)))+(((x582*x582)*(((1.04544e-15)+(((-4.84e-12)*(pz*pz*pz)))+(((-0.0054)*(px*px)))+(((0.09)*pz*(px*px)))+(((8.712e-13)*(pz*pz)))+(((-5.2272e-14)*pz))))))+(((3.2294988e-9)*cj2*(pz*pz*pz)))+(((1.93769928e-10)*cj2*(px*px)))+(((-0.00012)*py*(px*px)))+(((-2.2679999998548e-6)*py))+(((-1.093143084e-7)*sj2*(pz*pz*pz)))+((pz*(px*px)*(py*py)))+(((((3.50439767290963e-10)+(((3.279429252e-8)*px*pz*sj2))+(((1.81443798030453e-8)*(pz*pz)))+(((-4.4e-6)*(pz*pz*pz*pz)))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-9.78052557636544e-9)*pz))+(((-4.4e-9)*py*(pz*pz)))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((0.0006)*px*py*pz))+(((1.056e-6)*(pz*pz*pz)))+(((-7.92e-9)*(py*py)))))*(IKsin(j0))))+(((2.339999999758e-5)*py*pz))+(((3.66225163896554e-12)*cj2))+(((x583*x583)*(((5.7024e-11)+(((4.4e-6)*(pz*pz*pz*pz)))+(((-4.752e-8)*(px*px)))+(((-0.324)*px*(pz*pz)))+(((9.504e-8)*(pz*pz)))+(((0.036)*(px*px*px)))+(((1.8)*px*(pz*pz*pz)))+(((-3.8016e-9)*pz))+(((-1.056e-6)*(pz*pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.01944)*px*pz))+(((-0.0003888)*px))+(((-1.32e-5)*(px*px)*(pz*pz)))+(((1.584e-6)*pz*(px*px)))))*(IKsin(j0))))+(((0.000386846722046436)*(px*px)))+(((1.27897740814773e-9)*pz*sj2))+(((x584*x584)*(((((-8.8e-6)*px*(pz*pz*pz)))+(((-0.00432)*(px*px)))+(((1.584e-6)*px*(pz*pz)))+(((-9.504e-8)*px*pz))+(((-1.2)*(px*px)*(pz*pz)))+(((1.9008e-9)*px))+(((0.144)*pz*(px*px)))))*(IKcos(j0))))+(((-1.0)*(pz*pz*pz*pz*pz)))+(((-0.00016048511076294)*pz))+(((0.002)*py*pz*(px*px)))+(((-3.77851359560923e-11)*cj2*pz))+(((-6.558858504e-9)*sj2*(px*px)))+(((-0.00710054016570371)*(pz*pz)))+(((0.0154474453650206)*(pz*pz*pz)))+(((1.9676575512e-8)*sj2*(pz*pz)))+(((1.093143084e-7)*pz*sj2*(px*px)))+(((x585*x585*x585)*(((-7.776e-6)+(((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((0.144)*(pz*pz*pz)))+(((-9.504e-10)*px))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.01296)*(pz*pz)))+(((0.0005184)*pz))+(((-0.6)*(pz*pz*pz*pz)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))))+(((0.18)*(py*py)*(pz*pz))));
IkReal x586=IKsin(j0);
IkReal x587=IKcos(j0);
IkReal x588=IKsin(j0);
IkReal x589=IKcos(j0);
IkReal x590=IKcos(j0);
evalcond[2]=((((((((-2.64e-10)*px*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-0.0006)*py*(px*px)))+(((-0.6)*(px*px*px*px)))+(((-0.3)*(px*px)*(py*py)))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((-6.56643798030453e-8)*px*pz))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((9.6884964e-10)*cj2*(px*px)))+(((5.84066278818272e-9)*px))+(((4.4e-6)*px*(pz*pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.00193423361023218)*(px*px)))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKsin(j0))))+(((-1.0)*(px*px*px)*(py*py)))+(((-0.24)*px*(pz*pz*pz)))+(((3.2294988e-9)*cj2*(px*px*px)))+(((x586*x586)*(((((-5.808e-13)*px*pz))+(((-0.09)*(px*px*px)))+(((4.84e-12)*px*(pz*pz)))+(((1.7424e-14)*px))))))+(((0.000479066717391088)*px))+(((0.0064474453674406)*(px*px*px)))+(((0.002)*px*py*(pz*pz)))+(((-0.01889999999879)*px*(py*py)))+(((6.10375273160923e-11)*cj2*px))+(((-0.00024)*px*py*pz))+(((0.00530969344380247)*px*pz))+((px*(pz*pz*pz*pz)))+(((x587*x587*x587)*(((((4.4e-6)*(px*px*px*px)))+(((0.00648)*px*pz))+(((-0.0001296)*px))+(((0.036)*(px*px*px)))+(((5.28e-7)*pz*(px*px)))+(((-1.584e-8)*(px*px)))+(((-4.4e-6)*(px*px)*(pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.6)*px*(pz*pz*pz)))+(((-0.108)*px*(pz*pz)))))))+(((-1.0)*(px*px*px*px*px)))+(((-1.3117717008e-8)*px*pz*sj2))+(((-3.779999999758e-5)*px*py))+(((x588*x588)*(((((-0.072)*(px*px*px)))+(((3.168e-8)*(px*px)))+(((8.8e-6)*(px*px)*(pz*pz)))+(((1.2)*pz*(px*px*px)))+(((-1.056e-6)*pz*(px*px)))))*(IKcos(j0))))+(((x589*x589)*(((((-0.0578948907276212)*(px*px*px)))+(((-7.75079712e-10)*cj2*px*pz))+(((2.0)*(px*px*px)*(py*py)))+(((-7.8706302048e-10)*px*sj2))+(((0.004)*py*(px*px*px)))+(((0.24)*px*pz*(py*py)))+(((-2.186286168e-7)*px*sj2*(pz*pz)))+(((-2.0)*px*(pz*pz*pz*pz)))+(((-1.44e-5)*px*py))+(((6.4589976e-9)*cj2*px*(pz*pz)))+(((-0.00014149839336314)*px))+(((-0.004)*px*py*(pz*pz)))+(((0.00048)*px*py*pz))+(((-0.0072)*px*(py*py)))+(((2.325239136e-11)*cj2*px))+(((2.186286168e-7)*sj2*(px*px*px)))+(((0.00558061311210466)*px*pz))+(((2.6235434016e-8)*px*pz*sj2))+(((-6.4589976e-9)*cj2*(px*px*px)))+(((2.0)*(px*px*px*px*px)))+(((-0.0753051092675388)*px*(pz*pz)))+(((0.48)*px*(pz*pz*pz)))+(((-2.0)*px*(py*py)*(pz*pz)))))))+(((-1.093143084e-7)*sj2*(px*px*px)))+(((1.093143084e-7)*px*sj2*(pz*pz)))+(((x590*x590)*(((((7.92e-7)*px*(pz*pz)))+(((9.504e-10)*px))+(((1.32e-5)*pz*(px*px*px)))+(((-7.92e-7)*(px*px*px)))+(((0.216)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-4.752e-8)*px*pz))+(((-1.8)*(px*px)*(pz*pz)))+(((0.6)*(px*px*px*px)))))*(IKsin(j0))))+(((-0.12)*px*pz*(py*py)))+(((-0.0298474453650206)*px*(pz*pz)))+(((-0.002)*py*(px*px*px)))+(((((((-0.24)*(px*px*px*px)))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((0.107410218544758)*pz*(px*px)))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((-0.00471661311268546)*(px*px)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.008)*py*pz*(px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.06604042862773e-9)*px*sj2))+((px*(py*py)*(pz*pz)))+(((((((3.279429252e-8)*px*pz*sj2))+(((-9.73443798030453e-8)*(px*px)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((2.2e-6)*(px*px)*(py*py)))+(((2.4049147848e-13)*sj2*(px*px)))+(((-0.018)*px*(py*py)))+(((4.4e-6)*(px*px)*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((-5.28e-7)*pz*(px*px)))+(((4.4e-9)*py*(px*px)))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((-1.9676575512e-9)*px*sj2))+(((-7.10489736e-15)*cj2*(px*px)))+(((0.0006)*px*py*pz))))*(IKcos(j0))))+(((-3.2294988e-9)*cj2*px*(pz*pz)))+(((3.87539856e-10)*cj2*px*pz)));
IkReal x591=IKcos(j0);
IkReal x592=IKsin(j0);
IkReal x593=IKsin(j0);
IkReal x594=IKcos(j0);
IkReal x595=IKcos(j0);
evalcond[3]=((5.01879418251366e-10)+(((0.0072)*(px*px*px)))+(((x591*x591)*(((7.776e-6)+(((-0.0005184)*pz))+(((2.8512e-9)*px))+(((-0.144)*(pz*pz*pz)))+(((-2.64e-7)*(px*px*px)))+(((4.4e-6)*pz*(px*px*px)))+(((0.216)*pz*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((0.01296)*(pz*pz)))+(((-1.32e-5)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-1.8)*(px*px)*(pz*pz)))+(((-1.4256e-7)*px*pz))+(((2.376e-6)*px*(pz*pz)))))*(IKsin(j0))))+(((-1.065734604e-15)*cj2*pz))+(((x592*x592)*(((-5.7024e-11)+(((-4.4e-6)*(pz*pz*pz*pz)))+(((1.584e-8)*(px*px)))+(((-0.00648)*px*pz))+(((3.8016e-9)*pz))+(((4.4e-6)*(px*px)*(pz*pz)))+(((-9.504e-8)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((-5.28e-7)*pz*(px*px)))+(((0.108)*px*(pz*pz)))+(((0.6)*pz*(px*px*px)))+(((0.0001296)*px))+(((-0.036)*(px*px*px)))+(((1.056e-6)*(pz*pz*pz)))))*(IKcos(j0))))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((3.3e-7)*pz*(py*py)))+(((-2.16442330632e-15)*sj2))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((3.3e-7)*(pz*pz*pz)))+(((-0.0146948907324612)*px*(pz*pz)))+(((-0.48)*px*(pz*pz*pz)))+(((-0.00018250160663686)*px))+(((-5.94e-8)*(pz*pz)))+(((-0.24)*pz*(px*px*px)))+(((-0.00048)*px*py*pz))+(((6.6e-10)*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((((8.48990360283382e-6)+(((-6.4589976e-9)*cj2*pz*(px*px)))+(((3.87539856e-10)*cj2*(px*px)))+(((-2.186286168e-7)*sj2*(pz*pz*pz)))+(((0.004)*py*pz*(px*px)))+(((-0.0216)*pz*(py*py)))+(((0.0321051092723788)*pz*(px*px)))+(((0.36)*(py*py)*(pz*pz)))+(((-0.000476335180141691)*pz))+(((-1.3951434816e-12)*cj2))+(((0.0100989196690282)*(pz*pz)))+(((-0.104105109272379)*(pz*pz*pz)))+(((-0.004)*py*(pz*pz*pz)))+(((-1.162619568e-9)*cj2*(pz*pz)))+(((-4.32e-5)*py*pz))+(((-0.12)*(px*px)*(py*py)))+(((-2.0)*(py*py)*(pz*pz*pz)))+(((-2.36118906144e-9)*pz*sj2))+(((2.0)*pz*(px*px)*(py*py)))+(((-0.00024)*py*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((-2.0)*(pz*pz*pz*pz*pz)))+(((3.9353151024e-8)*sj2*(pz*pz)))+(((4.72237812288e-11)*sj2))+(((6.975717408e-11)*cj2*pz))+(((2.186286168e-7)*pz*sj2*(px*px)))+(((2.0)*pz*(px*px*px*px)))+(((6.4589976e-9)*cj2*(pz*pz*pz)))+(((-0.12)*(px*px*px*px)))+(((0.000432)*(py*py)))+(((8.64e-7)*py))+(((0.00072)*py*(pz*pz)))+(((-1.3117717008e-8)*sj2*(px*px)))+(((-0.00192630655634273)*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.325239136e-11)*cj2*px))+(((3.3e-7)*pz*(px*px)))+(((-1.98e-8)*(py*py)))+(((-0.24)*px*pz*(py*py)))+(((-5.9886569708561e-9)*pz))+(((2.0)*(px*px*px)*(pz*pz)))+(((x593*x593)*(((-1.4256e-10)+(((-0.0108000000005808)*px*pz))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((-1.188e-7)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((0.000324000000017424)*px))+(((0.09000000000484)*px*(pz*pz)))))))+(((-1.98e-8)*(px*px)))+(((3.6073721772e-14)*pz*sj2))+(((x594*x594*x594)*(((((-0.0002592)*px))+(((0.01296)*px*pz))+(((1.2)*px*(pz*pz*pz)))+(((-0.216)*px*(pz*pz)))+(((-3.168e-8)*(px*px)))+(((1.056e-6)*pz*(px*px)))+(((-8.8e-6)*(px*px)*(pz*pz)))))))+(((((-2.73752409929154e-5)+(((-9.6884964e-10)*cj2*(pz*pz)))+(((-3.54453721165756e-9)*px))+(((-7.2e-5)*py*pz))+(((1.06595620194293e-7)*px*pz))+(((-3.487858704e-12)*cj2))+(((0.3)*(pz*pz*pz*pz)))+(((0.0006)*py*(pz*pz)))+(((0.00108)*(py*py)))+(((-2.64e-10)*px*py))+(((6.6e-6)*px*(pz*pz*pz)))+(((2.16e-6)*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-1.32e-7)*(px*px*px)))+(((2.2e-6)*pz*(px*px*px)))+(((-0.072)*(pz*pz*pz)))+(((0.000782908033097182)*pz))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((1.162619568e-10)*cj2*pz))+(((2.2e-6)*px*pz*(py*py)))+(((0.9)*(px*px)*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-0.036)*pz*(py*py)))+(((-1.32e-7)*px*(py*py)))+(((-1.188e-6)*px*(pz*pz)))+(((0.00324)*(px*px)))+(((-0.108)*pz*(px*px)))+(((1.18059453072e-10)*sj2))+(((-0.00220423360914318)*(pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.3)*(py*py)*(pz*pz)))+(((-3.9353151024e-9)*pz*sj2))+(((3.279429252e-8)*sj2*(pz*pz)))))*(IKsin(j0))))+(((6.394407624e-17)*cj2))+(((0.00521938688789534)*px*pz))+(((2.0)*px*(pz*pz*pz*pz)))+(((((-1.55648232699454e-10)+(((3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.000585854016548591)*px))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((-0.018)*(px*px*px)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((-2.2e-6)*(pz*pz*pz*pz)))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-4.4e-9)*py*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-0.0119242336091432)*px*pz))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((6.13867442331512e-9)*pz))+(((-3.6e-5)*px*py))+(((0.3)*pz*(px*px*px)))+(((2.2e-6)*(px*px)*(pz*pz)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((7.92e-9)*(px*px)))+(((-2.64e-7)*pz*(px*px)))+(((5.28e-7)*(pz*pz*pz)))+(((-8.28356201942927e-8)*(pz*pz)))+(((0.0006)*px*py*pz))+(((-7.92e-9)*(py*py)))))*(IKcos(j0))))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-3.96e-11)*py))+(((x595*x595)*(((-1.4256e-10)+(((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.0606102185399176)*px*(pz*pz)))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((4.10032132562966e-5)*px))+(((-1.188e-7)*(pz*pz)))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))+(((0.000361226224790112)*px*pz)))))));
IkReal x596=IKcos(j0);
IkReal x597=IKsin(j0);
IkReal x598=IKcos(j0);
IkReal x599=IKcos(j0);
IkReal x600=IKsin(j0);
evalcond[4]=((((-2.186286168e-7)*pz*sj2*(px*px)))+(((x596*x596)*(((((-0.24)*(px*px*px*px)))+(((-2.376e-9)*px))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((7.92e-8)*px*pz))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((0.000683386887604944)*(px*px)))+(((-6.6e-7)*px*(pz*pz)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.0174102185399176)*pz*(px*px)))+(((0.008)*py*pz*(px*px)))+(((-6.6e-7)*(px*px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))))+(((x597*x597)*(((((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((-9.504e-10)*px))+(((-0.6)*(px*px*px*px)))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))*(IKcos(j0))))+(((((((5.90756201942927e-8)*px*pz))+(((0.00976423360914318)*(px*px)))+(((-2.64e-10)*px*py))+(((-3.96e-7)*px*(pz*pz)))+(((2.4049147848e-13)*px*pz*sj2))+(((0.3)*(px*px)*(pz*pz)))+(((-0.0006)*py*(px*px)))+(((-0.3)*(px*px)*(py*py)))+(((-0.036)*pz*(px*px)))+(((4.262938416e-16)*cj2*px))+(((-0.3)*(px*px*px*px)))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((2.2e-6)*px*(pz*pz*pz)))+(((-2.2e-6)*pz*(px*px*px)))+(((9.6884964e-10)*cj2*(px*px)))+(((-2.59413721165756e-9)*px))+(((1.32e-7)*(px*px*px)))+(((-1.44294887088e-14)*px*sj2))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKcos(j0))))+(((0.00024)*py*(px*px)))+(((x598*x598)*(((((-0.00648)*px*pz))+(((1.8)*pz*(px*px*px)))+(((1.32e-5)*(px*px)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((0.108)*px*(pz*pz)))+(((-4.4e-6)*(px*px*px*px)))+(((-1.584e-6)*pz*(px*px)))+(((0.0001296)*px))+(((-0.108)*(px*px*px)))+(((4.752e-8)*(px*px)))))*(IKsin(j0))))+(((-3.3e-7)*px*(pz*pz)))+(((-3.3e-7)*px*(py*py)))+(((-3.6073721772e-14)*px*sj2))+(((-3.87539856e-10)*cj2*(px*px)))+(((-6.6e-10)*px*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((1.3117717008e-8)*sj2*(px*px)))+(((0.0362948907324612)*pz*(px*px)))+(((-2.0)*pz*(px*px*px*px)))+(((3.96e-8)*px*pz))+(((x599*x599*x599)*(((((-0.00432)*(px*px)))+(((-1.2)*(px*px)*(pz*pz)))+(((-5.28e-7)*(px*px*px)))+(((8.8e-6)*pz*(px*px*px)))+(((0.144)*pz*(px*px)))))))+(((-2.0)*(px*px)*(pz*pz*pz)))+(((0.36)*(px*px)*(pz*pz)))+(((((((-0.00558061311268546)*px*pz))+(((-2.186286168e-7)*sj2*(px*px*px)))+(((-2.0)*(px*px*px)*(py*py)))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((0.0753051092723788)*px*(pz*pz)))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((-0.48)*px*(pz*pz*pz)))+(((0.000141498393380564)*px))+(((-0.004)*py*(px*px*px)))+(((-0.00048)*px*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((-2.325239136e-11)*cj2*px))+(((-0.24)*px*pz*(py*py)))+(((6.4589976e-9)*cj2*(px*px*px)))+(((-0.0321051092723788)*(px*px*px)))+(((2.0)*px*(pz*pz*pz*pz)))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-2.0)*(px*px*px*px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((0.12)*(px*px)*(py*py)))+(((8.3646569708561e-9)*px))+(((-2.0)*pz*(px*px)*(py*py)))+(((-0.00304169344394767)*(px*px)))+(((x600*x600)*(((((-2.376e-9)*px))+(((7.92e-8)*px*pz))+(((-6.6e-7)*px*(pz*pz)))+(((-6.6e-7)*(px*px*px)))+(((0.0054000000002904)*(px*px)))+(((-0.09000000000484)*pz*(px*px)))))))+(((1.065734604e-15)*cj2*px))+(((0.12)*(px*px*px*px)))+(((((((-2.2e-6)*(px*px*px*px)))+(((-3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.00544423360914318)*px*pz))+(((-0.9)*pz*(px*px*px)))+(((-6.6e-6)*(px*px)*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-5.90756201942927e-8)*(px*px)))+(((-2.2e-6)*(px*px)*(py*py)))+(((1.9676575512e-9)*px*sj2))+(((7.92e-7)*pz*(px*px)))+(((9.6884964e-10)*cj2*px*pz))+(((3.6e-5)*px*py))+(((-0.3)*px*pz*(py*py)))+(((-5.81309784e-11)*cj2*px))+(((-0.0006)*px*py*pz))+(((7.10489736e-15)*cj2*(px*px)))+(((0.054)*(px*px*px)))+(((-4.4e-9)*py*(px*px)))+(((0.018)*px*(py*py)))+(((-2.4049147848e-13)*sj2*(px*px)))+(((-0.000456254016548591)*px))))*(IKsin(j0))))+(((-0.004)*py*pz*(px*px)))+(((-3.3e-7)*(px*px*px))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x601=px*px;
IkReal x602=pz*pz;
IkReal x603=(cj0*px);
IkReal x604=(px*sj0);
IkReal x605=(pz*sj0);
IkReal x606=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+(((-2272727.27272727)*x604))+sj0+(((909090.909090909)*pz))+(((-7575757.57575758)*x602))+(((-7575757.57575758)*x601))+(((2272727.27272727)*x606))+(((-16.6666666666667)*x603))+(((-16.6666666666667)*x605)));
j1eval[1]=IKsign(((-522.0000000242)+(((2400.0)*pz))+(((6000.0)*x606))+(((-20000.0)*x602))+(((-20000.0)*x601))+(((0.00264)*sj0))+(((-360.0)*cj0))+(((-0.044)*x603))+(((-0.044)*x605))+(((-6000.0)*x604))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x607=pz*pz;
IkReal x608=px*px;
IkReal x609=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x610=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x611=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x607))+(((-7575757.57575758)*x608)));
IkReal x612=((x609*x609)+(x610*x610));
if((((18595041323.314)+(((5165289256476.13)*x608))+(((5165289256476.13)*x607))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x613=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x608))+(((5165289256476.13)*x607))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x619=IKPowWithIntegerCheck(x613,-1);
if(!x619.valid){
continue;
}
IkReal x614=x619.value;
IkReal x620 = x612;
if(IKabs(x620)==0){
continue;
}
IkReal x615=pow(x620,-0.5);
IkReal x616=((1.0)*x615);
IkReal x617=(x611*x614);
if((((1.0)+(((-1.0)*(x617*x617))))) < -0.00001)
continue;
IkReal x618=IKsqrt(((1.0)+(((-1.0)*(x617*x617)))));
if((x612) < -0.00001)
continue;
CheckValue<IkReal> x621=IKPowWithIntegerCheck(IKabs(IKsqrt(x612)),-1);
if(!x621.valid){
continue;
}
if( ((x611*(x621.value))) < -1-IKFAST_SINCOS_THRESH || ((x611*(x621.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x622 = IKatan2WithCheck(IkReal(x609),IkReal(x610),IKFAST_ATAN2_MAGTHRESH);
if(!x622.valid){
continue;
}
IkReal gconst28=((((-1.0)*(IKasin((x611*(x621.value))))))+(((-1.0)*(x622.value))));
IkReal gconst29=((((-1.0)*x610*x616*x617))+(((-1.0)*x609*x616*x618)));
IkReal gconst30=((((-1.0)*x609*x616*x617))+((x610*x615*x618)));
IkReal x623=pz*pz;
IkReal x624=px*px;
if((((18595041323.314)+(((5165289256476.13)*x623))+(((5165289256476.13)*x624))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x627=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x623))+(((5165289256476.13)*x624))+(((-619834710777.135)*pz))))),-1);
if(!x627.valid){
continue;
}
IkReal x625=x627.value;
IkReal x626=((7575757.57575758)*x625);
if( (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x628 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x628.valid){
continue;
}
CheckValue<IkReal> x629 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x629.valid){
continue;
}
CheckValue<IkReal> x630 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x630.valid){
continue;
}
if( (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x631 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x631.valid){
continue;
}
if( (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x632 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x632.valid){
continue;
}
CheckValue<IkReal> x633 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x633.valid){
continue;
}
if( (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if(((((j0*(j0)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))*(j0)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))*(x628.value)))+(((x629.value)*(x630.value)))+(((1.0)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))))+((j0*(x631.value)))+(((-1.0)*j0*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))))+(((x632.value)*(j0)))+(((-1.0)*(x633.value)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j0*(j0)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))*(j0)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))*(x628.value)))+(((x629.value)*(x630.value)))+(((1.0)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))))+((j0*(x631.value)))+(((-1.0)*j0*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625)))))))+(((x632.value)*(j0)))+(((-1.0)*(x633.value)*(IKasin(((((-909090.909090909)*pz*x625))+((x624*x626))+((x623*x626))+(((197727.272736439)*x625))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x634=gconst30*gconst30;
IkReal x635=gconst29*gconst29;
IkReal x636=px*px;
IkReal x637=pz*pz;
IkReal x638=((2400.0)*pz);
IkReal x639=(gconst29*px);
IkReal x640=((1657.72300388932)*sj2);
IkReal x641=(gconst30*px);
IkReal x642=((590.86479112738)*py);
IkReal x643=((99.4633802333595)*sj2);
IkReal x644=(gconst30*pz);
IkReal x645=((35.4518874676428)*py);
IkReal x646=(gconst29*pz);
IkReal x647=((20000.0)*x636);
IkReal x648=((20000.0)*x637);
CheckValue<IkReal> x649=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x634*x638))+((x635*x638))+(((6000.0)*x644))+(((0.00264)*gconst29))+(((-0.044)*x646))+(((-0.044)*x641))+(((-360.0)*gconst30))+(((-1.0)*x635*x647))+(((-1.0)*x635*x648))+(((-6000.0)*x639))+(((-72.0)*x634))+(((-72.0)*x635))+(((-1.0)*x634*x647))+(((-1.0)*x634*x648)))),-1);
if(!x649.valid){
continue;
}
CheckValue<IkReal> x650 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst29))+(((-1.0)*x639*x642))+(((-1.0)*x639*x640))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst30))+((x640*x644))+(((0.57766479112738)*x644))+(((-0.57766479112738)*x639))+(((-1.0)*gconst30*x643))+(((-1.0)*gconst30*x645))+((x642*x644))+(((4223.0)*x646))+(((4223.0)*x641)))),IkReal(((633.450000635431)+(((253.38)*gconst30))+(((4223.0)*x639))+(((-0.0346598874676428)*gconst29))+((x640*x646))+((x640*x641))+(((0.57766479112738)*x641))+(((0.57766479112738)*x646))+((x641*x642))+(((0.00182349530427826)*sj2))+(((-1.0)*gconst29*x643))+(((-1.0)*gconst29*x645))+(((-4223.0)*x644))+(((0.000649951270240118)*py))+((x642*x646)))),IKFAST_ATAN2_MAGTHRESH);
if(!x650.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x649.value)))+(x650.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x651=IKcos(j1);
IkReal x652=IKsin(j1);
IkReal x653=((0.12)*pz);
IkReal x654=pz*pz;
IkReal x655=gconst30*gconst30;
IkReal x656=px*px;
IkReal x657=((1.32e-7)*gconst29);
IkReal x658=(gconst29*gconst30);
IkReal x659=(px*pz);
IkReal x660=(gconst29*pz);
IkReal x661=(gconst30*px);
IkReal x662=(gconst29*px);
IkReal x663=((0.24)*pz);
IkReal x664=((0.018)*gconst30);
IkReal x665=(gconst30*pz);
IkReal x666=((0.24)*px);
IkReal x667=((0.12)*px);
IkReal x668=((0.06)*gconst29);
IkReal x669=x651*x651;
IkReal x670=((2.2e-6)*x660);
IkReal x671=((2.2e-6)*x661);
IkReal x672=((1.0)*x654);
IkReal x673=((1.0)*x651);
IkReal x674=((1.0)*x656);
IkReal x675=((1.32e-6)*x651);
IkReal x676=((1.0)*x652);
IkReal x677=(gconst30*x652);
IkReal x678=(x653+x657);
IkReal x679=(x651*x652);
IkReal x680=(x652*x665);
IkReal x681=((2.2e-6)*x669);
IkReal x682=((0.3)*x669);
IkReal x683=((2.0)*x679);
IkReal x684=(x654*x669);
IkReal x685=(x655*x669);
IkReal x686=(x672+x670+x671);
evalcond[0]=((-0.21115)+((x651*x665))+(((-1.1e-6)*x652))+(((-1.0)*x660*x676))+(((-1.0)*x662*x673))+(((-0.15)*x651))+((x652*x668))+(((-0.06)*gconst30*x651))+(((-1.0)*x661*x676)));
evalcond[1]=((-2.8883239556369e-5)+((x651*x668))+(((-1.1e-6)*x651))+(((-1.0)*x660*x673))+(((-0.029543239556369)*py))+(((-1.0)*x665*x676))+(((-0.0828861501944662)*sj2))+((x652*x662))+(((0.06)*x677))+(((0.15)*x652))+(((-1.0)*x661*x673)));
evalcond[2]=((0.0253474453653594)+(((0.3)*x665))+((x660*x675))+((x661*x675))+(((-7.92e-8)*x677))+(((-1.0)*x686))+(((1.32e-6)*x680))+(((1.452e-12)*x651))+(((-1.0)*x664))+(((-1.32e-6)*x652*x662))+x678+(((-7.92e-8)*gconst29*x651))+(((-1.98e-7)*x652))+(((-0.3)*x662))+(((-1.0)*(py*py)))+(((-1.0)*x674))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((2.2e-6)*x665*x679))+((x663*x685))+(((-0.3)*x661*x679))+(((-2.2e-6)*x662*x679))+(((-1.0)*x655*x666*x679))+(((2.0)*x656*x685))+(((-1.0)*x686))+(((4.0)*x658*x659*x669))+(((-1.0)*x662*x682))+(((-1.0)*x659*x683))+(((-1.0)*x658*x663*x679))+(((-0.0072)*x685))+(((-1.0)*x658*x666*x669))+(((0.018)*gconst29*x679))+(((-2.0)*x655*x684))+((x654*x655))+(((-0.01889999999879)*x669))+((x669*x671))+((x669*x670))+(((4.0)*x655*x659*x679))+((x667*x679))+(((-1.0)*x657*x669))+(((-1.0)*x669*x674))+x678+x684+((x654*x658*x683))+(((0.0036)*x655))+(((-0.3)*x660*x679))+(((-3.3e-7)*x679))+(((-2.0)*x658*x659))+((x658*x667))+(((-1.32e-7)*x651*x677))+(((-1.0)*x653*x669))+(((-1.0)*x656*x658*x683))+(((-1.0)*x664*x669))+(((-1.0)*x655*x674))+((x665*x682))+(((-1.0)*x653*x655))+(((0.0072)*x658*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x687=(cj1*gconst30);
IkReal x688=((0.0295301092415339)*sj2);
IkReal x689=((0.999563891228661)*cj2);
IkReal x690=(gconst29*sj1);
IkReal x691=((((-1.0)*cj1*gconst29))+(((-1.0)*gconst30*sj1)));
IkReal x692=(((x687*x689))+((x687*x688))+(((-1.0)*x688*x690))+(((-1.0)*x689*x690)));
CheckValue<IkReal> x695 = IKatan2WithCheck(IkReal(x691),IkReal(x692),IKFAST_ATAN2_MAGTHRESH);
if(!x695.valid){
continue;
}
IkReal x693=((1.0)*(x695.value));
if((((x691*x691)+(x692*x692))) < -0.00001)
continue;
CheckValue<IkReal> x696=IKPowWithIntegerCheck(IKabs(IKsqrt(((x691*x691)+(x692*x692)))),-1);
if(!x696.valid){
continue;
}
if( (((x696.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x696.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x694=IKasin(((x696.value)*(IKcos(r00))));
j3array[0]=(x694+(((-1.0)*x693)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x693))+(((-1.0)*x694)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x697=pz*pz;
IkReal x698=px*px;
IkReal x699=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x700=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x701=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x697))+(((-7575757.57575758)*x698)));
IkReal x702=x701*x701;
IkReal x703=((x700*x700)+(x699*x699));
if((((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x698))+(((5165289256476.13)*x697)))) < -0.00001)
continue;
IkReal x704=IKabs(IKsqrt(((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x698))+(((5165289256476.13)*x697)))));
CheckValue<IkReal> x711=IKPowWithIntegerCheck(x704,-1);
if(!x711.valid){
continue;
}
IkReal x705=x711.value;
IkReal x712 = x703;
if(IKabs(x712)==0){
continue;
}
IkReal x706=pow(x712,-0.5);
CheckValue<IkReal> x713=IKPowWithIntegerCheck(x704,-2);
if(!x713.valid){
continue;
}
IkReal x707=x713.value;
IkReal x708=((1.0)*x706);
IkReal x709=(x701*x705);
IkReal x710=(x702*x707);
if((x703) < -0.00001)
continue;
CheckValue<IkReal> x714=IKPowWithIntegerCheck(IKabs(IKsqrt(x703)),-1);
if(!x714.valid){
continue;
}
if( ((x701*(x714.value))) < -1-IKFAST_SINCOS_THRESH || ((x701*(x714.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x715 = IKatan2WithCheck(IkReal(x699),IkReal(x700),IKFAST_ATAN2_MAGTHRESH);
if(!x715.valid){
continue;
}
IkReal gconst31=((3.14159265358979)+(IKasin((x701*(x714.value))))+(((-1.0)*(x715.value))));
if((((1.0)+(((-1.0)*x710)))) < -0.00001)
continue;
IkReal gconst32=((((-1.0)*x700*x708*x709))+((x699*x708*(IKsqrt(((1.0)+(((-1.0)*x710))))))));
if((((1.0)+(((-1.0)*x710)))) < -0.00001)
continue;
IkReal gconst33=((((-1.0)*x700*x708*(IKsqrt(((1.0)+(((-1.0)*x710)))))))+(((-1.0)*x699*x708*x709)));
IkReal x716=x699;
IkReal x717=x700;
CheckValue<IkReal> x718 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x718.valid){
continue;
}
CheckValue<IkReal> x719 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x719.valid){
continue;
}
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x720=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x720.valid){
continue;
}
if( (((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x721=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x721.valid){
continue;
}
if( (((x721.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x721.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x722 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x722.valid){
continue;
}
CheckValue<IkReal> x723 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x723.valid){
continue;
}
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x724=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x724.valid){
continue;
}
if( (((x724.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x724.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x725=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x725.valid){
continue;
}
if( (((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x727=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x727.valid){
continue;
}
if( (((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x728=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x728.valid){
continue;
}
if( (((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x729 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x729.valid){
continue;
}
CheckValue<IkReal> x730 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x730.valid){
continue;
}
CheckValue<IkReal> x731 = IKatan2WithCheck(IkReal(x716),IkReal(x717),IKFAST_ATAN2_MAGTHRESH);
if(!x731.valid){
continue;
}
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x732=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x732.valid){
continue;
}
if( (((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x717*x717)+(x716*x716))) < -0.00001)
continue;
CheckValue<IkReal> x733=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x716*x716)))),-1);
if(!x733.valid){
continue;
}
if( (((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((9.86960440108936)+(((-3.14159265358979)*(x718.value)))+(((x719.value)*(j0)))+((j0*(j0)))+(((3.14159265358979)*(IKasin(((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x721.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+(((x722.value)*(x723.value)))+(((-3.14159265358979)*(j0)))+(((1.0)*(IKasin(((x724.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(x726.value)*(IKasin(((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x729.value)))+(((-3.14159265358979)*j0))+((j0*(x730.value)))+(((-3.14159265358979)*(x731.value)))+(((3.14159265358979)*(IKasin(((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz))))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+(((-3.14159265358979)*(x718.value)))+(((x719.value)*(j0)))+((j0*(j0)))+(((3.14159265358979)*(IKasin(((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x721.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+(((x722.value)*(x723.value)))+(((-3.14159265358979)*(j0)))+(((1.0)*(IKasin(((x724.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(x726.value)*(IKasin(((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x729.value)))+(((-3.14159265358979)*j0))+((j0*(x730.value)))+(((-3.14159265358979)*(x731.value)))+(((3.14159265358979)*(IKasin(((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz))))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x734=gconst33*gconst33;
IkReal x735=gconst32*gconst32;
IkReal x736=pz*pz;
IkReal x737=px*px;
IkReal x738=(gconst32*pz);
IkReal x739=((590.86479112738)*py);
IkReal x740=(gconst33*pz);
IkReal x741=((2400.0)*pz);
IkReal x742=(gconst32*px);
IkReal x743=((35.4518874676428)*py);
IkReal x744=((99.4633802333595)*sj2);
IkReal x745=(gconst33*px);
IkReal x746=((1657.72300388932)*sj2);
IkReal x747=((20000.0)*x737);
IkReal x748=((20000.0)*x736);
CheckValue<IkReal> x749 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst32))+(((-0.57766479112738)*x742))+(((-1.0)*x742*x746))+((x739*x740))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst33))+((x740*x746))+(((4223.0)*x745))+(((-1.0)*x739*x742))+(((0.57766479112738)*x740))+(((-1.0)*gconst33*x743))+(((-1.0)*gconst33*x744))+(((4223.0)*x738)))),IkReal(((633.450000635431)+(((-1.0)*gconst32*x743))+(((-1.0)*gconst32*x744))+(((0.57766479112738)*x738))+((x745*x746))+((x738*x746))+(((253.38)*gconst33))+((x739*x745))+(((-0.0346598874676428)*gconst32))+(((0.00182349530427826)*sj2))+(((4223.0)*x742))+(((-4223.0)*x740))+(((0.57766479112738)*x745))+((x738*x739))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x749.valid){
continue;
}
CheckValue<IkReal> x750=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x734*x741))+(((-0.044)*x745))+(((-6000.0)*x742))+(((0.00264)*gconst32))+(((6000.0)*x740))+(((-360.0)*gconst33))+(((-72.0)*x734))+(((-72.0)*x735))+(((-1.0)*x734*x748))+(((-1.0)*x734*x747))+(((-0.044)*x738))+(((-1.0)*x735*x748))+(((-1.0)*x735*x747))+((x735*x741)))),-1);
if(!x750.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x749.value)+(((1.5707963267949)*(x750.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x751=IKsin(j1);
IkReal x752=IKcos(j1);
IkReal x753=((0.12)*pz);
IkReal x754=gconst33*gconst33;
IkReal x755=px*px;
IkReal x756=pz*pz;
IkReal x757=((1.32e-7)*gconst32);
IkReal x758=(gconst33*px);
IkReal x759=((2.2e-6)*gconst32);
IkReal x760=(gconst32*pz);
IkReal x761=((0.018)*gconst33);
IkReal x762=((1.0)*pz);
IkReal x763=((0.3)*px);
IkReal x764=(px*pz);
IkReal x765=(gconst33*pz);
IkReal x766=x752*x752;
IkReal x767=((2.2e-6)*x758);
IkReal x768=(pz*x759);
IkReal x769=((1.0)*x756);
IkReal x770=(gconst32*x751);
IkReal x771=((1.0)*x752);
IkReal x772=(gconst33*x751);
IkReal x773=((1.0)*x755);
IkReal x774=(gconst33*x752);
IkReal x775=((2.0)*gconst32*gconst33);
IkReal x776=((0.24)*x754);
IkReal x777=((1.32e-6)*x752);
IkReal x778=(gconst32*x752);
IkReal x779=(x757+x753);
IkReal x780=(x751*x752);
IkReal x781=(pz*x766);
IkReal x782=(gconst32*x766);
IkReal x783=(x756*x766);
IkReal x784=(x754*x766);
IkReal x785=(x768+x769+x767);
evalcond[0]=((-0.21115)+(((-1.0)*x751*x760))+(((-1.1e-6)*x751))+((x752*x765))+(((-0.15)*x752))+(((0.06)*x770))+(((-1.0)*gconst32*px*x771))+(((-0.06)*x774))+(((-1.0)*x751*x758)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.1e-6)*x752))+(((-0.029543239556369)*py))+((px*x770))+(((-0.0828861501944662)*sj2))+(((-1.0)*x758*x771))+(((0.06)*x772))+(((0.06)*x778))+(((-1.0)*x762*x772))+(((0.15)*x751))+(((-1.0)*x760*x771)));
evalcond[2]=((0.0253474453653594)+(((-1.0)*x785))+(((-1.0)*x761))+((x758*x777))+(((-1.98e-7)*x751))+(((-7.92e-8)*x778))+(((-7.92e-8)*x772))+(((1.32e-6)*x751*x765))+(((-1.0)*gconst32*x763))+x779+(((-1.0)*x773))+(((-1.0)*(py*py)))+(((0.3)*x765))+((x760*x777))+(((1.452e-12)*x752))+(((-1.32e-6)*px*x770))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-0.3)*x760*x780))+(((-0.24)*x758*x782))+(((-0.0072)*x784))+(((-2.0)*x754*x783))+(((-1.0)*x754*x773))+(((4.0)*x758*x760*x766))+(((0.3)*x765*x766))+(((2.0)*x756*x770*x774))+(((-0.01889999999879)*x766))+(((-1.0)*x785))+(((0.12)*px*x780))+(((-2.0)*x764*x780))+(((-1.32e-7)*x752*x772))+(((-1.0)*x753*x754))+(((0.018)*x752*x770))+(((4.0)*x754*x764*x780))+(((-1.0)*x753*x766))+(((-1.0)*x757*x766))+(((-0.3)*x758*x780))+(((-1.0)*x766*x773))+(((2.2e-6)*x765*x780))+(((-1.0)*px*x759*x780))+(((0.0036)*x754))+(((-3.3e-7)*x780))+((x766*x767))+((x766*x768))+(((0.0072)*x770*x774))+x779+x783+(((-2.0)*x758*x760))+(((-0.24)*x752*x760*x772))+(((-2.0)*x755*x770*x774))+(((-1.0)*px*x776*x780))+(((0.12)*gconst32*x758))+(((-1.0)*x761*x766))+((x776*x781))+((x754*x756))+(((-1.0)*x763*x782))+(((2.0)*x755*x784)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x786=((0.0295301092415339)*sj2);
IkReal x787=(gconst32*sj1);
IkReal x788=(cj1*gconst33);
IkReal x789=((0.999563891228661)*cj2);
IkReal x790=((((-1.0)*gconst33*sj1))+(((-1.0)*cj1*gconst32)));
IkReal x791=(((x786*x788))+((x788*x789))+(((-1.0)*x787*x789))+(((-1.0)*x786*x787)));
CheckValue<IkReal> x794 = IKatan2WithCheck(IkReal(x790),IkReal(x791),IKFAST_ATAN2_MAGTHRESH);
if(!x794.valid){
continue;
}
IkReal x792=((1.0)*(x794.value));
if((((x791*x791)+(x790*x790))) < -0.00001)
continue;
CheckValue<IkReal> x795=IKPowWithIntegerCheck(IKabs(IKsqrt(((x791*x791)+(x790*x790)))),-1);
if(!x795.valid){
continue;
}
if( (((x795.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x795.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x793=IKasin(((x795.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x792))+x793);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x792))+(((-1.0)*x793)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x796=((4223.0)*pz);
IkReal x797=((0.0132)*px);
IkReal x798=((48.9318)*cj2);
IkReal x799=(pz*sj0);
IkReal x800=((2.935908)*cj2);
IkReal x801=(cj0*px);
IkReal x802=((1656.2774)*sj2);
IkReal x803=(px*sj0);
IkReal x804=(cj0*pz);
IkReal x805=((99.376644)*sj2);
CheckValue<IkReal> x806=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-6000.0)*x803))+(((6000.0)*x804))+(((-0.044)*x801))+(((-360.0)*cj0))+(((-20000.0)*(px*px)))+(((-0.044)*x799)))),-1);
if(!x806.valid){
continue;
}
CheckValue<IkReal> x807 = IKatan2WithCheck(IkReal(((0.0066253)+(((-253.38)*sj0))+(((-1.0)*x798*x804))+((sj0*x796))+((sj0*x797))+(((0.000792)*cj0))+(((-248.44161)*sj2))+((x798*x803))+((cj0*x800))+(((-0.0132)*x804))+(((-1.0)*cj0*x805))+((x802*x804))+(((7.33977)*cj2))+(((4223.0)*x801))+(((-1.0)*x802*x803)))),IkReal(((633.44999998548)+(((-1.0)*x798*x799))+(((-1.0)*cj0*x796))+(((-1.0)*cj0*x797))+(((253.38)*cj0))+(((-1.0)*x798*x801))+(((-5.382498e-5)*cj2))+(((0.00182190514)*sj2))+((x799*x802))+((sj0*x800))+((x801*x802))+(((-0.0132)*x799))+(((0.000792)*sj0))+(((-1.0)*sj0*x805))+(((4223.0)*x803)))),IKFAST_ATAN2_MAGTHRESH);
if(!x807.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x806.value)))+(x807.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x808=IKcos(j1);
IkReal x809=IKsin(j1);
IkReal x810=((0.12)*pz);
IkReal x811=cj0*cj0;
IkReal x812=pz*pz;
IkReal x813=px*px;
IkReal x814=((1.32e-7)*sj0);
IkReal x815=(cj0*px);
IkReal x816=((2.2e-6)*pz);
IkReal x817=((0.3)*pz);
IkReal x818=((0.3)*px);
IkReal x819=(pz*sj0);
IkReal x820=((0.24)*pz);
IkReal x821=((4.0)*pz);
IkReal x822=x808*x808;
IkReal x823=((2.2e-6)*x815);
IkReal x824=(sj0*x816);
IkReal x825=((1.0)*x812);
IkReal x826=((1.0)*x809);
IkReal x827=((1.32e-6)*x808);
IkReal x828=(cj0*x809);
IkReal x829=(sj0*x808);
IkReal x830=(sj0*x809);
IkReal x831=(cj0*x808);
IkReal x832=(px*x811);
IkReal x833=((1.0)*x813);
IkReal x834=(x814+x810);
IkReal x835=(x808*x809);
IkReal x836=(x811*x812);
IkReal x837=(sj0*x822);
IkReal x838=(cj0*x822);
IkReal x839=(x813*x822);
IkReal x840=(x811*x822);
IkReal x841=(x823+x825+x824);
evalcond[0]=((-0.21115)+(((0.06)*x830))+(((-0.06)*x831))+(((-1.0)*x819*x826))+(((-1.0)*px*x829))+(((-1.0)*x815*x826))+((pz*x831))+(((-0.15)*x808))+(((-1.1e-6)*x809)));
evalcond[1]=((6.6e-7)+(((0.06)*x828))+(((0.06)*x829))+(((-1.0)*cj0*pz*x826))+(((0.00244659)*cj2))+(((-1.0)*x808*x819))+(((-1.0)*x808*x815))+(((-0.08281387)*sj2))+(((0.15)*x809))+(((-1.1e-6)*x808))+((px*x830)));
evalcond[2]=((0.0253474453653594)+((cj0*x817))+((x815*x827))+(((-1.0)*sj0*x818))+((x819*x827))+(((-1.98e-7)*x809))+(((-1.0)*x841))+(((-1.0)*x833))+x834+(((1.452e-12)*x808))+(((-1.0)*(py*py)))+(((1.32e-6)*pz*x828))+(((-1.32e-6)*px*x830))+(((-0.018)*cj0))+(((-0.002)*py))+(((-7.92e-8)*x828))+(((-7.92e-8)*x829)));
evalcond[3]=((0.04098432249879)+(((-0.24)*x815*x837))+(((-0.24)*x832*x835))+((x812*x822))+(((-0.018)*x838))+((x820*x840))+(((-0.3)*x815*x835))+(((-1.32e-7)*x808*x828))+(((-1.0)*x814*x822))+(((2.0)*x811*x839))+(((-1.0)*x818*x837))+(((-2.0)*x815*x819))+(((-0.0072)*x840))+(((-2.0)*x813*x828*x829))+((x808*x816*x828))+(((-1.0)*x822*x833))+(((-1.0)*x810*x822))+(((-0.01889999999879)*x822))+(((-2.2e-6)*px*x809*x829))+(((0.0036)*x811))+(((-1.0)*x810*x811))+(((-1.0)*x811*x833))+(((-1.0)*x841))+(((0.12)*sj0*x815))+((x822*x823))+((x822*x824))+(((-2.0)*x822*x836))+(((-1.0)*x809*x817*x829))+(((4.0)*x815*x819*x822))+x834+x836+(((-2.0)*px*pz*x835))+((x817*x838))+(((-0.24)*x808*x819*x828))+(((0.0072)*x828*x829))+(((-3.3e-7)*x835))+(((0.018)*x809*x829))+((x821*x832*x835))+(((2.0)*x812*x828*x829))+(((0.12)*px*x835)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
IkReal x842=sj0*sj0;
IkReal x843=sj1*sj1;
IkReal x844=cj0*cj0;
IkReal x845=cj2*cj2;
IkReal x846=cj1*cj1;
IkReal x847=sj2*sj2;
IkReal x848=(cj2*sj2);
IkReal x849=((1145.753020896)*x845);
IkReal x850=(cj0*cj1*sj0*sj1);
IkReal x851=(x844*x846);
IkReal x852=(x842*x843);
j3eval[0]=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
j3eval[1]=((((1146.753020896)*x843*x844))+(((-2291.50604179201)*x845*x850))+(((1146.753020896)*x842*x846))+(((2293.50604179201)*x850))+(((-135.39589482084)*x848*x850))+((x847*x851))+((x847*x852))+(((67.6979474104201)*x848*x852))+(((67.6979474104201)*x848*x851))+(((-2.0)*x847*x850))+((x849*x851))+((x849*x852)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x853=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x853.valid){
continue;
}
sj3array[0]=((x853.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x854=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x854.valid){
continue;
}
sj3array[0]=((x854.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x855=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x855.valid){
continue;
}
sj3array[0]=((x855.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x856=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x856.valid){
continue;
}
sj3array[0]=((x856.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x857=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x857.valid){
continue;
}
sj3array[0]=((x857.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x858=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x858.valid){
continue;
}
sj3array[0]=((x858.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x859=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x859.valid){
continue;
}
sj3array[0]=((x859.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x860=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x860.valid){
continue;
}
sj3array[0]=((x860.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x861=(sj0*sj1);
IkReal x862=((0.999563891228661)*cj2);
IkReal x863=((0.0295301092415339)*sj2);
IkReal x864=(cj0*cj1);
IkReal x865=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
IkReal x866=(((x863*x864))+(((-1.0)*x861*x863))+(((-1.0)*x861*x862))+((x862*x864)));
CheckValue<IkReal> x869 = IKatan2WithCheck(IkReal(x865),IkReal(x866),IKFAST_ATAN2_MAGTHRESH);
if(!x869.valid){
continue;
}
IkReal x867=((1.0)*(x869.value));
if((((x865*x865)+(x866*x866))) < -0.00001)
continue;
CheckValue<IkReal> x870=IKPowWithIntegerCheck(IKabs(IKsqrt(((x865*x865)+(x866*x866)))),-1);
if(!x870.valid){
continue;
}
if( (((x870.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x870.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x868=IKasin(((x870.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x867))+x868);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x867))+(((-1.0)*x868)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x871=px*px;
IkReal x872=(px*pz);
IkReal x873=((((-0.3)*x872))+(((0.018)*px))+(((2.2e-6)*x871)));
IkReal x874=((((0.3)*x871))+(((2.2e-6)*x872))+(((-1.32e-7)*px)));
CheckValue<IkReal> x877 = IKatan2WithCheck(IkReal(x873),IkReal(x874),IKFAST_ATAN2_MAGTHRESH);
if(!x877.valid){
continue;
}
IkReal x875=((1.0)*(x877.value));
if((((x873*x873)+(x874*x874))) < -0.00001)
continue;
CheckValue<IkReal> x878=IKPowWithIntegerCheck(IKabs(IKsqrt(((x873*x873)+(x874*x874)))),-1);
if(!x878.valid){
continue;
}
if( (((x878.value)*(((((-0.12)*x872))+(((0.002)*px*py))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x872)))))) < -1-IKFAST_SINCOS_THRESH || (((x878.value)*(((((-0.12)*x872))+(((0.002)*px*py))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x872)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x876=IKasin(((x878.value)*(((((-0.12)*x872))+(((0.002)*px*py))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x872))))));
j0array[0]=((((-1.0)*x876))+(((-1.0)*x875)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x876+(((-1.0)*x875)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x879=pz*pz;
IkReal x880=py*py;
IkReal x881=px*px;
IkReal x882=((1.0)*pz);
IkReal x883=(px*pz);
evalcond[0]=((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((6.558858504e-9)*sj2))+(((0.18)*x879))+(((((-7.92e-9)+(((0.018)*px))+(((2.64e-7)*pz))+(((-0.3)*x883))+(((-2.2e-6)*x879))))*(IKsin(j0))))+(((-1.0)*x881*x882))+(((-1.93769928e-10)*cj2))+(((0.00012)*py))+(((((0.00108)+(((0.3)*x879))+(((-2.2e-6)*x883))+(((1.32e-7)*px))+(((-0.036)*pz))))*(IKcos(j0))))+(((-1.093143084e-7)*pz*sj2))+(((-1.0)*x882*(pz*pz)))+(((0.06)*x881))+(((0.06)*x880))+(((3.2294988e-9)*cj2*pz))+(((-1.0)*x880*x882)));
IkReal x884=IKcos(j0);
IkReal x885=IKsin(j0);
IkReal x886=IKcos(j0);
IkReal x887=IKsin(j0);
IkReal x888=IKcos(j0);
evalcond[1]=((2.87440030434653e-5)+(((-0.06)*(px*px)*(py*py)))+(((0.01169999999879)*pz*(py*py)))+(((-5.81309784e-10)*cj2*(pz*pz)))+(((-0.06)*(px*px*px*px)))+(((((((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.000282996786761127)*px))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((0.0111612262253709)*px*pz))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-0.150610218544758)*px*(pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))))*(IKcos(j0))*(IKsin(j0))))+(((((6.96324099683585e-6)+(((7.92e-7)*px*(pz*pz)))+(((-0.0006)*py*(pz*pz)))+(((-1.18059453072e-10)*sj2))+(((0.00193423361023218)*(pz*pz)))+(((-0.00216)*(px*px)))+(((-1.162619568e-10)*cj2*pz))+(((-3.279429252e-8)*sj2*(pz*pz)))+(((3.487858704e-12)*cj2))+(((-0.3)*(py*py)*(pz*pz)))+(((-0.00108)*(py*py)))+(((-5.84066278818272e-9)*px))+(((-2.16e-6)*py))+(((0.036)*pz*(py*py)))+(((-0.6)*(px*px)*(pz*pz)))+(((1.44294887088e-14)*px*sj2))+(((7.2e-5)*py*pz))+(((-2.2e-6)*px*pz*(py*py)))+(((0.072)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((6.56643798030453e-8)*px*pz))+(((3.9353151024e-9)*pz*sj2))+(((2.64e-10)*px*py))+(((-0.000232108033227862)*pz))+(((-2.4049147848e-13)*px*pz*sj2))+(((1.32e-7)*px*(py*py)))+(((-4.262938416e-16)*cj2*px))+(((9.6884964e-10)*cj2*(pz*pz)))+(((7.10489736e-15)*cj2*px*pz))+(((-4.4e-9)*px*py*pz))))*(IKcos(j0))))+(((-1.23962425717664e-10)*sj2))+(((-0.0064474453674406)*pz*(px*px)))+(((0.00036)*py*(pz*pz)))+(((-3.2294988e-9)*cj2*pz*(px*px)))+(((0.3)*(pz*pz*pz*pz)))+(((-1.0)*(py*py)*(pz*pz*pz)))+((pz*(px*px*px*px)))+(((x884*x884)*(((-8.48990360178838e-6)+(((-2.186286168e-7)*pz*sj2*(px*px)))+(((-0.36)*(py*py)*(pz*pz)))+(((0.00024)*py*(px*px)))+(((2.0)*(py*py)*(pz*pz*pz)))+(((0.104105109267539)*(pz*pz*pz)))+(((0.0578948907276212)*pz*(px*px)))+(((-3.87539856e-10)*cj2*(px*px)))+(((-3.9353151024e-8)*sj2*(pz*pz)))+(((-8.64e-7)*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((0.0216)*pz*(py*py)))+(((1.162619568e-9)*cj2*(pz*pz)))+(((1.3117717008e-8)*sj2*(px*px)))+(((2.186286168e-7)*sj2*(pz*pz*pz)))+(((-0.00072)*py*(pz*pz)))+(((-2.0)*pz*(px*px*px*px)))+(((4.32e-5)*py*pz))+(((-0.00347369344365727)*(px*px)))+(((-6.4589976e-9)*cj2*(pz*pz*pz)))+(((1.3951434816e-12)*cj2))+(((-0.010098919668157)*(pz*pz)))+(((0.004)*py*(pz*pz*pz)))+(((2.0)*(pz*pz*pz*pz*pz)))+(((0.12)*(px*px)*(py*py)))+(((-2.0)*pz*(px*px)*(py*py)))+(((-6.975717408e-11)*cj2*pz))+(((0.000476335180089419)*pz))+(((-0.000432)*(py*py)))+(((0.12)*(px*px*px*px)))+(((-4.72237812288e-11)*sj2))+(((-0.004)*py*pz*(px*px)))+(((-0.6)*(pz*pz*pz*pz)))+(((2.36118906144e-9)*pz*sj2))))))+(((-0.002)*py*(pz*pz*pz)))+(((-0.0011339999999274)*(py*py)))+(((x885*x885)*(((1.04544e-15)+(((-4.84e-12)*(pz*pz*pz)))+(((-0.0054)*(px*px)))+(((0.09)*pz*(px*px)))+(((8.712e-13)*(pz*pz)))+(((-5.2272e-14)*pz))))))+(((3.2294988e-9)*cj2*(pz*pz*pz)))+(((1.93769928e-10)*cj2*(px*px)))+(((-0.00012)*py*(px*px)))+(((-2.2679999998548e-6)*py))+(((-1.093143084e-7)*sj2*(pz*pz*pz)))+((pz*(px*px)*(py*py)))+(((((3.50439767290963e-10)+(((3.279429252e-8)*px*pz*sj2))+(((1.81443798030453e-8)*(pz*pz)))+(((-4.4e-6)*(pz*pz*pz*pz)))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-9.78052557636544e-9)*pz))+(((-4.4e-9)*py*(pz*pz)))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((0.0006)*px*py*pz))+(((1.056e-6)*(pz*pz*pz)))+(((-7.92e-9)*(py*py)))))*(IKsin(j0))))+(((2.339999999758e-5)*py*pz))+(((3.66225163896554e-12)*cj2))+(((x886*x886)*(((5.7024e-11)+(((4.4e-6)*(pz*pz*pz*pz)))+(((-4.752e-8)*(px*px)))+(((-0.324)*px*(pz*pz)))+(((9.504e-8)*(pz*pz)))+(((0.036)*(px*px*px)))+(((1.8)*px*(pz*pz*pz)))+(((-3.8016e-9)*pz))+(((-1.056e-6)*(pz*pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.01944)*px*pz))+(((-0.0003888)*px))+(((-1.32e-5)*(px*px)*(pz*pz)))+(((1.584e-6)*pz*(px*px)))))*(IKsin(j0))))+(((0.000386846722046436)*(px*px)))+(((1.27897740814773e-9)*pz*sj2))+(((x887*x887)*(((((-8.8e-6)*px*(pz*pz*pz)))+(((-0.00432)*(px*px)))+(((1.584e-6)*px*(pz*pz)))+(((-9.504e-8)*px*pz))+(((-1.2)*(px*px)*(pz*pz)))+(((1.9008e-9)*px))+(((0.144)*pz*(px*px)))))*(IKcos(j0))))+(((-1.0)*(pz*pz*pz*pz*pz)))+(((-0.00016048511076294)*pz))+(((0.002)*py*pz*(px*px)))+(((-3.77851359560923e-11)*cj2*pz))+(((-6.558858504e-9)*sj2*(px*px)))+(((-0.00710054016570371)*(pz*pz)))+(((0.0154474453650206)*(pz*pz*pz)))+(((1.9676575512e-8)*sj2*(pz*pz)))+(((1.093143084e-7)*pz*sj2*(px*px)))+(((x888*x888*x888)*(((-7.776e-6)+(((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((0.144)*(pz*pz*pz)))+(((-9.504e-10)*px))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.01296)*(pz*pz)))+(((0.0005184)*pz))+(((-0.6)*(pz*pz*pz*pz)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))))+(((0.18)*(py*py)*(pz*pz))));
IkReal x889=IKsin(j0);
IkReal x890=IKcos(j0);
IkReal x891=IKsin(j0);
IkReal x892=IKcos(j0);
IkReal x893=IKcos(j0);
evalcond[2]=((((((((-2.64e-10)*px*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-0.0006)*py*(px*px)))+(((-0.6)*(px*px*px*px)))+(((-0.3)*(px*px)*(py*py)))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((-6.56643798030453e-8)*px*pz))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((9.6884964e-10)*cj2*(px*px)))+(((5.84066278818272e-9)*px))+(((4.4e-6)*px*(pz*pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.00193423361023218)*(px*px)))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKsin(j0))))+(((-1.0)*(px*px*px)*(py*py)))+(((-0.24)*px*(pz*pz*pz)))+(((3.2294988e-9)*cj2*(px*px*px)))+(((x889*x889)*(((((-5.808e-13)*px*pz))+(((-0.09)*(px*px*px)))+(((4.84e-12)*px*(pz*pz)))+(((1.7424e-14)*px))))))+(((0.000479066717391088)*px))+(((0.0064474453674406)*(px*px*px)))+(((0.002)*px*py*(pz*pz)))+(((-0.01889999999879)*px*(py*py)))+(((6.10375273160923e-11)*cj2*px))+(((-0.00024)*px*py*pz))+(((0.00530969344380247)*px*pz))+((px*(pz*pz*pz*pz)))+(((x890*x890*x890)*(((((4.4e-6)*(px*px*px*px)))+(((0.00648)*px*pz))+(((-0.0001296)*px))+(((0.036)*(px*px*px)))+(((5.28e-7)*pz*(px*px)))+(((-1.584e-8)*(px*px)))+(((-4.4e-6)*(px*px)*(pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.6)*px*(pz*pz*pz)))+(((-0.108)*px*(pz*pz)))))))+(((-1.0)*(px*px*px*px*px)))+(((-1.3117717008e-8)*px*pz*sj2))+(((-3.779999999758e-5)*px*py))+(((x891*x891)*(((((-0.072)*(px*px*px)))+(((3.168e-8)*(px*px)))+(((8.8e-6)*(px*px)*(pz*pz)))+(((1.2)*pz*(px*px*px)))+(((-1.056e-6)*pz*(px*px)))))*(IKcos(j0))))+(((x892*x892)*(((((-0.0578948907276212)*(px*px*px)))+(((-7.75079712e-10)*cj2*px*pz))+(((2.0)*(px*px*px)*(py*py)))+(((-7.8706302048e-10)*px*sj2))+(((0.004)*py*(px*px*px)))+(((0.24)*px*pz*(py*py)))+(((-2.186286168e-7)*px*sj2*(pz*pz)))+(((-2.0)*px*(pz*pz*pz*pz)))+(((-1.44e-5)*px*py))+(((6.4589976e-9)*cj2*px*(pz*pz)))+(((-0.00014149839336314)*px))+(((-0.004)*px*py*(pz*pz)))+(((0.00048)*px*py*pz))+(((-0.0072)*px*(py*py)))+(((2.325239136e-11)*cj2*px))+(((2.186286168e-7)*sj2*(px*px*px)))+(((0.00558061311210466)*px*pz))+(((2.6235434016e-8)*px*pz*sj2))+(((-6.4589976e-9)*cj2*(px*px*px)))+(((2.0)*(px*px*px*px*px)))+(((-0.0753051092675388)*px*(pz*pz)))+(((0.48)*px*(pz*pz*pz)))+(((-2.0)*px*(py*py)*(pz*pz)))))))+(((-1.093143084e-7)*sj2*(px*px*px)))+(((1.093143084e-7)*px*sj2*(pz*pz)))+(((x893*x893)*(((((7.92e-7)*px*(pz*pz)))+(((9.504e-10)*px))+(((1.32e-5)*pz*(px*px*px)))+(((-7.92e-7)*(px*px*px)))+(((0.216)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-4.752e-8)*px*pz))+(((-1.8)*(px*px)*(pz*pz)))+(((0.6)*(px*px*px*px)))))*(IKsin(j0))))+(((-0.12)*px*pz*(py*py)))+(((-0.0298474453650206)*px*(pz*pz)))+(((-0.002)*py*(px*px*px)))+(((((((-0.24)*(px*px*px*px)))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((0.107410218544758)*pz*(px*px)))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((-0.00471661311268546)*(px*px)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.008)*py*pz*(px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.06604042862773e-9)*px*sj2))+((px*(py*py)*(pz*pz)))+(((((((3.279429252e-8)*px*pz*sj2))+(((-9.73443798030453e-8)*(px*px)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((2.2e-6)*(px*px)*(py*py)))+(((2.4049147848e-13)*sj2*(px*px)))+(((-0.018)*px*(py*py)))+(((4.4e-6)*(px*px)*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((-5.28e-7)*pz*(px*px)))+(((4.4e-9)*py*(px*px)))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((-1.9676575512e-9)*px*sj2))+(((-7.10489736e-15)*cj2*(px*px)))+(((0.0006)*px*py*pz))))*(IKcos(j0))))+(((-3.2294988e-9)*cj2*px*(pz*pz)))+(((3.87539856e-10)*cj2*px*pz)));
IkReal x894=IKcos(j0);
IkReal x895=IKsin(j0);
IkReal x896=IKsin(j0);
IkReal x897=IKcos(j0);
IkReal x898=IKcos(j0);
evalcond[3]=((5.01879418251366e-10)+(((0.0072)*(px*px*px)))+(((x894*x894)*(((7.776e-6)+(((-0.0005184)*pz))+(((2.8512e-9)*px))+(((-0.144)*(pz*pz*pz)))+(((-2.64e-7)*(px*px*px)))+(((4.4e-6)*pz*(px*px*px)))+(((0.216)*pz*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((0.01296)*(pz*pz)))+(((-1.32e-5)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-1.8)*(px*px)*(pz*pz)))+(((-1.4256e-7)*px*pz))+(((2.376e-6)*px*(pz*pz)))))*(IKsin(j0))))+(((-1.065734604e-15)*cj2*pz))+(((x895*x895)*(((-5.7024e-11)+(((-4.4e-6)*(pz*pz*pz*pz)))+(((1.584e-8)*(px*px)))+(((-0.00648)*px*pz))+(((3.8016e-9)*pz))+(((4.4e-6)*(px*px)*(pz*pz)))+(((-9.504e-8)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((-5.28e-7)*pz*(px*px)))+(((0.108)*px*(pz*pz)))+(((0.6)*pz*(px*px*px)))+(((0.0001296)*px))+(((-0.036)*(px*px*px)))+(((1.056e-6)*(pz*pz*pz)))))*(IKcos(j0))))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((3.3e-7)*pz*(py*py)))+(((-2.16442330632e-15)*sj2))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((3.3e-7)*(pz*pz*pz)))+(((-0.0146948907324612)*px*(pz*pz)))+(((-0.48)*px*(pz*pz*pz)))+(((-0.00018250160663686)*px))+(((-5.94e-8)*(pz*pz)))+(((-0.24)*pz*(px*px*px)))+(((-0.00048)*px*py*pz))+(((6.6e-10)*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((((8.48990360283382e-6)+(((-6.4589976e-9)*cj2*pz*(px*px)))+(((3.87539856e-10)*cj2*(px*px)))+(((-2.186286168e-7)*sj2*(pz*pz*pz)))+(((0.004)*py*pz*(px*px)))+(((-0.0216)*pz*(py*py)))+(((0.0321051092723788)*pz*(px*px)))+(((0.36)*(py*py)*(pz*pz)))+(((-0.000476335180141691)*pz))+(((-1.3951434816e-12)*cj2))+(((0.0100989196690282)*(pz*pz)))+(((-0.104105109272379)*(pz*pz*pz)))+(((-0.004)*py*(pz*pz*pz)))+(((-1.162619568e-9)*cj2*(pz*pz)))+(((-4.32e-5)*py*pz))+(((-0.12)*(px*px)*(py*py)))+(((-2.0)*(py*py)*(pz*pz*pz)))+(((-2.36118906144e-9)*pz*sj2))+(((2.0)*pz*(px*px)*(py*py)))+(((-0.00024)*py*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((-2.0)*(pz*pz*pz*pz*pz)))+(((3.9353151024e-8)*sj2*(pz*pz)))+(((4.72237812288e-11)*sj2))+(((6.975717408e-11)*cj2*pz))+(((2.186286168e-7)*pz*sj2*(px*px)))+(((2.0)*pz*(px*px*px*px)))+(((6.4589976e-9)*cj2*(pz*pz*pz)))+(((-0.12)*(px*px*px*px)))+(((0.000432)*(py*py)))+(((8.64e-7)*py))+(((0.00072)*py*(pz*pz)))+(((-1.3117717008e-8)*sj2*(px*px)))+(((-0.00192630655634273)*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.325239136e-11)*cj2*px))+(((3.3e-7)*pz*(px*px)))+(((-1.98e-8)*(py*py)))+(((-0.24)*px*pz*(py*py)))+(((-5.9886569708561e-9)*pz))+(((2.0)*(px*px*px)*(pz*pz)))+(((x896*x896)*(((-1.4256e-10)+(((-0.0108000000005808)*px*pz))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((-1.188e-7)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((0.000324000000017424)*px))+(((0.09000000000484)*px*(pz*pz)))))))+(((-1.98e-8)*(px*px)))+(((3.6073721772e-14)*pz*sj2))+(((x897*x897*x897)*(((((-0.0002592)*px))+(((0.01296)*px*pz))+(((1.2)*px*(pz*pz*pz)))+(((-0.216)*px*(pz*pz)))+(((-3.168e-8)*(px*px)))+(((1.056e-6)*pz*(px*px)))+(((-8.8e-6)*(px*px)*(pz*pz)))))))+(((((-2.73752409929154e-5)+(((-9.6884964e-10)*cj2*(pz*pz)))+(((-3.54453721165756e-9)*px))+(((-7.2e-5)*py*pz))+(((1.06595620194293e-7)*px*pz))+(((-3.487858704e-12)*cj2))+(((0.3)*(pz*pz*pz*pz)))+(((0.0006)*py*(pz*pz)))+(((0.00108)*(py*py)))+(((-2.64e-10)*px*py))+(((6.6e-6)*px*(pz*pz*pz)))+(((2.16e-6)*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-1.32e-7)*(px*px*px)))+(((2.2e-6)*pz*(px*px*px)))+(((-0.072)*(pz*pz*pz)))+(((0.000782908033097182)*pz))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((1.162619568e-10)*cj2*pz))+(((2.2e-6)*px*pz*(py*py)))+(((0.9)*(px*px)*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-0.036)*pz*(py*py)))+(((-1.32e-7)*px*(py*py)))+(((-1.188e-6)*px*(pz*pz)))+(((0.00324)*(px*px)))+(((-0.108)*pz*(px*px)))+(((1.18059453072e-10)*sj2))+(((-0.00220423360914318)*(pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.3)*(py*py)*(pz*pz)))+(((-3.9353151024e-9)*pz*sj2))+(((3.279429252e-8)*sj2*(pz*pz)))))*(IKsin(j0))))+(((6.394407624e-17)*cj2))+(((0.00521938688789534)*px*pz))+(((2.0)*px*(pz*pz*pz*pz)))+(((((-1.55648232699454e-10)+(((3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.000585854016548591)*px))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((-0.018)*(px*px*px)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((-2.2e-6)*(pz*pz*pz*pz)))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-4.4e-9)*py*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-0.0119242336091432)*px*pz))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((6.13867442331512e-9)*pz))+(((-3.6e-5)*px*py))+(((0.3)*pz*(px*px*px)))+(((2.2e-6)*(px*px)*(pz*pz)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((7.92e-9)*(px*px)))+(((-2.64e-7)*pz*(px*px)))+(((5.28e-7)*(pz*pz*pz)))+(((-8.28356201942927e-8)*(pz*pz)))+(((0.0006)*px*py*pz))+(((-7.92e-9)*(py*py)))))*(IKcos(j0))))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-3.96e-11)*py))+(((x898*x898)*(((-1.4256e-10)+(((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.0606102185399176)*px*(pz*pz)))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((4.10032132562966e-5)*px))+(((-1.188e-7)*(pz*pz)))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))+(((0.000361226224790112)*px*pz)))))));
IkReal x899=IKcos(j0);
IkReal x900=IKsin(j0);
IkReal x901=IKcos(j0);
IkReal x902=IKcos(j0);
IkReal x903=IKsin(j0);
evalcond[4]=((((-2.186286168e-7)*pz*sj2*(px*px)))+(((x899*x899)*(((((-0.24)*(px*px*px*px)))+(((-2.376e-9)*px))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((7.92e-8)*px*pz))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((0.000683386887604944)*(px*px)))+(((-6.6e-7)*px*(pz*pz)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.0174102185399176)*pz*(px*px)))+(((0.008)*py*pz*(px*px)))+(((-6.6e-7)*(px*px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))))+(((x900*x900)*(((((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((-9.504e-10)*px))+(((-0.6)*(px*px*px*px)))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))*(IKcos(j0))))+(((((((5.90756201942927e-8)*px*pz))+(((0.00976423360914318)*(px*px)))+(((-2.64e-10)*px*py))+(((-3.96e-7)*px*(pz*pz)))+(((2.4049147848e-13)*px*pz*sj2))+(((0.3)*(px*px)*(pz*pz)))+(((-0.0006)*py*(px*px)))+(((-0.3)*(px*px)*(py*py)))+(((-0.036)*pz*(px*px)))+(((4.262938416e-16)*cj2*px))+(((-0.3)*(px*px*px*px)))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((2.2e-6)*px*(pz*pz*pz)))+(((-2.2e-6)*pz*(px*px*px)))+(((9.6884964e-10)*cj2*(px*px)))+(((-2.59413721165756e-9)*px))+(((1.32e-7)*(px*px*px)))+(((-1.44294887088e-14)*px*sj2))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKcos(j0))))+(((0.00024)*py*(px*px)))+(((x901*x901)*(((((-0.00648)*px*pz))+(((1.8)*pz*(px*px*px)))+(((1.32e-5)*(px*px)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((0.108)*px*(pz*pz)))+(((-4.4e-6)*(px*px*px*px)))+(((-1.584e-6)*pz*(px*px)))+(((0.0001296)*px))+(((-0.108)*(px*px*px)))+(((4.752e-8)*(px*px)))))*(IKsin(j0))))+(((-3.3e-7)*px*(pz*pz)))+(((-3.3e-7)*px*(py*py)))+(((-3.6073721772e-14)*px*sj2))+(((-3.87539856e-10)*cj2*(px*px)))+(((-6.6e-10)*px*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((1.3117717008e-8)*sj2*(px*px)))+(((0.0362948907324612)*pz*(px*px)))+(((-2.0)*pz*(px*px*px*px)))+(((3.96e-8)*px*pz))+(((x902*x902*x902)*(((((-0.00432)*(px*px)))+(((-1.2)*(px*px)*(pz*pz)))+(((-5.28e-7)*(px*px*px)))+(((8.8e-6)*pz*(px*px*px)))+(((0.144)*pz*(px*px)))))))+(((-2.0)*(px*px)*(pz*pz*pz)))+(((0.36)*(px*px)*(pz*pz)))+(((((((-0.00558061311268546)*px*pz))+(((-2.186286168e-7)*sj2*(px*px*px)))+(((-2.0)*(px*px*px)*(py*py)))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((0.0753051092723788)*px*(pz*pz)))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((-0.48)*px*(pz*pz*pz)))+(((0.000141498393380564)*px))+(((-0.004)*py*(px*px*px)))+(((-0.00048)*px*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((-2.325239136e-11)*cj2*px))+(((-0.24)*px*pz*(py*py)))+(((6.4589976e-9)*cj2*(px*px*px)))+(((-0.0321051092723788)*(px*px*px)))+(((2.0)*px*(pz*pz*pz*pz)))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-2.0)*(px*px*px*px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((0.12)*(px*px)*(py*py)))+(((8.3646569708561e-9)*px))+(((-2.0)*pz*(px*px)*(py*py)))+(((-0.00304169344394767)*(px*px)))+(((x903*x903)*(((((-2.376e-9)*px))+(((7.92e-8)*px*pz))+(((-6.6e-7)*px*(pz*pz)))+(((-6.6e-7)*(px*px*px)))+(((0.0054000000002904)*(px*px)))+(((-0.09000000000484)*pz*(px*px)))))))+(((1.065734604e-15)*cj2*px))+(((0.12)*(px*px*px*px)))+(((((((-2.2e-6)*(px*px*px*px)))+(((-3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.00544423360914318)*px*pz))+(((-0.9)*pz*(px*px*px)))+(((-6.6e-6)*(px*px)*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-5.90756201942927e-8)*(px*px)))+(((-2.2e-6)*(px*px)*(py*py)))+(((1.9676575512e-9)*px*sj2))+(((7.92e-7)*pz*(px*px)))+(((9.6884964e-10)*cj2*px*pz))+(((3.6e-5)*px*py))+(((-0.3)*px*pz*(py*py)))+(((-5.81309784e-11)*cj2*px))+(((-0.0006)*px*py*pz))+(((7.10489736e-15)*cj2*(px*px)))+(((0.054)*(px*px*px)))+(((-4.4e-9)*py*(px*px)))+(((0.018)*px*(py*py)))+(((-2.4049147848e-13)*sj2*(px*px)))+(((-0.000456254016548591)*px))))*(IKsin(j0))))+(((-0.004)*py*pz*(px*px)))+(((-3.3e-7)*(px*px*px))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x904=px*px;
IkReal x905=pz*pz;
IkReal x906=(cj0*px);
IkReal x907=(px*sj0);
IkReal x908=(pz*sj0);
IkReal x909=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+(((-7575757.57575758)*x904))+(((-7575757.57575758)*x905))+sj0+(((-16.6666666666667)*x906))+(((-16.6666666666667)*x908))+(((-2272727.27272727)*x907))+(((909090.909090909)*pz))+(((2272727.27272727)*x909)));
j1eval[1]=IKsign(((-522.0000000242)+(((2400.0)*pz))+(((0.00264)*sj0))+(((-0.044)*x906))+(((-0.044)*x908))+(((-20000.0)*x904))+(((-20000.0)*x905))+(((-360.0)*cj0))+(((-6000.0)*x907))+(((6000.0)*x909))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x910=pz*pz;
IkReal x911=px*px;
IkReal x912=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x913=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x914=((-197727.272736439)+(((-7575757.57575758)*x911))+(((-7575757.57575758)*x910))+(((909090.909090909)*pz)));
IkReal x915=((x912*x912)+(x913*x913));
if((((18595041323.314)+(((5165289256476.13)*x911))+(((5165289256476.13)*x910))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x916=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x911))+(((5165289256476.13)*x910))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x922=IKPowWithIntegerCheck(x916,-1);
if(!x922.valid){
continue;
}
IkReal x917=x922.value;
IkReal x923 = x915;
if(IKabs(x923)==0){
continue;
}
IkReal x918=pow(x923,-0.5);
IkReal x919=((1.0)*x918);
IkReal x920=(x914*x917);
if((((1.0)+(((-1.0)*(x920*x920))))) < -0.00001)
continue;
IkReal x921=IKsqrt(((1.0)+(((-1.0)*(x920*x920)))));
if((x915) < -0.00001)
continue;
CheckValue<IkReal> x924=IKPowWithIntegerCheck(IKabs(IKsqrt(x915)),-1);
if(!x924.valid){
continue;
}
if( ((x914*(x924.value))) < -1-IKFAST_SINCOS_THRESH || ((x914*(x924.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x925 = IKatan2WithCheck(IkReal(x912),IkReal(x913),IKFAST_ATAN2_MAGTHRESH);
if(!x925.valid){
continue;
}
IkReal gconst28=((((-1.0)*(IKasin((x914*(x924.value))))))+(((-1.0)*(x925.value))));
IkReal gconst29=((((-1.0)*x912*x919*x921))+(((-1.0)*x913*x919*x920)));
IkReal gconst30=(((x913*x918*x921))+(((-1.0)*x912*x919*x920)));
IkReal x926=pz*pz;
IkReal x927=px*px;
if((((18595041323.314)+(((5165289256476.13)*x926))+(((5165289256476.13)*x927))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x930=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x926))+(((5165289256476.13)*x927))+(((-619834710777.135)*pz))))),-1);
if(!x930.valid){
continue;
}
IkReal x928=x930.value;
IkReal x929=((7575757.57575758)*x928);
if( ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) < -1-IKFAST_SINCOS_THRESH || ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) < -1-IKFAST_SINCOS_THRESH || ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) < -1-IKFAST_SINCOS_THRESH || ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) < -1-IKFAST_SINCOS_THRESH || ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x931 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x931.valid){
continue;
}
if( ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) < -1-IKFAST_SINCOS_THRESH || ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x932 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x932.valid){
continue;
}
CheckValue<IkReal> x933 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x933.valid){
continue;
}
CheckValue<IkReal> x934 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x934.valid){
continue;
}
CheckValue<IkReal> x935 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x935.valid){
continue;
}
if( ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) < -1-IKFAST_SINCOS_THRESH || ((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x936 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x936.valid){
continue;
}
if(((((j0*(j0)))+(((-1.0)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))*(j0)))+(((-1.0)*j0*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))))+(((1.0)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))))+(((-1.0)*(x931.value)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))))+(((x932.value)*(x933.value)))+((j0*(x934.value)))+(((x935.value)*(j0)))+(((-1.0)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))*(x936.value))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j0*(j0)))+(((-1.0)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))*(j0)))+(((-1.0)*j0*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))))+(((1.0)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))))+(((-1.0)*(x931.value)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))))+(((x932.value)*(x933.value)))+((j0*(x934.value)))+(((x935.value)*(j0)))+(((-1.0)*(IKasin((((x927*x929))+(((197727.272736439)*x928))+((x926*x929))+(((-909090.909090909)*pz*x928)))))*(x936.value))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x937=gconst30*gconst30;
IkReal x938=gconst29*gconst29;
IkReal x939=px*px;
IkReal x940=pz*pz;
IkReal x941=((2400.0)*pz);
IkReal x942=(gconst29*px);
IkReal x943=((1657.72300388932)*sj2);
IkReal x944=(gconst30*px);
IkReal x945=((590.86479112738)*py);
IkReal x946=((99.4633802333595)*sj2);
IkReal x947=(gconst30*pz);
IkReal x948=((35.4518874676428)*py);
IkReal x949=(gconst29*pz);
IkReal x950=((20000.0)*x939);
IkReal x951=((20000.0)*x940);
CheckValue<IkReal> x952=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((-6000.0)*x942))+(((-72.0)*x937))+(((-72.0)*x938))+(((-1.0)*x938*x950))+(((-1.0)*x938*x951))+((x938*x941))+(((0.00264)*gconst29))+((x937*x941))+(((-360.0)*gconst30))+(((6000.0)*x947))+(((-1.0)*x937*x950))+(((-1.0)*x937*x951))+(((-0.044)*x949))+(((-0.044)*x944)))),-1);
if(!x952.valid){
continue;
}
CheckValue<IkReal> x953 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((0.57766479112738)*x947))+((x945*x947))+(((4223.0)*x949))+(((4223.0)*x944))+(((-253.38)*gconst29))+(((-1.0)*x942*x943))+(((-1.0)*x942*x945))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst30))+((x943*x947))+(((-0.57766479112738)*x942))+(((-1.0)*gconst30*x946))+(((-1.0)*gconst30*x948)))),IkReal(((633.450000635431)+(((0.57766479112738)*x944))+(((0.57766479112738)*x949))+(((-1.0)*gconst29*x946))+(((-1.0)*gconst29*x948))+(((253.38)*gconst30))+((x945*x949))+(((4223.0)*x942))+(((-0.0346598874676428)*gconst29))+((x943*x949))+((x943*x944))+(((0.00182349530427826)*sj2))+((x944*x945))+(((-4223.0)*x947))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x953.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x952.value)))+(x953.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x954=IKcos(j1);
IkReal x955=IKsin(j1);
IkReal x956=((0.12)*pz);
IkReal x957=pz*pz;
IkReal x958=gconst30*gconst30;
IkReal x959=px*px;
IkReal x960=((1.32e-7)*gconst29);
IkReal x961=(gconst29*gconst30);
IkReal x962=(px*pz);
IkReal x963=(gconst29*pz);
IkReal x964=(gconst30*px);
IkReal x965=(gconst29*px);
IkReal x966=((0.24)*pz);
IkReal x967=((0.018)*gconst30);
IkReal x968=(gconst30*pz);
IkReal x969=((0.24)*px);
IkReal x970=((0.12)*px);
IkReal x971=((0.06)*gconst29);
IkReal x972=x954*x954;
IkReal x973=((2.2e-6)*x963);
IkReal x974=((2.2e-6)*x964);
IkReal x975=((1.0)*x957);
IkReal x976=((1.0)*x954);
IkReal x977=((1.0)*x959);
IkReal x978=((1.32e-6)*x954);
IkReal x979=((1.0)*x955);
IkReal x980=(gconst30*x955);
IkReal x981=(x960+x956);
IkReal x982=(x954*x955);
IkReal x983=(x955*x968);
IkReal x984=((2.2e-6)*x972);
IkReal x985=((0.3)*x972);
IkReal x986=((2.0)*x982);
IkReal x987=(x957*x972);
IkReal x988=(x958*x972);
IkReal x989=(x973+x975+x974);
evalcond[0]=((-0.21115)+(((-1.0)*x963*x979))+(((-1.0)*x965*x976))+((x954*x968))+(((-0.15)*x954))+(((-0.06)*gconst30*x954))+(((-1.0)*x964*x979))+(((-1.1e-6)*x955))+((x955*x971)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x963*x976))+(((0.06)*x980))+(((-1.0)*x964*x976))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((0.15)*x955))+((x954*x971))+(((-1.1e-6)*x954))+(((-1.0)*x968*x979))+((x955*x965)));
evalcond[2]=((0.0253474453653594)+(((-1.0)*x989))+(((0.3)*x968))+((x963*x978))+((x964*x978))+(((-7.92e-8)*gconst29*x954))+(((1.452e-12)*x954))+(((-1.32e-6)*x955*x965))+(((-7.92e-8)*x980))+(((-1.98e-7)*x955))+(((-1.0)*(py*py)))+x981+(((-1.0)*x967))+(((-0.3)*x965))+(((-1.0)*x977))+(((1.32e-6)*x983))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-1.0)*x989))+((x957*x961*x986))+(((-2.2e-6)*x965*x982))+(((-2.0)*x958*x987))+(((-1.0)*x965*x985))+(((0.0072)*x961*x982))+(((-0.3)*x964*x982))+(((-1.0)*x959*x961*x986))+((x961*x970))+(((2.2e-6)*x968*x982))+(((-0.01889999999879)*x972))+(((-1.0)*x962*x986))+(((2.0)*x959*x988))+((x968*x985))+(((-1.32e-7)*x954*x980))+(((-1.0)*x958*x977))+(((-1.0)*x956*x958))+(((-1.0)*x967*x972))+(((-1.0)*x961*x966*x982))+((x966*x988))+(((4.0)*x958*x962*x982))+(((-1.0)*x956*x972))+(((4.0)*x961*x962*x972))+((x957*x958))+(((-1.0)*x961*x969*x972))+(((-0.0072)*x988))+(((0.018)*gconst29*x982))+(((-1.0)*x972*x977))+(((0.0036)*x958))+x987+x981+((x970*x982))+(((-1.0)*x958*x969*x982))+(((-0.3)*x963*x982))+((x972*x973))+((x972*x974))+(((-1.0)*x960*x972))+(((-3.3e-7)*x982))+(((-2.0)*x961*x962)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x990=(cj1*gconst30);
IkReal x991=((0.0295301092415339)*sj2);
IkReal x992=((0.999563891228661)*cj2);
IkReal x993=(gconst29*sj1);
IkReal x994=((((-1.0)*cj1*gconst29))+(((-1.0)*gconst30*sj1)));
IkReal x995=((((-1.0)*x991*x993))+(((-1.0)*x992*x993))+((x990*x992))+((x990*x991)));
CheckValue<IkReal> x998 = IKatan2WithCheck(IkReal(x994),IkReal(x995),IKFAST_ATAN2_MAGTHRESH);
if(!x998.valid){
continue;
}
IkReal x996=((1.0)*(x998.value));
if((((x994*x994)+(x995*x995))) < -0.00001)
continue;
CheckValue<IkReal> x999=IKPowWithIntegerCheck(IKabs(IKsqrt(((x994*x994)+(x995*x995)))),-1);
if(!x999.valid){
continue;
}
if( (((x999.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x999.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x997=IKasin(((x999.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x996))+x997);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x997))+(((-1.0)*x996)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1000=pz*pz;
IkReal x1001=px*px;
IkReal x1002=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x1003=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x1004=((-197727.272736439)+(((-7575757.57575758)*x1001))+(((-7575757.57575758)*x1000))+(((909090.909090909)*pz)));
IkReal x1005=x1004*x1004;
IkReal x1006=((x1003*x1003)+(x1002*x1002));
if((((18595041323.314)+(((5165289256476.13)*x1000))+(((5165289256476.13)*x1001))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x1007=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x1000))+(((5165289256476.13)*x1001))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x1014=IKPowWithIntegerCheck(x1007,-1);
if(!x1014.valid){
continue;
}
IkReal x1008=x1014.value;
IkReal x1015 = x1006;
if(IKabs(x1015)==0){
continue;
}
IkReal x1009=pow(x1015,-0.5);
CheckValue<IkReal> x1016=IKPowWithIntegerCheck(x1007,-2);
if(!x1016.valid){
continue;
}
IkReal x1010=x1016.value;
IkReal x1011=((1.0)*x1009);
IkReal x1012=(x1004*x1008);
IkReal x1013=(x1005*x1010);
if((x1006) < -0.00001)
continue;
CheckValue<IkReal> x1017=IKPowWithIntegerCheck(IKabs(IKsqrt(x1006)),-1);
if(!x1017.valid){
continue;
}
if( ((x1004*(x1017.value))) < -1-IKFAST_SINCOS_THRESH || ((x1004*(x1017.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1018 = IKatan2WithCheck(IkReal(x1002),IkReal(x1003),IKFAST_ATAN2_MAGTHRESH);
if(!x1018.valid){
continue;
}
IkReal gconst31=((3.14159265358979)+(IKasin((x1004*(x1017.value))))+(((-1.0)*(x1018.value))));
if((((1.0)+(((-1.0)*x1013)))) < -0.00001)
continue;
IkReal gconst32=(((x1002*x1011*(IKsqrt(((1.0)+(((-1.0)*x1013)))))))+(((-1.0)*x1003*x1011*x1012)));
if((((1.0)+(((-1.0)*x1013)))) < -0.00001)
continue;
IkReal gconst33=((((-1.0)*x1003*x1011*(IKsqrt(((1.0)+(((-1.0)*x1013)))))))+(((-1.0)*x1002*x1011*x1012)));
IkReal x1019=x1002;
IkReal x1020=x1003;
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1021=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1021.valid){
continue;
}
if( (((x1021.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1021.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1022=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1022.valid){
continue;
}
if( (((x1022.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1022.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1023 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1023.valid){
continue;
}
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1024=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1024.valid){
continue;
}
if( (((x1024.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1024.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1025=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1025.valid){
continue;
}
if( (((x1025.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1025.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1026 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1026.valid){
continue;
}
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1027=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1027.valid){
continue;
}
if( (((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1028=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1028.valid){
continue;
}
if( (((x1028.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1028.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1029=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1029.valid){
continue;
}
if( (((x1029.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1029.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1020*x1020)+(x1019*x1019))) < -0.00001)
continue;
CheckValue<IkReal> x1030=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1020*x1020)+(x1019*x1019)))),-1);
if(!x1030.valid){
continue;
}
if( (((x1030.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1030.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1031 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1031.valid){
continue;
}
CheckValue<IkReal> x1032 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1032.valid){
continue;
}
CheckValue<IkReal> x1033 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1033.valid){
continue;
}
CheckValue<IkReal> x1034 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1034.valid){
continue;
}
CheckValue<IkReal> x1035 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1035.valid){
continue;
}
CheckValue<IkReal> x1036 = IKatan2WithCheck(IkReal(x1019),IkReal(x1020),IKFAST_ATAN2_MAGTHRESH);
if(!x1036.valid){
continue;
}
if((((9.86960440108936)+((j0*(j0)))+(((3.14159265358979)*(IKasin(((x1021.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x1022.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(x1023.value)*(IKasin(((x1024.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x1025.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x1026.value)))+(((-3.14159265358979)*(j0)))+(((-1.0)*(IKasin(((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+(((-3.14159265358979)*j0))+(((1.0)*(IKasin(((x1028.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x1029.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x1030.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((x1031.value)*(j0)))+(((-3.14159265358979)*(x1032.value)))+(((x1033.value)*(x1034.value)))+((j0*(x1035.value)))+(((-3.14159265358979)*(x1036.value))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((j0*(j0)))+(((3.14159265358979)*(IKasin(((x1021.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x1022.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(x1023.value)*(IKasin(((x1024.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x1025.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x1026.value)))+(((-3.14159265358979)*(j0)))+(((-1.0)*(IKasin(((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+(((-3.14159265358979)*j0))+(((1.0)*(IKasin(((x1028.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x1029.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x1030.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((x1031.value)*(j0)))+(((-3.14159265358979)*(x1032.value)))+(((x1033.value)*(x1034.value)))+((j0*(x1035.value)))+(((-3.14159265358979)*(x1036.value))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1037=gconst33*gconst33;
IkReal x1038=gconst32*gconst32;
IkReal x1039=pz*pz;
IkReal x1040=px*px;
IkReal x1041=(gconst32*pz);
IkReal x1042=((590.86479112738)*py);
IkReal x1043=(gconst33*pz);
IkReal x1044=((2400.0)*pz);
IkReal x1045=(gconst32*px);
IkReal x1046=((35.4518874676428)*py);
IkReal x1047=((99.4633802333595)*sj2);
IkReal x1048=(gconst33*px);
IkReal x1049=((1657.72300388932)*sj2);
IkReal x1050=((20000.0)*x1040);
IkReal x1051=((20000.0)*x1039);
CheckValue<IkReal> x1052=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x1038*x1044))+((x1037*x1044))+(((-1.0)*x1038*x1051))+(((-1.0)*x1038*x1050))+(((0.00264)*gconst32))+(((-72.0)*x1037))+(((-72.0)*x1038))+(((-360.0)*gconst33))+(((-1.0)*x1037*x1051))+(((-1.0)*x1037*x1050))+(((-6000.0)*x1045))+(((6000.0)*x1043))+(((-0.044)*x1041))+(((-0.044)*x1048)))),-1);
if(!x1052.valid){
continue;
}
CheckValue<IkReal> x1053 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+((x1042*x1043))+(((-1.0)*gconst33*x1046))+(((-1.0)*gconst33*x1047))+((x1043*x1049))+(((-253.38)*gconst32))+(((-1.0)*x1045*x1049))+(((-0.57766479112738)*x1045))+(((4223.0)*x1041))+(((4223.0)*x1048))+(((0.57766479112738)*x1043))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst33))+(((-1.0)*x1042*x1045)))),IkReal(((633.450000635431)+((x1042*x1048))+(((-1.0)*gconst32*x1046))+(((-1.0)*gconst32*x1047))+(((253.38)*gconst33))+(((4223.0)*x1045))+(((0.57766479112738)*x1048))+(((0.57766479112738)*x1041))+((x1041*x1049))+((x1041*x1042))+(((-0.0346598874676428)*gconst32))+((x1048*x1049))+(((0.00182349530427826)*sj2))+(((-4223.0)*x1043))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1053.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1052.value)))+(x1053.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1054=IKsin(j1);
IkReal x1055=IKcos(j1);
IkReal x1056=((0.12)*pz);
IkReal x1057=gconst33*gconst33;
IkReal x1058=px*px;
IkReal x1059=pz*pz;
IkReal x1060=((1.32e-7)*gconst32);
IkReal x1061=(gconst33*px);
IkReal x1062=((2.2e-6)*gconst32);
IkReal x1063=(gconst32*pz);
IkReal x1064=((0.018)*gconst33);
IkReal x1065=((1.0)*pz);
IkReal x1066=((0.3)*px);
IkReal x1067=(px*pz);
IkReal x1068=(gconst33*pz);
IkReal x1069=x1055*x1055;
IkReal x1070=((2.2e-6)*x1061);
IkReal x1071=(pz*x1062);
IkReal x1072=((1.0)*x1059);
IkReal x1073=(gconst32*x1054);
IkReal x1074=((1.0)*x1055);
IkReal x1075=(gconst33*x1054);
IkReal x1076=((1.0)*x1058);
IkReal x1077=(gconst33*x1055);
IkReal x1078=((2.0)*gconst32*gconst33);
IkReal x1079=((0.24)*x1057);
IkReal x1080=((1.32e-6)*x1055);
IkReal x1081=(gconst32*x1055);
IkReal x1082=(x1056+x1060);
IkReal x1083=(x1054*x1055);
IkReal x1084=(pz*x1069);
IkReal x1085=(gconst32*x1069);
IkReal x1086=(x1059*x1069);
IkReal x1087=(x1057*x1069);
IkReal x1088=(x1072+x1070+x1071);
evalcond[0]=((-0.21115)+((x1055*x1068))+(((-0.06)*x1077))+(((0.06)*x1073))+(((-1.1e-6)*x1054))+(((-1.0)*gconst32*px*x1074))+(((-0.15)*x1055))+(((-1.0)*x1054*x1063))+(((-1.0)*x1054*x1061)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x1063*x1074))+(((0.06)*x1081))+((px*x1073))+(((0.06)*x1075))+(((-0.029543239556369)*py))+(((-1.0)*x1061*x1074))+(((-1.1e-6)*x1055))+(((-0.0828861501944662)*sj2))+(((0.15)*x1054))+(((-1.0)*x1065*x1075)));
evalcond[2]=((0.0253474453653594)+(((-7.92e-8)*x1075))+(((0.3)*x1068))+x1082+(((-1.98e-7)*x1054))+((x1061*x1080))+(((1.32e-6)*x1054*x1068))+((x1063*x1080))+(((-7.92e-8)*x1081))+(((-1.32e-6)*px*x1073))+(((-1.0)*x1064))+(((-1.0)*(py*py)))+(((-1.0)*x1088))+(((-1.0)*x1076))+(((1.452e-12)*x1055))+(((-1.0)*gconst32*x1066))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+((x1079*x1084))+((x1069*x1071))+((x1069*x1070))+(((-1.0)*x1060*x1069))+(((-3.3e-7)*x1083))+(((0.12)*gconst32*x1061))+(((-0.01889999999879)*x1069))+x1086+x1082+(((-2.0)*x1057*x1086))+(((-2.0)*x1058*x1073*x1077))+(((4.0)*x1061*x1063*x1069))+(((0.0036)*x1057))+(((-0.24)*x1055*x1063*x1075))+((x1057*x1059))+(((0.0072)*x1073*x1077))+(((-1.0)*x1066*x1085))+(((2.0)*x1058*x1087))+(((-1.0)*px*x1062*x1083))+(((-0.3)*x1063*x1083))+(((4.0)*x1057*x1067*x1083))+(((-1.0)*x1056*x1069))+(((-1.0)*x1057*x1076))+(((2.2e-6)*x1068*x1083))+(((-1.0)*x1056*x1057))+(((-0.0072)*x1087))+(((-2.0)*x1067*x1083))+(((0.12)*px*x1083))+(((0.018)*x1055*x1073))+(((2.0)*x1059*x1073*x1077))+(((-1.0)*x1064*x1069))+(((-1.0)*px*x1079*x1083))+(((0.3)*x1068*x1069))+(((-1.0)*x1088))+(((-1.0)*x1069*x1076))+(((-0.3)*x1061*x1083))+(((-1.32e-7)*x1055*x1075))+(((-0.24)*x1061*x1085))+(((-2.0)*x1061*x1063)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x1089=((0.0295301092415339)*sj2);
IkReal x1090=(gconst32*sj1);
IkReal x1091=(cj1*gconst33);
IkReal x1092=((0.999563891228661)*cj2);
IkReal x1093=((((-1.0)*gconst33*sj1))+(((-1.0)*cj1*gconst32)));
IkReal x1094=(((x1089*x1091))+(((-1.0)*x1090*x1092))+(((-1.0)*x1089*x1090))+((x1091*x1092)));
CheckValue<IkReal> x1097 = IKatan2WithCheck(IkReal(x1093),IkReal(x1094),IKFAST_ATAN2_MAGTHRESH);
if(!x1097.valid){
continue;
}
IkReal x1095=((1.0)*(x1097.value));
if((((x1093*x1093)+(x1094*x1094))) < -0.00001)
continue;
CheckValue<IkReal> x1098=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1093*x1093)+(x1094*x1094)))),-1);
if(!x1098.valid){
continue;
}
if( (((x1098.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x1098.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1096=IKasin(((x1098.value)*(IKcos(r00))));
j3array[0]=(x1096+(((-1.0)*x1095)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x1095))+(((-1.0)*x1096)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1099=((4223.0)*pz);
IkReal x1100=((0.0132)*px);
IkReal x1101=((48.9318)*cj2);
IkReal x1102=(pz*sj0);
IkReal x1103=((2.935908)*cj2);
IkReal x1104=(cj0*px);
IkReal x1105=((1656.2774)*sj2);
IkReal x1106=(px*sj0);
IkReal x1107=(cj0*pz);
IkReal x1108=((99.376644)*sj2);
CheckValue<IkReal> x1109=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-360.0)*cj0))+(((-20000.0)*(px*px)))+(((-0.044)*x1102))+(((-0.044)*x1104))+(((6000.0)*x1107))+(((-6000.0)*x1106)))),-1);
if(!x1109.valid){
continue;
}
CheckValue<IkReal> x1110 = IKatan2WithCheck(IkReal(((0.0066253)+(((-253.38)*sj0))+(((-0.0132)*x1107))+((sj0*x1099))+((x1105*x1107))+(((4223.0)*x1104))+((x1101*x1106))+(((0.000792)*cj0))+(((-248.44161)*sj2))+((sj0*x1100))+(((7.33977)*cj2))+((cj0*x1103))+(((-1.0)*cj0*x1108))+(((-1.0)*x1101*x1107))+(((-1.0)*x1105*x1106)))),IkReal(((633.44999998548)+((x1102*x1105))+(((-0.0132)*x1102))+(((4223.0)*x1106))+(((253.38)*cj0))+(((-5.382498e-5)*cj2))+(((0.00182190514)*sj2))+((x1104*x1105))+((sj0*x1103))+(((0.000792)*sj0))+(((-1.0)*cj0*x1099))+(((-1.0)*cj0*x1100))+(((-1.0)*sj0*x1108))+(((-1.0)*x1101*x1104))+(((-1.0)*x1101*x1102)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1110.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1109.value)))+(x1110.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1111=IKcos(j1);
IkReal x1112=IKsin(j1);
IkReal x1113=((0.12)*pz);
IkReal x1114=cj0*cj0;
IkReal x1115=pz*pz;
IkReal x1116=px*px;
IkReal x1117=((1.32e-7)*sj0);
IkReal x1118=(cj0*px);
IkReal x1119=((2.2e-6)*pz);
IkReal x1120=((0.3)*pz);
IkReal x1121=((0.3)*px);
IkReal x1122=(pz*sj0);
IkReal x1123=((0.24)*pz);
IkReal x1124=((4.0)*pz);
IkReal x1125=x1111*x1111;
IkReal x1126=((2.2e-6)*x1118);
IkReal x1127=(sj0*x1119);
IkReal x1128=((1.0)*x1115);
IkReal x1129=((1.0)*x1112);
IkReal x1130=((1.32e-6)*x1111);
IkReal x1131=(cj0*x1112);
IkReal x1132=(sj0*x1111);
IkReal x1133=(sj0*x1112);
IkReal x1134=(cj0*x1111);
IkReal x1135=(px*x1114);
IkReal x1136=((1.0)*x1116);
IkReal x1137=(x1113+x1117);
IkReal x1138=(x1111*x1112);
IkReal x1139=(x1114*x1115);
IkReal x1140=(sj0*x1125);
IkReal x1141=(cj0*x1125);
IkReal x1142=(x1116*x1125);
IkReal x1143=(x1114*x1125);
IkReal x1144=(x1128+x1126+x1127);
evalcond[0]=((-0.21115)+(((-0.06)*x1134))+(((-1.1e-6)*x1112))+(((-1.0)*x1122*x1129))+(((-0.15)*x1111))+(((-1.0)*px*x1132))+((pz*x1134))+(((-1.0)*x1118*x1129))+(((0.06)*x1133)));
evalcond[1]=((6.6e-7)+(((-1.1e-6)*x1111))+(((-1.0)*cj0*pz*x1129))+(((0.00244659)*cj2))+(((-0.08281387)*sj2))+(((-1.0)*x1111*x1118))+(((0.15)*x1112))+((px*x1133))+(((0.06)*x1132))+(((0.06)*x1131))+(((-1.0)*x1111*x1122)));
evalcond[2]=((0.0253474453653594)+x1137+((cj0*x1120))+(((-1.0)*x1144))+(((-1.0)*x1136))+(((1.32e-6)*pz*x1131))+(((-1.0)*sj0*x1121))+(((-7.92e-8)*x1131))+(((-7.92e-8)*x1132))+(((-1.98e-7)*x1112))+((x1122*x1130))+(((-1.0)*(py*py)))+(((1.452e-12)*x1111))+(((-0.018)*cj0))+((x1118*x1130))+(((-1.32e-6)*px*x1133))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-0.0072)*x1143))+x1139+x1137+(((-1.0)*x1121*x1140))+(((-1.0)*x1113*x1125))+(((-1.0)*x1114*x1136))+(((-0.01889999999879)*x1125))+(((4.0)*x1118*x1122*x1125))+(((-1.0)*x1117*x1125))+((x1124*x1135*x1138))+(((-0.24)*x1111*x1122*x1131))+(((-2.0)*x1125*x1139))+(((-2.0)*px*pz*x1138))+(((-0.3)*x1118*x1138))+(((0.018)*x1112*x1132))+(((-0.24)*x1118*x1140))+(((-1.0)*x1144))+((x1123*x1143))+(((-0.018)*x1141))+(((-1.0)*x1113*x1114))+((x1125*x1126))+((x1125*x1127))+(((0.12)*px*x1138))+(((-2.0)*x1116*x1131*x1132))+(((-2.0)*x1118*x1122))+((x1120*x1141))+(((2.0)*x1114*x1142))+(((-1.32e-7)*x1111*x1131))+(((-1.0)*x1112*x1120*x1132))+(((-3.3e-7)*x1138))+(((-2.2e-6)*px*x1112*x1132))+(((0.0072)*x1131*x1132))+(((0.12)*sj0*x1118))+(((0.0036)*x1114))+(((2.0)*x1115*x1131*x1132))+((x1111*x1119*x1131))+(((-1.0)*x1125*x1136))+(((-0.24)*x1135*x1138))+((x1115*x1125)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
IkReal x1145=sj0*sj0;
IkReal x1146=sj1*sj1;
IkReal x1147=cj0*cj0;
IkReal x1148=cj2*cj2;
IkReal x1149=cj1*cj1;
IkReal x1150=sj2*sj2;
IkReal x1151=(cj2*sj2);
IkReal x1152=((1145.753020896)*x1148);
IkReal x1153=(cj0*cj1*sj0*sj1);
IkReal x1154=(x1147*x1149);
IkReal x1155=(x1145*x1146);
j3eval[0]=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
j3eval[1]=((((-2291.50604179201)*x1148*x1153))+(((1146.753020896)*x1145*x1149))+(((67.6979474104201)*x1151*x1154))+(((67.6979474104201)*x1151*x1155))+(((-135.39589482084)*x1151*x1153))+(((-2.0)*x1150*x1153))+(((1146.753020896)*x1146*x1147))+((x1152*x1155))+((x1152*x1154))+(((2293.50604179201)*x1153))+((x1150*x1154))+((x1150*x1155)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1156=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1156.valid){
continue;
}
sj3array[0]=((x1156.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1157=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1157.valid){
continue;
}
sj3array[0]=((x1157.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1158=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1158.valid){
continue;
}
sj3array[0]=((x1158.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1159=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1159.valid){
continue;
}
sj3array[0]=((x1159.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1160=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1160.valid){
continue;
}
sj3array[0]=((x1160.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1161=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1161.valid){
continue;
}
sj3array[0]=((x1161.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1162=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1162.valid){
continue;
}
sj3array[0]=((x1162.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1163=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1163.valid){
continue;
}
sj3array[0]=((x1163.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x1164=(sj0*sj1);
IkReal x1165=((0.999563891228661)*cj2);
IkReal x1166=((0.0295301092415339)*sj2);
IkReal x1167=(cj0*cj1);
IkReal x1168=((((-1.0)*cj1*sj0))+(((-1.0)*cj0*sj1)));
IkReal x1169=(((x1165*x1167))+((x1166*x1167))+(((-1.0)*x1164*x1165))+(((-1.0)*x1164*x1166)));
CheckValue<IkReal> x1172 = IKatan2WithCheck(IkReal(x1168),IkReal(x1169),IKFAST_ATAN2_MAGTHRESH);
if(!x1172.valid){
continue;
}
IkReal x1170=((1.0)*(x1172.value));
if((((x1169*x1169)+(x1168*x1168))) < -0.00001)
continue;
CheckValue<IkReal> x1173=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1169*x1169)+(x1168*x1168)))),-1);
if(!x1173.valid){
continue;
}
if( (((x1173.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x1173.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1171=IKasin(((x1173.value)*(IKcos(r00))));
j3array[0]=(x1171+(((-1.0)*x1170)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x1170))+(((-1.0)*x1171)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}
}
}

} else
{
continue; // verifyAllEquations

}

}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "53a4976966144c9440d86012ca359708"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
