/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2022-09-15 23:28:37.710805
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[0]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[2]);
x6=((0.21115)*x2);
x7=((0.0828500022148737)*x5);
x8=((0.0828500022148737)*x4);
x9=(x0*x1);
x10=(x0*x3);
x11=(x2*x3);
x12=(x1*x2);
eetrans[0]=((((-1.0)*x7*(((((0.0295301092415339)*x11))+(((-0.0295301092415339)*x9))))))+((x4*(((((6.02202407431771e-10)*x9))+(((-6.02202407431771e-10)*x11))))))+(((-1.0)*x8*(((((-0.999563891228661)*x11))+(((0.999563891228661)*x9))))))+(((6.6e-7)*x9))+(((-1.1e-6)*x0))+(((-0.15)*x2))+(((-0.21115)*x10))+(((-1.0)*x1*x6))+((x5*(((((-2.03839334543722e-8)*x11))+(((2.03839334543722e-8)*x9))))))+(((-6.6e-7)*x11)));
eetrans[1]=((-0.001)+(((-0.00244659)*x4))+(((-0.08281387)*x5)));
eetrans[2]=((0.06)+(((-1.1e-6)*x2))+(((0.21115)*x9))+(((0.15)*x0))+((x5*(((((2.03839334543722e-8)*x10))+(((2.03839334543722e-8)*x12))))))+(((-1.0)*x7*(((((-0.0295301092415339)*x10))+(((-0.0295301092415339)*x12))))))+(((-1.0)*x3*x6))+((x4*(((((6.02202407431771e-10)*x12))+(((6.02202407431771e-10)*x10))))))+(((6.6e-7)*x10))+(((6.6e-7)*x12))+(((-1.0)*x8*(((((0.999563891228661)*x10))+(((0.999563891228661)*x12)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 4; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=px;
new_py=((-0.06)+pz);
new_pz=((0.0465)+(((-1.0)*py)));
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
if( (((-0.573325271335612)+(((12.0700057123287)*pz)))) < -1-IKFAST_SINCOS_THRESH || (((-0.573325271335612)+(((12.0700057123287)*pz)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x13=IKasin(((-0.573325271335612)+(((12.0700057123287)*pz))));
j2array[0]=((-1.54126167788295)+(((1.0)*x13)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((1.60033097570684)+(((-1.0)*x13)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[1];
j0eval[0]=((px*px)+(py*py));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[4];
IkReal x14=px*px;
IkReal x15=py*py;
j0eval[0]=((x14*x14)+((x14*x15)));
j0eval[1]=0.09000000000484;
j0eval[2]=px;
j0eval[3]=(x15+x14);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal j0eval[4];
IkReal x16=px*px;
IkReal x17=py*py;
j0eval[0]=((x17*x17)+((x16*x17)));
j0eval[1]=0.09000000000484;
j0eval[2]=py;
j0eval[3]=(x17+x16);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))))+IKsqr(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))), ((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x18=IKsin(j1);
IkReal x19=IKcos(j1);
IkReal x20=((0.029543239556369)*pz);
IkReal x21=((0.0828861501944662)*sj2);
evalcond[0]=((-0.21115)+(((-0.15)*x19))+(((-1.1e-6)*x18)));
evalcond[1]=((-0.00140264387892753)+(((-1.0)*x21))+(((-1.1e-6)*x19))+x20+(((0.15)*x18)));
evalcond[2]=((0.0266921953653594)+(((0.095)*pz))+(((1.452e-12)*x19))+(((-1.0)*(pz*pz)))+(((-1.98e-7)*x18)));
evalcond[3]=((1.1e-6)+(((-1.0)*x19*x20))+((x19*x21))+(((0.21115)*x18))+(((0.00140264387892753)*x19)));
evalcond[4]=((0.15)+((x18*x20))+(((0.21115)*x19))+(((-1.0)*x18*x21))+(((-0.00140264387892753)*x18)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))))+IKsqr(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))), ((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x22=IKsin(j1);
IkReal x23=IKcos(j1);
IkReal x24=((0.029543239556369)*pz);
IkReal x25=((0.0828861501944662)*sj2);
evalcond[0]=((-0.21115)+(((-0.15)*x23))+(((-1.1e-6)*x22)));
evalcond[1]=((-0.00140264387892753)+(((-1.0)*x25))+(((-1.1e-6)*x23))+x24+(((0.15)*x22)));
evalcond[2]=((0.0266921953653594)+(((0.095)*pz))+(((1.452e-12)*x23))+(((-1.0)*(pz*pz)))+(((-1.98e-7)*x22)));
evalcond[3]=((1.1e-6)+(((-1.0)*x23*x24))+(((0.21115)*x22))+((x23*x25))+(((0.00140264387892753)*x23)));
evalcond[4]=((0.15)+(((-1.0)*x22*x25))+((x22*x24))+(((0.21115)*x23))+(((-0.00140264387892753)*x22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x26=py*py;
IkReal x27=(px*py);
IkReal x28=((1.0)*py);
IkReal x29=((((0.3)*x26))+(((-2.2e-6)*x27)));
IkReal x30=((((-0.3)*x27))+(((-2.2e-6)*x26)));
CheckValue<IkReal> x33 = IKatan2WithCheck(IkReal(x29),IkReal(x30),IKFAST_ATAN2_MAGTHRESH);
if(!x33.valid){
continue;
}
IkReal x31=((1.0)*(x33.value));
if((((x30*x30)+(x29*x29))) < -0.00001)
continue;
CheckValue<IkReal> x34=IKPowWithIntegerCheck(IKabs(IKsqrt(((x30*x30)+(x29*x29)))),-1);
if(!x34.valid){
continue;
}
if( (((x34.value)*(((((-1.0)*px*x27))+(((0.0266921953662306)*py))+(((0.095)*py*pz))+(((-1.0)*x28*(py*py)))+(((-1.093143084e-7)*py*sj2))+(((-1.0)*x28*(pz*pz)))+(((3.2294988e-9)*cj2*py)))))) < -1-IKFAST_SINCOS_THRESH || (((x34.value)*(((((-1.0)*px*x27))+(((0.0266921953662306)*py))+(((0.095)*py*pz))+(((-1.0)*x28*(py*py)))+(((-1.093143084e-7)*py*sj2))+(((-1.0)*x28*(pz*pz)))+(((3.2294988e-9)*cj2*py)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x32=IKasin(((x34.value)*(((((-1.0)*px*x27))+(((0.0266921953662306)*py))+(((0.095)*py*pz))+(((-1.0)*x28*(py*py)))+(((-1.093143084e-7)*py*sj2))+(((-1.0)*x28*(pz*pz)))+(((3.2294988e-9)*cj2*py))))));
j0array[0]=((((-1.0)*x32))+(((-1.0)*x31)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x31))+x32);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x35=IKcos(j0);
IkReal x36=px*px;
IkReal x37=IKsin(j0);
IkReal x38=pz*pz;
IkReal x39=py*py;
IkReal x40=((0.3)*px);
IkReal x41=((2.2e-6)*py);
IkReal x42=((3.2294988e-9)*cj2);
IkReal x43=((1.093143084e-7)*sj2);
IkReal x44=((0.095)*pz);
evalcond[0]=((0.0266921953662306)+(((-1.0)*x36))+(((-1.0)*x39))+(((-1.0)*x38))+((x35*(((((0.3)*py))+(((-2.2e-6)*px))))))+(((-1.0)*x43))+((x37*(((((-1.0)*x41))+(((-1.0)*x40))))))+x44+x42);
evalcond[1]=((px*px*px)+((x37*((((px*x41))+(((0.3)*x36))))))+((px*x38))+((px*x39))+((px*x43))+((x35*(((((2.2e-6)*x36))+(((-1.0)*py*x40))))))+(((-1.0)*px*x44))+(((-1.0)*px*x42))+(((-0.0266921953662306)*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x45=cj2*cj2;
IkReal x46=(cj2*sj2);
j1eval[0]=((-15928929.7660716)+(((2121738.29008662)*x45))+(((33.8486914440098)*sj2))+(((-1.0)*cj2))+(((125475.560606061)*x46)));
j1eval[1]=IKsign(((-20576983.825925)+(((2740860.50469952)*x45))+(((-1.29179952)*cj2))+(((43.72572336)*sj2))+(((162089.26896264)*x46))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x47=(cj0*py);
IkReal x48=(px*sj0);
IkReal x49=((18358.833902375)*cj2);
IkReal x50=(cj0*px);
IkReal x51=((1656.2774)*sj2);
IkReal x52=(py*sj0);
IkReal x53=((621422.504033317)*sj2);
IkReal x54=((48.9318)*cj2);
j1eval[0]=((1.0)+(((-4.95253817581511)*x48))+(((93213.3756049976)*sj2))+(((-2753.82508535624)*cj2))+(((-1.0)*x48*x49))+((x47*x49))+(((4.95253817581511)*x47))+(((-1.0)*x47*x53))+((x48*x53))+(((1584437.02397479)*x50))+(((1584437.02397479)*x52)));
j1eval[1]=IKsign(((0.0026653)+(((4223.0)*x50))+(((4223.0)*x52))+(((-1.0)*x48*x54))+(((-1.0)*x47*x51))+((x48*x51))+(((248.44161)*sj2))+((x47*x54))+(((-0.0132)*x48))+(((0.0132)*x47))+(((-7.33977)*cj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x55=(py*sj0);
IkReal x56=((30771537.6763726)*sj2);
IkReal x57=((909090.909090909)*cj2);
IkReal x58=(cj0*px);
j1eval[0]=((11768699.217622)+(((78457994.7823483)*px*sj0))+(((-1.0)*x56*x58))+cj2+(((-78457994.7823483)*cj0*py))+(((-33.8486914440098)*sj2))+(((-1.0)*x55*x56))+((x57*x58))+(((245.239292239403)*x55))+(((245.239292239403)*x58))+((x55*x57)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x59=cj0*cj0;
IkReal x60=px*px;
IkReal x61=py*py;
IkReal x62=(cj0*px);
IkReal x63=((33125548.0)*sj2);
IkReal x64=(cj0*py);
IkReal x65=(py*sj0);
IkReal x66=(px*py);
IkReal x67=((978636.0)*cj2);
IkReal x68=((1656.2774)*sj2);
IkReal x69=(px*sj0);
IkReal x70=((48.9318)*cj2);
IkReal x71=((20000.0)*cj0*sj0);
IkReal x72=((400000000.0)*x61);
CheckValue<IkReal> x73=IKPowWithIntegerCheck(((633.45000001452)+(((4223.0)*x69))+((x62*x70))+(((0.0132)*x65))+(((0.0132)*x62))+(((5.382498e-5)*cj2))+(((-1.0)*x65*x68))+(((-4223.0)*x64))+((x65*x70))+(((-0.00182190514)*sj2))+(((-1.0)*x62*x68))),-1);
if(!x73.valid){
continue;
}
CheckValue<IkReal> x74=IKPowWithIntegerCheck(((12669000.0002904)+(((-36.4381028)*sj2))+(((1.0764996)*cj2))+(((264.0)*x62))+(((264.0)*x65))+((x62*x67))+(((84460000.0)*x69))+(((-84460000.0)*x64))+(((-1.0)*x63*x65))+(((-1.0)*x62*x63))+((x65*x67))),-1);
if(!x74.valid){
continue;
}
if( IKabs(((x73.value)*(((-0.00608718)+(((-3000.0)*x65))+(((-3000.0)*x62))+(((40000.0)*x59*x66))+(((-10.33194957)*cj2))+(((-1.0)*x60*x71))+(((-20000.0)*x66))+((x61*x71))+(((-0.022)*x69))+(((349.72297301)*sj2))+(((0.022)*x64)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x74.value)*(((-17833728.999516)+(((400000000.0)*x59*x60))+(((-1.0)*x59*x72))+(((880.0)*x65))+(((880.0)*x62))+x72+(((800000000.0)*x62*x65)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x73.value)*(((-0.00608718)+(((-3000.0)*x65))+(((-3000.0)*x62))+(((40000.0)*x59*x66))+(((-10.33194957)*cj2))+(((-1.0)*x60*x71))+(((-20000.0)*x66))+((x61*x71))+(((-0.022)*x69))+(((349.72297301)*sj2))+(((0.022)*x64))))))+IKsqr(((x74.value)*(((-17833728.999516)+(((400000000.0)*x59*x60))+(((-1.0)*x59*x72))+(((880.0)*x65))+(((880.0)*x62))+x72+(((800000000.0)*x62*x65))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x73.value)*(((-0.00608718)+(((-3000.0)*x65))+(((-3000.0)*x62))+(((40000.0)*x59*x66))+(((-10.33194957)*cj2))+(((-1.0)*x60*x71))+(((-20000.0)*x66))+((x61*x71))+(((-0.022)*x69))+(((349.72297301)*sj2))+(((0.022)*x64))))), ((x74.value)*(((-17833728.999516)+(((400000000.0)*x59*x60))+(((-1.0)*x59*x72))+(((880.0)*x65))+(((880.0)*x62))+x72+(((800000000.0)*x62*x65))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x75=IKcos(j1);
IkReal x76=IKsin(j1);
IkReal x77=((0.08281387)*sj2);
IkReal x78=(py*sj0);
IkReal x79=((1.32e-6)*px);
IkReal x80=(px*sj0);
IkReal x81=(cj0*py);
IkReal x82=((0.00244659)*cj2);
IkReal x83=(cj0*px);
IkReal x84=((1.0)*x83);
IkReal x85=(cj0*x75);
IkReal x86=((1.0)*x75);
IkReal x87=((1.0)*x76);
evalcond[0]=((1.1e-6)+(((0.21115)*x76))+((x75*x77))+(((-6.6e-7)*x75))+x78+x83+(((-1.0)*x75*x82)));
evalcond[1]=((0.15)+(((6.6e-7)*x76))+(((0.21115)*x75))+((x76*x82))+x80+(((-1.0)*x81))+(((-1.0)*x76*x77)));
evalcond[2]=((-0.21115)+(((-0.15)*x75))+(((-1.0)*x80*x86))+(((-1.0)*x78*x87))+((x75*x81))+(((-1.0)*x76*x84))+(((-1.1e-6)*x76)));
evalcond[3]=((6.6e-7)+(((-1.0)*x81*x87))+(((-1.0)*x77))+(((0.15)*x76))+(((-1.0)*x78*x86))+((x76*x80))+x82+(((-1.0)*x75*x84))+(((-1.1e-6)*x75)));
evalcond[4]=((0.0266921953653594)+(((-1.98e-7)*x76))+(((-1.0)*(px*px)))+((x79*x85))+(((1.32e-6)*x76*x81))+(((0.3)*x81))+(((1.32e-6)*x75*x78))+(((0.095)*pz))+(((-1.0)*sj0*x76*x79))+(((-2.2e-6)*x83))+(((-2.2e-6)*x78))+(((1.452e-12)*x75))+(((-1.0)*(pz*pz)))+(((-0.3)*x80))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x88=py*py;
IkReal x89=cj0*cj0;
IkReal x90=px*px;
IkReal x91=(cj0*py);
IkReal x92=((48.9318)*cj2);
IkReal x93=(px*sj0);
IkReal x94=(cj0*px);
IkReal x95=((1656.2774)*sj2);
IkReal x96=(py*sj0);
IkReal x97=(px*py);
IkReal x98=((20000.0)*x89);
IkReal x99=((20000.0)*cj0*sj0);
CheckValue<IkReal> x100=IKPowWithIntegerCheck(IKsign(((0.0026653)+(((0.0132)*x91))+(((4223.0)*x94))+(((4223.0)*x96))+(((-1.0)*x91*x95))+(((-0.0132)*x93))+((x93*x95))+(((-1.0)*x92*x93))+(((248.44161)*sj2))+(((-7.33977)*cj2))+((x91*x92)))),-1);
if(!x100.valid){
continue;
}
CheckValue<IkReal> x101 = IKatan2WithCheck(IkReal(((137.16274127205)+(((-40000.0)*x91*x93))+(((-137.043025234976)*(cj2*cj2)))+(((-1.0)*x90*x98))+(((-0.044)*x96))+(((-0.044)*x94))+(((-8.104463448132)*cj2*sj2))+((x88*x98))+(((-0.002186286168)*sj2))+(((-20000.0)*x88))+(((6.4589976e-5)*cj2)))),IkReal(((-0.00051282)+(((10.33194957)*cj2))+(((-349.72297301)*sj2))+(((-1.0)*x90*x99))+(((40000.0)*x89*x97))+(((-3000.0)*x94))+(((-3000.0)*x96))+((x88*x99))+(((-20000.0)*x97))+(((0.022)*x91))+(((-0.022)*x93)))),IKFAST_ATAN2_MAGTHRESH);
if(!x101.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x100.value)))+(x101.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x102=IKcos(j1);
IkReal x103=IKsin(j1);
IkReal x104=((0.08281387)*sj2);
IkReal x105=(py*sj0);
IkReal x106=((1.32e-6)*px);
IkReal x107=(px*sj0);
IkReal x108=(cj0*py);
IkReal x109=((0.00244659)*cj2);
IkReal x110=(cj0*px);
IkReal x111=((1.0)*x110);
IkReal x112=(cj0*x102);
IkReal x113=((1.0)*x102);
IkReal x114=((1.0)*x103);
evalcond[0]=((1.1e-6)+x110+x105+((x102*x104))+(((-6.6e-7)*x102))+(((-1.0)*x102*x109))+(((0.21115)*x103)));
evalcond[1]=((0.15)+x107+((x103*x109))+(((6.6e-7)*x103))+(((-1.0)*x103*x104))+(((0.21115)*x102))+(((-1.0)*x108)));
evalcond[2]=((-0.21115)+(((-1.0)*x107*x113))+(((-1.1e-6)*x103))+((x102*x108))+(((-0.15)*x102))+(((-1.0)*x103*x111))+(((-1.0)*x105*x114)));
evalcond[3]=((6.6e-7)+(((-1.0)*x104))+(((-1.1e-6)*x102))+x109+((x103*x107))+(((-1.0)*x108*x114))+(((-1.0)*x102*x111))+(((-1.0)*x105*x113))+(((0.15)*x103)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+((x106*x112))+(((0.095)*pz))+(((-2.2e-6)*x110))+(((0.3)*x108))+(((-2.2e-6)*x105))+(((-1.98e-7)*x103))+(((1.32e-6)*x103*x108))+(((1.32e-6)*x102*x105))+(((-1.0)*(pz*pz)))+(((-1.0)*sj0*x103*x106))+(((-0.3)*x107))+(((-1.0)*(py*py)))+(((1.452e-12)*x102)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x115=(py*sj0);
IkReal x116=((978636.0)*cj2);
IkReal x117=(px*sj0);
IkReal x118=((264.0)*cj0);
IkReal x119=((33125548.0)*sj2);
IkReal x120=(cj0*px);
IkReal x121=(cj0*py);
IkReal x122=(px*x119);
CheckValue<IkReal> x123=IKPowWithIntegerCheck(IKsign(((-20576983.825925)+(((2740860.50469952)*(cj2*cj2)))+(((-1.29179952)*cj2))+(((162089.26896264)*cj2*sj2))+(((43.72572336)*sj2)))),-1);
if(!x123.valid){
continue;
}
CheckValue<IkReal> x124 = IKatan2WithCheck(IkReal(((132.506)+(((264.0)*x117))+(((84460000.0)*x115))+(((146795.4)*cj2))+(((-1.0)*x117*x119))+(((-1.0)*x116*x121))+(((-4968832.2)*sj2))+((x116*x117))+((x119*x121))+(((84460000.0)*x120))+(((-1.0)*py*x118)))),IkReal(((12668999.9997096)+(((-264.0)*x115))+(((84460000.0)*x117))+(((-1.0)*px*x118))+(((-1.0)*x116*x120))+(((-1.0764996)*cj2))+(((-1.0)*x115*x116))+(((36.4381028)*sj2))+((x115*x119))+((x119*x120))+(((-84460000.0)*x121)))),IKFAST_ATAN2_MAGTHRESH);
if(!x124.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x123.value)))+(x124.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x125=IKcos(j1);
IkReal x126=IKsin(j1);
IkReal x127=((0.08281387)*sj2);
IkReal x128=(py*sj0);
IkReal x129=((1.32e-6)*px);
IkReal x130=(px*sj0);
IkReal x131=(cj0*py);
IkReal x132=((0.00244659)*cj2);
IkReal x133=(cj0*px);
IkReal x134=((1.0)*x133);
IkReal x135=(cj0*x125);
IkReal x136=((1.0)*x125);
IkReal x137=((1.0)*x126);
evalcond[0]=((1.1e-6)+x133+x128+((x125*x127))+(((-1.0)*x125*x132))+(((0.21115)*x126))+(((-6.6e-7)*x125)));
evalcond[1]=((0.15)+(((-1.0)*x126*x127))+(((6.6e-7)*x126))+x130+(((0.21115)*x125))+((x126*x132))+(((-1.0)*x131)));
evalcond[2]=((-0.21115)+(((-1.1e-6)*x126))+(((-1.0)*x126*x134))+(((-1.0)*x128*x137))+((x125*x131))+(((-0.15)*x125))+(((-1.0)*x130*x136)));
evalcond[3]=((6.6e-7)+(((-1.1e-6)*x125))+(((-1.0)*x127))+x132+(((-1.0)*x128*x136))+(((-1.0)*x125*x134))+((x126*x130))+(((0.15)*x126))+(((-1.0)*x131*x137)));
evalcond[4]=((0.0266921953653594)+(((1.32e-6)*x126*x131))+(((-1.0)*(px*px)))+(((-2.2e-6)*x133))+(((-2.2e-6)*x128))+((x129*x135))+(((0.095)*pz))+(((0.3)*x131))+(((-1.98e-7)*x126))+(((-1.0)*(pz*pz)))+(((-0.3)*x130))+(((-1.0)*sj0*x126*x129))+(((1.452e-12)*x125))+(((-1.0)*(py*py)))+(((1.32e-6)*x125*x128)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x138=px*px;
IkReal x139=(px*py);
IkReal x140=((((-0.3)*x139))+(((2.2e-6)*x138)));
IkReal x141=((((0.3)*x138))+(((2.2e-6)*x139)));
CheckValue<IkReal> x144 = IKatan2WithCheck(IkReal(x140),IkReal(x141),IKFAST_ATAN2_MAGTHRESH);
if(!x144.valid){
continue;
}
IkReal x142=((1.0)*(x144.value));
if((((x140*x140)+(x141*x141))) < -0.00001)
continue;
CheckValue<IkReal> x145=IKPowWithIntegerCheck(IKabs(IKsqrt(((x140*x140)+(x141*x141)))),-1);
if(!x145.valid){
continue;
}
if( (((x145.value)*(((px*px*px)+((py*x139))+(((1.093143084e-7)*px*sj2))+(((-0.095)*px*pz))+(((-3.2294988e-9)*cj2*px))+((px*(pz*pz)))+(((-0.0266921953662306)*px)))))) < -1-IKFAST_SINCOS_THRESH || (((x145.value)*(((px*px*px)+((py*x139))+(((1.093143084e-7)*px*sj2))+(((-0.095)*px*pz))+(((-3.2294988e-9)*cj2*px))+((px*(pz*pz)))+(((-0.0266921953662306)*px)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x143=IKasin(((x145.value)*(((px*px*px)+((py*x139))+(((1.093143084e-7)*px*sj2))+(((-0.095)*px*pz))+(((-3.2294988e-9)*cj2*px))+((px*(pz*pz)))+(((-0.0266921953662306)*px))))));
j0array[0]=((((-1.0)*x142))+(((-1.0)*x143)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x142))+x143);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x146=IKcos(j0);
IkReal x147=py*py;
IkReal x148=IKsin(j0);
IkReal x149=px*px;
IkReal x150=pz*pz;
IkReal x151=((0.3)*px);
IkReal x152=((2.2e-6)*py);
IkReal x153=((1.093143084e-7)*sj2);
IkReal x154=((0.095)*pz);
IkReal x155=((3.2294988e-9)*cj2);
IkReal x156=((1.0)*x150);
IkReal x157=((1.0)*x149);
evalcond[0]=((0.0266921953662306)+(((-1.0)*x157))+(((-1.0)*x153))+(((-1.0)*x156))+((x146*(((((0.3)*py))+(((-2.2e-6)*px))))))+x155+x154+(((-1.0)*x147))+((x148*(((((-1.0)*x151))+(((-1.0)*x152)))))));
evalcond[1]=(((x146*(((((0.3)*x147))+(((-1.0)*px*x152))))))+(((-1.0)*(py*py*py)))+(((0.0266921953662306)*py))+(((-1.0)*py*x153))+(((-1.0)*py*x156))+(((-1.0)*py*x157))+((x148*(((((-1.0)*py*x151))+(((-2.2e-6)*x147))))))+((py*x155))+((py*x154)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x158=cj2*cj2;
IkReal x159=(cj2*sj2);
j1eval[0]=((-15928929.7660716)+(((33.8486914440098)*sj2))+(((125475.560606061)*x159))+(((2121738.29008662)*x158))+(((-1.0)*cj2)));
j1eval[1]=IKsign(((-20576983.825925)+(((162089.26896264)*x159))+(((2740860.50469952)*x158))+(((-1.29179952)*cj2))+(((43.72572336)*sj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x160=(cj0*py);
IkReal x161=(px*sj0);
IkReal x162=((18358.833902375)*cj2);
IkReal x163=(cj0*px);
IkReal x164=((1656.2774)*sj2);
IkReal x165=(py*sj0);
IkReal x166=((621422.504033317)*sj2);
IkReal x167=((48.9318)*cj2);
j1eval[0]=((1.0)+((x161*x166))+(((93213.3756049976)*sj2))+(((-4.95253817581511)*x161))+(((-2753.82508535624)*cj2))+(((-1.0)*x160*x166))+(((-1.0)*x161*x162))+(((4.95253817581511)*x160))+((x160*x162))+(((1584437.02397479)*x163))+(((1584437.02397479)*x165)));
j1eval[1]=IKsign(((0.0026653)+((x161*x164))+(((-1.0)*x160*x164))+(((-1.0)*x161*x167))+(((0.0132)*x160))+(((4223.0)*x163))+(((4223.0)*x165))+(((248.44161)*sj2))+((x160*x167))+(((-7.33977)*cj2))+(((-0.0132)*x161))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x168=(py*sj0);
IkReal x169=((30771537.6763726)*sj2);
IkReal x170=((909090.909090909)*cj2);
IkReal x171=(cj0*px);
j1eval[0]=((11768699.217622)+(((78457994.7823483)*px*sj0))+cj2+((x168*x170))+(((245.239292239403)*x168))+(((245.239292239403)*x171))+(((-78457994.7823483)*cj0*py))+(((-33.8486914440098)*sj2))+(((-1.0)*x168*x169))+((x170*x171))+(((-1.0)*x169*x171)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x172=cj0*cj0;
IkReal x173=px*px;
IkReal x174=py*py;
IkReal x175=(cj0*px);
IkReal x176=((33125548.0)*sj2);
IkReal x177=(cj0*py);
IkReal x178=(py*sj0);
IkReal x179=(px*py);
IkReal x180=((978636.0)*cj2);
IkReal x181=((1656.2774)*sj2);
IkReal x182=(px*sj0);
IkReal x183=((48.9318)*cj2);
IkReal x184=((20000.0)*cj0*sj0);
IkReal x185=((400000000.0)*x174);
CheckValue<IkReal> x186=IKPowWithIntegerCheck(((633.45000001452)+(((-4223.0)*x177))+(((-1.0)*x178*x181))+((x178*x183))+((x175*x183))+(((4223.0)*x182))+(((0.0132)*x178))+(((0.0132)*x175))+(((-1.0)*x175*x181))+(((5.382498e-5)*cj2))+(((-0.00182190514)*sj2))),-1);
if(!x186.valid){
continue;
}
CheckValue<IkReal> x187=IKPowWithIntegerCheck(((12669000.0002904)+(((-1.0)*x175*x176))+(((-36.4381028)*sj2))+(((1.0764996)*cj2))+((x178*x180))+((x175*x180))+(((264.0)*x175))+(((264.0)*x178))+(((84460000.0)*x182))+(((-84460000.0)*x177))+(((-1.0)*x176*x178))),-1);
if(!x187.valid){
continue;
}
if( IKabs(((x186.value)*(((-0.00608718)+(((40000.0)*x172*x179))+(((0.022)*x177))+(((-20000.0)*x179))+(((-10.33194957)*cj2))+((x174*x184))+(((-3000.0)*x178))+(((-3000.0)*x175))+(((-0.022)*x182))+(((349.72297301)*sj2))+(((-1.0)*x173*x184)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x187.value)*(((-17833728.999516)+(((800000000.0)*x175*x178))+(((880.0)*x178))+(((880.0)*x175))+x185+(((400000000.0)*x172*x173))+(((-1.0)*x172*x185)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x186.value)*(((-0.00608718)+(((40000.0)*x172*x179))+(((0.022)*x177))+(((-20000.0)*x179))+(((-10.33194957)*cj2))+((x174*x184))+(((-3000.0)*x178))+(((-3000.0)*x175))+(((-0.022)*x182))+(((349.72297301)*sj2))+(((-1.0)*x173*x184))))))+IKsqr(((x187.value)*(((-17833728.999516)+(((800000000.0)*x175*x178))+(((880.0)*x178))+(((880.0)*x175))+x185+(((400000000.0)*x172*x173))+(((-1.0)*x172*x185))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x186.value)*(((-0.00608718)+(((40000.0)*x172*x179))+(((0.022)*x177))+(((-20000.0)*x179))+(((-10.33194957)*cj2))+((x174*x184))+(((-3000.0)*x178))+(((-3000.0)*x175))+(((-0.022)*x182))+(((349.72297301)*sj2))+(((-1.0)*x173*x184))))), ((x187.value)*(((-17833728.999516)+(((800000000.0)*x175*x178))+(((880.0)*x178))+(((880.0)*x175))+x185+(((400000000.0)*x172*x173))+(((-1.0)*x172*x185))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x188=IKcos(j1);
IkReal x189=IKsin(j1);
IkReal x190=((0.08281387)*sj2);
IkReal x191=(py*sj0);
IkReal x192=((1.32e-6)*px);
IkReal x193=(px*sj0);
IkReal x194=(cj0*py);
IkReal x195=((0.00244659)*cj2);
IkReal x196=(cj0*px);
IkReal x197=((1.0)*x196);
IkReal x198=(cj0*x188);
IkReal x199=((1.0)*x188);
IkReal x200=((1.0)*x189);
evalcond[0]=((1.1e-6)+(((-6.6e-7)*x188))+(((-1.0)*x188*x195))+((x188*x190))+x191+x196+(((0.21115)*x189)));
evalcond[1]=((0.15)+(((-1.0)*x189*x190))+(((-1.0)*x194))+((x189*x195))+x193+(((6.6e-7)*x189))+(((0.21115)*x188)));
evalcond[2]=((-0.21115)+(((-1.0)*x191*x200))+(((-1.0)*x189*x197))+((x188*x194))+(((-0.15)*x188))+(((-1.1e-6)*x189))+(((-1.0)*x193*x199)));
evalcond[3]=((6.6e-7)+(((-1.0)*x188*x197))+(((-1.0)*x194*x200))+(((-1.0)*x191*x199))+(((0.15)*x189))+(((-1.0)*x190))+((x189*x193))+x195+(((-1.1e-6)*x188)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+(((-1.98e-7)*x189))+(((0.095)*pz))+(((-2.2e-6)*x191))+(((-2.2e-6)*x196))+(((0.3)*x194))+(((1.452e-12)*x188))+((x192*x198))+(((-1.0)*sj0*x189*x192))+(((1.32e-6)*x188*x191))+(((-1.0)*(pz*pz)))+(((1.32e-6)*x189*x194))+(((-1.0)*(py*py)))+(((-0.3)*x193)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x201=py*py;
IkReal x202=cj0*cj0;
IkReal x203=px*px;
IkReal x204=(cj0*py);
IkReal x205=((48.9318)*cj2);
IkReal x206=(px*sj0);
IkReal x207=(cj0*px);
IkReal x208=((1656.2774)*sj2);
IkReal x209=(py*sj0);
IkReal x210=(px*py);
IkReal x211=((20000.0)*x202);
IkReal x212=((20000.0)*cj0*sj0);
CheckValue<IkReal> x213=IKPowWithIntegerCheck(IKsign(((0.0026653)+(((-1.0)*x204*x208))+((x204*x205))+(((0.0132)*x204))+(((-1.0)*x205*x206))+(((248.44161)*sj2))+(((4223.0)*x207))+(((4223.0)*x209))+((x206*x208))+(((-0.0132)*x206))+(((-7.33977)*cj2)))),-1);
if(!x213.valid){
continue;
}
CheckValue<IkReal> x214 = IKatan2WithCheck(IkReal(((137.16274127205)+(((-137.043025234976)*(cj2*cj2)))+(((-8.104463448132)*cj2*sj2))+(((-1.0)*x203*x211))+(((-40000.0)*x204*x206))+(((-0.002186286168)*sj2))+(((6.4589976e-5)*cj2))+(((-20000.0)*x201))+(((-0.044)*x207))+(((-0.044)*x209))+((x201*x211)))),IkReal(((-0.00051282)+(((10.33194957)*cj2))+(((-349.72297301)*sj2))+(((-20000.0)*x210))+(((-1.0)*x203*x212))+(((-0.022)*x206))+(((0.022)*x204))+(((-3000.0)*x209))+(((-3000.0)*x207))+(((40000.0)*x202*x210))+((x201*x212)))),IKFAST_ATAN2_MAGTHRESH);
if(!x214.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x213.value)))+(x214.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x215=IKcos(j1);
IkReal x216=IKsin(j1);
IkReal x217=((0.08281387)*sj2);
IkReal x218=(py*sj0);
IkReal x219=((1.32e-6)*px);
IkReal x220=(px*sj0);
IkReal x221=(cj0*py);
IkReal x222=((0.00244659)*cj2);
IkReal x223=(cj0*px);
IkReal x224=((1.0)*x223);
IkReal x225=(cj0*x215);
IkReal x226=((1.0)*x215);
IkReal x227=((1.0)*x216);
evalcond[0]=((1.1e-6)+(((-1.0)*x215*x222))+((x215*x217))+(((0.21115)*x216))+x218+x223+(((-6.6e-7)*x215)));
evalcond[1]=((0.15)+(((6.6e-7)*x216))+((x216*x222))+(((0.21115)*x215))+x220+(((-1.0)*x216*x217))+(((-1.0)*x221)));
evalcond[2]=((-0.21115)+(((-1.0)*x216*x224))+(((-0.15)*x215))+((x215*x221))+(((-1.0)*x220*x226))+(((-1.0)*x218*x227))+(((-1.1e-6)*x216)));
evalcond[3]=((6.6e-7)+(((-1.0)*x215*x224))+((x216*x220))+x222+(((-1.0)*x218*x226))+(((0.15)*x216))+(((-1.1e-6)*x215))+(((-1.0)*x221*x227))+(((-1.0)*x217)));
evalcond[4]=((0.0266921953653594)+(((-0.3)*x220))+(((-1.0)*(px*px)))+(((1.32e-6)*x216*x221))+(((-1.0)*sj0*x216*x219))+(((-2.2e-6)*x223))+(((0.095)*pz))+(((1.452e-12)*x215))+(((-2.2e-6)*x218))+(((1.32e-6)*x215*x218))+(((-1.98e-7)*x216))+((x219*x225))+(((0.3)*x221))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x228=(py*sj0);
IkReal x229=((978636.0)*cj2);
IkReal x230=(px*sj0);
IkReal x231=((264.0)*cj0);
IkReal x232=((33125548.0)*sj2);
IkReal x233=(cj0*px);
IkReal x234=(cj0*py);
IkReal x235=(px*x232);
CheckValue<IkReal> x236=IKPowWithIntegerCheck(IKsign(((-20576983.825925)+(((2740860.50469952)*(cj2*cj2)))+(((-1.29179952)*cj2))+(((162089.26896264)*cj2*sj2))+(((43.72572336)*sj2)))),-1);
if(!x236.valid){
continue;
}
CheckValue<IkReal> x237 = IKatan2WithCheck(IkReal(((132.506)+(((-1.0)*x230*x232))+((x229*x230))+(((146795.4)*cj2))+((x232*x234))+(((-1.0)*py*x231))+(((-4968832.2)*sj2))+(((84460000.0)*x233))+(((84460000.0)*x228))+(((264.0)*x230))+(((-1.0)*x229*x234)))),IkReal(((12668999.9997096)+(((-1.0)*px*x231))+((x232*x233))+((x228*x232))+(((-1.0764996)*cj2))+(((-1.0)*x228*x229))+(((-84460000.0)*x234))+(((-264.0)*x228))+(((84460000.0)*x230))+(((36.4381028)*sj2))+(((-1.0)*x229*x233)))),IKFAST_ATAN2_MAGTHRESH);
if(!x237.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x236.value)))+(x237.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x238=IKcos(j1);
IkReal x239=IKsin(j1);
IkReal x240=((0.08281387)*sj2);
IkReal x241=(py*sj0);
IkReal x242=((1.32e-6)*px);
IkReal x243=(px*sj0);
IkReal x244=(cj0*py);
IkReal x245=((0.00244659)*cj2);
IkReal x246=(cj0*px);
IkReal x247=((1.0)*x246);
IkReal x248=(cj0*x238);
IkReal x249=((1.0)*x238);
IkReal x250=((1.0)*x239);
evalcond[0]=((1.1e-6)+((x238*x240))+(((-6.6e-7)*x238))+x241+x246+(((-1.0)*x238*x245))+(((0.21115)*x239)));
evalcond[1]=((0.15)+(((-1.0)*x244))+(((6.6e-7)*x239))+((x239*x245))+x243+(((0.21115)*x238))+(((-1.0)*x239*x240)));
evalcond[2]=((-0.21115)+(((-1.1e-6)*x239))+((x238*x244))+(((-1.0)*x243*x249))+(((-0.15)*x238))+(((-1.0)*x241*x250))+(((-1.0)*x239*x247)));
evalcond[3]=((6.6e-7)+(((-1.1e-6)*x238))+(((-1.0)*x244*x250))+((x239*x243))+(((-1.0)*x241*x249))+x245+(((-1.0)*x238*x247))+(((-1.0)*x240))+(((0.15)*x239)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+(((0.095)*pz))+(((-0.3)*x243))+(((-1.0)*sj0*x239*x242))+(((-2.2e-6)*x246))+(((-2.2e-6)*x241))+(((0.3)*x244))+(((1.32e-6)*x239*x244))+(((1.452e-12)*x238))+(((-1.0)*(pz*pz)))+((x242*x248))+(((-1.0)*(py*py)))+(((-1.98e-7)*x239))+(((1.32e-6)*x238*x241)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x251=((((0.3)*py))+(((-2.2e-6)*px)));
IkReal x252=((((-0.3)*px))+(((-2.2e-6)*py)));
CheckValue<IkReal> x255 = IKatan2WithCheck(IkReal(x251),IkReal(x252),IKFAST_ATAN2_MAGTHRESH);
if(!x255.valid){
continue;
}
IkReal x253=((1.0)*(x255.value));
if((((x251*x251)+(x252*x252))) < -0.00001)
continue;
CheckValue<IkReal> x256=IKPowWithIntegerCheck(IKabs(IKsqrt(((x251*x251)+(x252*x252)))),-1);
if(!x256.valid){
continue;
}
if( (((x256.value)*(((0.0266921953662306)+(((-1.0)*(px*px)))+(((0.095)*pz))+(((3.2294988e-9)*cj2))+(((-1.0)*(pz*pz)))+(((-1.093143084e-7)*sj2))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x256.value)*(((0.0266921953662306)+(((-1.0)*(px*px)))+(((0.095)*pz))+(((3.2294988e-9)*cj2))+(((-1.0)*(pz*pz)))+(((-1.093143084e-7)*sj2))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x254=IKasin(((x256.value)*(((0.0266921953662306)+(((-1.0)*(px*px)))+(((0.095)*pz))+(((3.2294988e-9)*cj2))+(((-1.0)*(pz*pz)))+(((-1.093143084e-7)*sj2))+(((-1.0)*(py*py)))))));
j0array[0]=((((-1.0)*x254))+(((-1.0)*x253)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x254+(((-1.0)*x253)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[2];
IkReal x257=cj2*cj2;
IkReal x258=(cj2*sj2);
j1eval[0]=((-15928929.7660716)+(((33.8486914440098)*sj2))+(((2121738.29008662)*x257))+(((125475.560606061)*x258))+(((-1.0)*cj2)));
j1eval[1]=IKsign(((-20576983.825925)+(((-1.29179952)*cj2))+(((2740860.50469952)*x257))+(((43.72572336)*sj2))+(((162089.26896264)*x258))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x259=(cj0*py);
IkReal x260=(px*sj0);
IkReal x261=((18358.833902375)*cj2);
IkReal x262=(cj0*px);
IkReal x263=((1656.2774)*sj2);
IkReal x264=(py*sj0);
IkReal x265=((621422.504033317)*sj2);
IkReal x266=((48.9318)*cj2);
j1eval[0]=((1.0)+(((-4.95253817581511)*x260))+(((93213.3756049976)*sj2))+(((-2753.82508535624)*cj2))+((x259*x261))+((x260*x265))+(((-1.0)*x259*x265))+(((4.95253817581511)*x259))+(((1584437.02397479)*x262))+(((1584437.02397479)*x264))+(((-1.0)*x260*x261)));
j1eval[1]=IKsign(((0.0026653)+(((-0.0132)*x260))+((x259*x266))+((x260*x263))+(((-1.0)*x259*x263))+(((4223.0)*x264))+(((4223.0)*x262))+(((248.44161)*sj2))+(((0.0132)*x259))+(((-1.0)*x260*x266))+(((-7.33977)*cj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x267=(py*sj0);
IkReal x268=((30771537.6763726)*sj2);
IkReal x269=((909090.909090909)*cj2);
IkReal x270=(cj0*px);
j1eval[0]=((11768699.217622)+((x267*x269))+(((78457994.7823483)*px*sj0))+cj2+(((-78457994.7823483)*cj0*py))+(((-33.8486914440098)*sj2))+(((245.239292239403)*x270))+(((-1.0)*x268*x270))+(((245.239292239403)*x267))+(((-1.0)*x267*x268))+((x269*x270)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x271=cj0*cj0;
IkReal x272=px*px;
IkReal x273=py*py;
IkReal x274=(cj0*px);
IkReal x275=((33125548.0)*sj2);
IkReal x276=(cj0*py);
IkReal x277=(py*sj0);
IkReal x278=(px*py);
IkReal x279=((978636.0)*cj2);
IkReal x280=((1656.2774)*sj2);
IkReal x281=(px*sj0);
IkReal x282=((48.9318)*cj2);
IkReal x283=((20000.0)*cj0*sj0);
IkReal x284=((400000000.0)*x273);
CheckValue<IkReal> x285=IKPowWithIntegerCheck(((633.45000001452)+(((-4223.0)*x276))+(((-1.0)*x277*x280))+(((4223.0)*x281))+(((0.0132)*x274))+(((0.0132)*x277))+((x274*x282))+(((5.382498e-5)*cj2))+((x277*x282))+(((-0.00182190514)*sj2))+(((-1.0)*x274*x280))),-1);
if(!x285.valid){
continue;
}
CheckValue<IkReal> x286=IKPowWithIntegerCheck(((12669000.0002904)+(((-1.0)*x274*x275))+(((-36.4381028)*sj2))+(((1.0764996)*cj2))+((x274*x279))+(((84460000.0)*x281))+(((264.0)*x277))+(((264.0)*x274))+((x277*x279))+(((-1.0)*x275*x277))+(((-84460000.0)*x276))),-1);
if(!x286.valid){
continue;
}
if( IKabs(((x285.value)*(((-0.00608718)+(((-10.33194957)*cj2))+(((-0.022)*x281))+((x273*x283))+(((-3000.0)*x274))+(((-3000.0)*x277))+(((349.72297301)*sj2))+(((-20000.0)*x278))+(((-1.0)*x272*x283))+(((40000.0)*x271*x278))+(((0.022)*x276)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x286.value)*(((-17833728.999516)+(((880.0)*x277))+(((880.0)*x274))+x284+(((800000000.0)*x274*x277))+(((400000000.0)*x271*x272))+(((-1.0)*x271*x284)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x285.value)*(((-0.00608718)+(((-10.33194957)*cj2))+(((-0.022)*x281))+((x273*x283))+(((-3000.0)*x274))+(((-3000.0)*x277))+(((349.72297301)*sj2))+(((-20000.0)*x278))+(((-1.0)*x272*x283))+(((40000.0)*x271*x278))+(((0.022)*x276))))))+IKsqr(((x286.value)*(((-17833728.999516)+(((880.0)*x277))+(((880.0)*x274))+x284+(((800000000.0)*x274*x277))+(((400000000.0)*x271*x272))+(((-1.0)*x271*x284))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x285.value)*(((-0.00608718)+(((-10.33194957)*cj2))+(((-0.022)*x281))+((x273*x283))+(((-3000.0)*x274))+(((-3000.0)*x277))+(((349.72297301)*sj2))+(((-20000.0)*x278))+(((-1.0)*x272*x283))+(((40000.0)*x271*x278))+(((0.022)*x276))))), ((x286.value)*(((-17833728.999516)+(((880.0)*x277))+(((880.0)*x274))+x284+(((800000000.0)*x274*x277))+(((400000000.0)*x271*x272))+(((-1.0)*x271*x284))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x287=IKcos(j1);
IkReal x288=IKsin(j1);
IkReal x289=((0.08281387)*sj2);
IkReal x290=(py*sj0);
IkReal x291=((1.32e-6)*px);
IkReal x292=(px*sj0);
IkReal x293=(cj0*py);
IkReal x294=((0.00244659)*cj2);
IkReal x295=(cj0*px);
IkReal x296=((1.0)*x295);
IkReal x297=(cj0*x287);
IkReal x298=((1.0)*x287);
IkReal x299=((1.0)*x288);
evalcond[0]=((1.1e-6)+x290+x295+(((0.21115)*x288))+(((-1.0)*x287*x294))+(((-6.6e-7)*x287))+((x287*x289)));
evalcond[1]=((0.15)+(((-1.0)*x293))+(((6.6e-7)*x288))+(((-1.0)*x288*x289))+x292+(((0.21115)*x287))+((x288*x294)));
evalcond[2]=((-0.21115)+(((-0.15)*x287))+(((-1.0)*x290*x299))+((x287*x293))+(((-1.1e-6)*x288))+(((-1.0)*x288*x296))+(((-1.0)*x292*x298)));
evalcond[3]=((6.6e-7)+(((-1.0)*x290*x298))+(((-1.0)*x293*x299))+x294+(((0.15)*x288))+(((-1.1e-6)*x287))+(((-1.0)*x287*x296))+(((-1.0)*x289))+((x288*x292)));
evalcond[4]=((0.0266921953653594)+((x291*x297))+(((-1.0)*(px*px)))+(((1.32e-6)*x288*x293))+(((-1.98e-7)*x288))+(((0.095)*pz))+(((1.452e-12)*x287))+(((-1.0)*sj0*x288*x291))+(((-1.0)*(pz*pz)))+(((-0.3)*x292))+(((1.32e-6)*x287*x290))+(((-2.2e-6)*x290))+(((-2.2e-6)*x295))+(((-1.0)*(py*py)))+(((0.3)*x293)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x300=py*py;
IkReal x301=cj0*cj0;
IkReal x302=px*px;
IkReal x303=(cj0*py);
IkReal x304=((48.9318)*cj2);
IkReal x305=(px*sj0);
IkReal x306=(cj0*px);
IkReal x307=((1656.2774)*sj2);
IkReal x308=(py*sj0);
IkReal x309=(px*py);
IkReal x310=((20000.0)*x301);
IkReal x311=((20000.0)*cj0*sj0);
CheckValue<IkReal> x312=IKPowWithIntegerCheck(IKsign(((0.0026653)+(((-0.0132)*x305))+(((4223.0)*x308))+(((4223.0)*x306))+(((-1.0)*x303*x307))+((x303*x304))+((x305*x307))+(((248.44161)*sj2))+(((-1.0)*x304*x305))+(((0.0132)*x303))+(((-7.33977)*cj2)))),-1);
if(!x312.valid){
continue;
}
CheckValue<IkReal> x313 = IKatan2WithCheck(IkReal(((137.16274127205)+((x300*x310))+(((-137.043025234976)*(cj2*cj2)))+(((-0.044)*x306))+(((-0.044)*x308))+(((-8.104463448132)*cj2*sj2))+(((-1.0)*x302*x310))+(((-40000.0)*x303*x305))+(((-0.002186286168)*sj2))+(((-20000.0)*x300))+(((6.4589976e-5)*cj2)))),IkReal(((-0.00051282)+(((10.33194957)*cj2))+(((-349.72297301)*sj2))+((x300*x311))+(((-0.022)*x305))+(((0.022)*x303))+(((-1.0)*x302*x311))+(((40000.0)*x301*x309))+(((-3000.0)*x308))+(((-3000.0)*x306))+(((-20000.0)*x309)))),IKFAST_ATAN2_MAGTHRESH);
if(!x313.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x312.value)))+(x313.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x314=IKcos(j1);
IkReal x315=IKsin(j1);
IkReal x316=((0.08281387)*sj2);
IkReal x317=(py*sj0);
IkReal x318=((1.32e-6)*px);
IkReal x319=(px*sj0);
IkReal x320=(cj0*py);
IkReal x321=((0.00244659)*cj2);
IkReal x322=(cj0*px);
IkReal x323=((1.0)*x322);
IkReal x324=(cj0*x314);
IkReal x325=((1.0)*x314);
IkReal x326=((1.0)*x315);
evalcond[0]=((1.1e-6)+(((0.21115)*x315))+(((-1.0)*x314*x321))+x322+x317+(((-6.6e-7)*x314))+((x314*x316)));
evalcond[1]=((0.15)+(((0.21115)*x314))+(((-1.0)*x320))+x319+((x315*x321))+(((-1.0)*x315*x316))+(((6.6e-7)*x315)));
evalcond[2]=((-0.21115)+(((-1.1e-6)*x315))+(((-1.0)*x317*x326))+(((-1.0)*x315*x323))+((x314*x320))+(((-0.15)*x314))+(((-1.0)*x319*x325)));
evalcond[3]=((6.6e-7)+(((-1.1e-6)*x314))+(((-1.0)*x314*x323))+(((-1.0)*x317*x325))+((x315*x319))+(((-1.0)*x320*x326))+x321+(((-1.0)*x316))+(((0.15)*x315)));
evalcond[4]=((0.0266921953653594)+((x318*x324))+(((-1.0)*(px*px)))+(((-0.3)*x319))+(((0.095)*pz))+(((1.32e-6)*x315*x320))+(((1.32e-6)*x314*x317))+(((0.3)*x320))+(((-2.2e-6)*x317))+(((-1.0)*(pz*pz)))+(((-1.98e-7)*x315))+(((1.452e-12)*x314))+(((-1.0)*(py*py)))+(((-1.0)*sj0*x315*x318))+(((-2.2e-6)*x322)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x327=(py*sj0);
IkReal x328=((978636.0)*cj2);
IkReal x329=(px*sj0);
IkReal x330=((264.0)*cj0);
IkReal x331=((33125548.0)*sj2);
IkReal x332=(cj0*px);
IkReal x333=(cj0*py);
IkReal x334=(px*x331);
CheckValue<IkReal> x335=IKPowWithIntegerCheck(IKsign(((-20576983.825925)+(((2740860.50469952)*(cj2*cj2)))+(((-1.29179952)*cj2))+(((162089.26896264)*cj2*sj2))+(((43.72572336)*sj2)))),-1);
if(!x335.valid){
continue;
}
CheckValue<IkReal> x336 = IKatan2WithCheck(IkReal(((132.506)+(((84460000.0)*x332))+(((146795.4)*cj2))+((x328*x329))+((x331*x333))+(((-1.0)*x329*x331))+(((-1.0)*x328*x333))+(((264.0)*x329))+(((-1.0)*py*x330))+(((84460000.0)*x327))+(((-4968832.2)*sj2)))),IkReal(((12668999.9997096)+(((-1.0)*px*x330))+((x331*x332))+(((-1.0764996)*cj2))+(((-1.0)*x328*x332))+(((-1.0)*x327*x328))+(((84460000.0)*x329))+((x327*x331))+(((-264.0)*x327))+(((36.4381028)*sj2))+(((-84460000.0)*x333)))),IKFAST_ATAN2_MAGTHRESH);
if(!x336.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x335.value)))+(x336.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x337=IKcos(j1);
IkReal x338=IKsin(j1);
IkReal x339=((0.08281387)*sj2);
IkReal x340=(py*sj0);
IkReal x341=((1.32e-6)*px);
IkReal x342=(px*sj0);
IkReal x343=(cj0*py);
IkReal x344=((0.00244659)*cj2);
IkReal x345=(cj0*px);
IkReal x346=((1.0)*x345);
IkReal x347=(cj0*x337);
IkReal x348=((1.0)*x337);
IkReal x349=((1.0)*x338);
evalcond[0]=((1.1e-6)+((x337*x339))+(((-1.0)*x337*x344))+x340+x345+(((-6.6e-7)*x337))+(((0.21115)*x338)));
evalcond[1]=((0.15)+(((6.6e-7)*x338))+(((-1.0)*x338*x339))+x342+((x338*x344))+(((-1.0)*x343))+(((0.21115)*x337)));
evalcond[2]=((-0.21115)+((x337*x343))+(((-0.15)*x337))+(((-1.0)*x340*x349))+(((-1.0)*x338*x346))+(((-1.1e-6)*x338))+(((-1.0)*x342*x348)));
evalcond[3]=((6.6e-7)+(((-1.0)*x337*x346))+x344+(((0.15)*x338))+(((-1.0)*x340*x348))+(((-1.0)*x339))+((x338*x342))+(((-1.0)*x343*x349))+(((-1.1e-6)*x337)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*sj0*x338*x341))+(((-1.0)*(px*px)))+(((-1.98e-7)*x338))+(((1.452e-12)*x337))+(((-0.3)*x342))+(((1.32e-6)*x337*x340))+(((0.3)*x343))+(((0.095)*pz))+(((-1.0)*(pz*pz)))+((x341*x347))+(((-2.2e-6)*x345))+(((-2.2e-6)*x340))+(((-1.0)*(py*py)))+(((1.32e-6)*x338*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(4);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "c17c806fcdf508ef75f2bcf31f29cacb"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
