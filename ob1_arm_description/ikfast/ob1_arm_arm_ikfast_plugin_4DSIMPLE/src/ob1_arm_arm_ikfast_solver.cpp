/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2022-09-15 23:59:01.692691
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[0]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[2]);
x6=(x0*x1);
x7=(x1*x2);
x8=(x2*x3);
x9=(x0*x3);
eetrans[0]=((((6.6e-7)*x6))+(((-1.1e-6)*x0))+(((-0.21115)*x7))+(((-0.21115)*x9))+((x4*(((((-0.08281387)*x6))+(((0.08281387)*x8))))))+(((-0.15)*x2))+((x5*(((((0.00244659)*x6))+(((-0.00244659)*x8))))))+(((-6.6e-7)*x8)));
eetrans[1]=((-0.001)+(((-0.08281387)*x5))+(((-0.00244659)*x4)));
eetrans[2]=((0.06)+(((6.6e-7)*x7))+(((6.6e-7)*x9))+(((-1.1e-6)*x2))+(((0.21115)*x6))+(((-0.21115)*x8))+((x5*(((((0.00244659)*x9))+(((0.00244659)*x7))))))+(((0.15)*x0))+((x4*(((((-0.08281387)*x7))+(((-0.08281387)*x9)))))));
if( (((((((((-1.0)*x8))+(((1.0)*x6))))*(IKcos(j[3]))))+((((((x5*(((((0.999563891228661)*x9))+(((0.999563891228661)*x7))))))+((x4*(((((0.0295301092415339)*x7))+(((0.0295301092415339)*x9))))))))*(IKsin(j[3])))))) < -1-IKFAST_SINCOS_THRESH || (((((((((-1.0)*x8))+(((1.0)*x6))))*(IKcos(j[3]))))+((((((x5*(((((0.999563891228661)*x9))+(((0.999563891228661)*x7))))))+((x4*(((((0.0295301092415339)*x7))+(((0.0295301092415339)*x9))))))))*(IKsin(j[3])))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
eerot[0]=IKacos(((((((((-1.0)*x8))+(((1.0)*x6))))*(IKcos(j[3]))))+((((((x5*(((((0.999563891228661)*x9))+(((0.999563891228661)*x7))))))+((x4*(((((0.0295301092415339)*x7))+(((0.0295301092415339)*x9))))))))*(IKsin(j[3]))))));
return;
}
IKFAST_ASSERT(0);
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {4}; return freeparams; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x4400000d; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1;  _ij4[0] = -1; _ij4[1] = -1; _nj4 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

j4=pfree[0]; cj4=cos(pfree[0]); sj4=sin(pfree[0]);
r00 = eerot[0];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_px=px;
new_py=py;
new_pz=pz;
new_r00=r00;
r00 = new_r00; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
{
IkReal verifyeval[1];
verifyeval[0]=0;
if( IKabs(verifyeval[0]) < 0.0000010000000000  )
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
if( (((0.0120700057123287)+(((12.0700057123287)*py)))) < -1-IKFAST_SINCOS_THRESH || (((0.0120700057123287)+(((12.0700057123287)*py)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x10=IKasin(((0.0120700057123287)+(((12.0700057123287)*py))));
j2array[0]=((-1.54126167788295)+(((-1.0)*x10)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((1.60033097570684)+x10);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[4];
IkReal x11=px*px;
IkReal x12=pz*pz;
IkReal x13=((33.3333333333333)*pz);
IkReal x14=((277.777777777778)*x12);
j0eval[0]=3.6000000001936e-5;
j0eval[1]=px;
j0eval[2]=((1.0)+(((-1.0)*x13))+x14+(((277.777777777778)*x11)));
j0eval[3]=(x11+((x11*x14))+(((277.777777777778)*(x11*x11)))+(((-1.0)*x11*x13)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x15=px*px;
IkReal x16=pz*pz;
IkReal x17=(px*pz);
j0eval[0]=((1.0)+(((77160.4938271605)*(x16*x16)))+(((1666.66666666667)*x16))+(((-66.6666666666667)*pz))+(((-18518.5185185185)*(pz*pz*pz)))+(((-9259.25925925926)*pz*x15))+(((77160.4938271605)*x15*x16))+(((277.777777777778)*x15)));
j0eval[1]=((IKabs(((-7.92e-9)+(((0.018)*px))+(((2.64e-7)*pz))+(((-0.3)*x17))+(((-2.2e-6)*x16)))))+(IKabs(((0.00108)+(((0.3)*x16))+(((1.32e-7)*px))+(((-0.036)*pz))+(((-2.2e-6)*x17))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(px);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0eval[0]=((1.0)+(((-66.6666666666667)*pz))+(((77160.4938271605)*(pz*pz*pz*pz)))+(((-18518.5185185185)*(pz*pz*pz)))+(((1666.66666666667)*(pz*pz))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
pp=((py*py)+(pz*pz));
IkReal x18=pz*pz;
IkReal x19=py*py;
IkReal x20=pz*pz*pz*pz;
IkReal x21=pz*pz*pz;
IkReal x22=(py*pz);
IkReal x23=(pz*sj2);
IkReal x24=((4.0)*(pz*pz*pz*pz*pz));
IkReal x25=((1.98e-5)*x20);
IkReal x26=(pz*x19);
IkReal x27=(sj2*x18);
IkReal x28=(py*x18);
IkReal x29=((4.37638873026782e-7)*sj2*x21);
IkReal x30=((0.00800015598830486)*py*x21);
IkReal x31=((2.4070138016473e-13)*x27);
IkReal x32=((4.40008579356767e-9)*x28);
IkReal x33=(x18*x19);
IkReal x34=((4.0)*x19*x21);
IkReal x35=((2.2e-6)*x33);
IkReal x36=(x30+x34+x24+x29);
IkReal x37=(x32+x31+x35+x25);
j0eval[0]=((IKabs(((-0.000140604963803194)+(((-1.57549994289641e-8)*x23))+(((0.00432)*x19))+(((-0.144)*x26))+(((8.64016846736925e-6)*py))+(((-1.2)*x20))+(((-0.000288005615578975)*x22))+(((-0.0606569343897762)*x18))+(((1.31291661908034e-7)*x27))+(((4.72649982868924e-10)*sj2))+(((0.00520523212677315)*pz))+(((1.2)*x33))+(((0.288)*x21))+(((0.00240004679649146)*x28)))))+(IKabs(((1.46170248544598e-9)+(((-5.63241229585468e-15)*sj2))+(((-5.148e-8)*x19))+(((-1.02962007569484e-10)*py))+(((7.26e-7)*x26))+(((7.94314554543609e-14)*x23))+(((1.45202831187733e-9)*x22))+x37+(((-1.79270453075715e-8)*pz))+(((-7.16043797199137e-8)*x18))+(((-1.782e-6)*x21)))))+(IKabs(((6.94214019429361e-10)+(((-1.0)*x37))+(((-7.36546223304073e-15)*sj2))+(((1.37199786693896e-13)*x23))+(((-6.732e-8)*x19))+(((7.722e-6)*x21))+(((1.254e-6)*x26))+(((-9.97595620280086e-7)*x18))+(((-1.34642625283171e-10)*py))+(((2.47631035596492e-8)*pz))+(((2.50804890233357e-9)*x22)))))+(IKabs(((-5.61782891409583e-5)+(((-0.223789781299254)*x21))+(((-3.15099988579283e-9)*x23))+(((-0.0288)*x26))+(((0.00131369343897762)*x18))+(((2.59205054021077e-6)*py))+x36+(((-0.12)*x33))+(((0.001296)*x19))+(((-1.31291661908034e-8)*x27))+(((-5.7601123115795e-5)*x22))+(((-0.000240004679649146)*x28))+(((0.6)*x20))+(((1.41794994860677e-10)*sj2))+(((0.00148168642535463)*pz)))))+(IKabs(((5.14967650487534e-10)+(((-1.29978745288954e-15)*sj2))+(((1.3200257380703e-10)*x22))+(((7.2210414049419e-15)*x23))+(((-4.99933139159741e-9)*pz))+(((4.62e-7)*x21))+(((2.2e-6)*x20))+(((-2.37604632852654e-11)*py))+x32+x31+x35+(((-9.53643797199138e-8)*x18))+(((6.6e-8)*x26))+(((-1.188e-8)*x19)))))+(IKabs(((-2.22186746622361e-5)+(((0.0417093721712462)*x18))+(((1.32)*x33))+(((-0.00023040449246318)*x22))+(((3.30854988008247e-10)*sj2))+(((-1.26039995431713e-8)*x23))+(((-1.0)*x36))+(((0.0026400514761406)*x28))+(((3.0)*x20))+(((6.04811792715847e-6)*py))+(((1.44420828098838e-7)*x27))+(((-0.1152)*x26))+(((0.003024)*x19))+(((-0.000423654298581482)*pz))+(((-0.640210218700746)*x21))))));
if( IKabs(j0eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j1, j3]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal x38=py*py;
IkReal x39=pz*pz;
IkReal x40=pz*pz*pz;
IkReal x41=pz*pz*pz*pz;
IkReal x42=(py*pz);
IkReal x43=(pz*sj2);
IkReal x44=((1.98e-5)*x41);
IkReal x45=((4.0)*(pz*pz*pz*pz*pz));
IkReal x46=((2.2e-6)*x41);
IkReal x47=(pz*x38);
IkReal x48=(py*x39);
IkReal x49=(sj2*x39);
IkReal x50=((2.4070138016473e-13)*x49);
IkReal x51=((4.40008579356767e-9)*x48);
IkReal x52=((4.37638873026782e-7)*sj2*x40);
IkReal x53=((0.00800015598830486)*py*x40);
IkReal x54=(x38*x39);
IkReal x55=((2.2e-6)*x54);
IkReal x56=((4.0)*x38*x40);
IkReal x57=(x55+x51+x50);
IkReal x58=(x45+x56+x53+x52);
op[0]=((5.14967650487534e-10)+(((-1.29978745288954e-15)*sj2))+(((-4.99933139159741e-9)*pz))+(((7.2210414049419e-15)*x43))+(((-9.53643797199138e-8)*x39))+(((4.62e-7)*x40))+(((-1.188e-8)*x38))+(((-2.37604632852654e-11)*py))+x46+x57+(((1.3200257380703e-10)*x42))+(((6.6e-8)*x47)));
op[1]=((-5.61782891409583e-5)+(((-5.7601123115795e-5)*x42))+(((0.00131369343897762)*x39))+(((-1.31291661908034e-8)*x49))+(((-0.000240004679649146)*x48))+(((-0.12)*x54))+(((0.6)*x41))+(((-3.15099988579283e-9)*x43))+(((2.59205054021077e-6)*py))+x58+(((-0.223789781299254)*x40))+(((-0.0288)*x47))+(((1.41794994860677e-10)*sj2))+(((0.001296)*x38))+(((0.00148168642535463)*pz)));
op[2]=((1.46170248544598e-9)+(((-5.63241229585468e-15)*sj2))+(((-1.02962007569484e-10)*py))+(((1.45202831187733e-9)*x42))+(((7.26e-7)*x47))+(((-5.148e-8)*x38))+(((-7.16043797199137e-8)*x39))+x44+x57+(((-1.79270453075715e-8)*pz))+(((-1.782e-6)*x40))+(((7.94314554543609e-14)*x43)));
op[3]=((-0.000140604963803194)+(((-0.0606569343897762)*x39))+(((8.64016846736925e-6)*py))+(((0.00432)*x38))+(((1.31291661908034e-7)*x49))+(((-1.2)*x41))+(((4.72649982868924e-10)*sj2))+(((0.00520523212677315)*pz))+(((-1.57549994289641e-8)*x43))+(((1.2)*x54))+(((-0.000288005615578975)*x42))+(((0.00240004679649146)*x48))+(((-0.144)*x47))+(((0.288)*x40)));
op[4]=((6.94214019429361e-10)+(((1.254e-6)*x47))+(((7.722e-6)*x40))+(((-9.97595620280086e-7)*x39))+(((-6.732e-8)*x38))+(((-1.0)*x44))+(((-7.36546223304073e-15)*sj2))+(((2.50804890233357e-9)*x42))+(((-1.34642625283171e-10)*py))+(((2.47631035596492e-8)*pz))+(((-1.0)*x57))+(((1.37199786693896e-13)*x43)));
op[5]=((-2.22186746622361e-5)+(((-0.640210218700746)*x40))+(((0.0026400514761406)*x48))+(((3.30854988008247e-10)*sj2))+(((0.0417093721712462)*x39))+(((1.32)*x54))+(((3.0)*x41))+(((6.04811792715847e-6)*py))+(((1.44420828098838e-7)*x49))+(((0.003024)*x38))+(((-0.00023040449246318)*x42))+(((-0.1152)*x47))+(((-1.26039995431713e-8)*x43))+(((-0.000423654298581482)*pz))+(((-1.0)*x58)));
op[6]=((2.03671184470913e-10)+(((1.18802316426327e-9)*x42))+(((-2.772e-8)*x38))+(((7.27801747562329e-9)*pz))+(((1.518e-6)*x40))+(((-1.0)*x46))+(((-3.0328373900756e-15)*sj2))+(((-2.61035620280086e-7)*x39))+(((5.94e-7)*x47))+(((6.49893726444771e-14)*x43))+(((-1.0)*x57))+(((-5.54410809989527e-11)*py)));
polyroots6(op,zeror,numroots);
IkReal j0array[6], cj0array[6], sj0array[6], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[6]={true,true,true,true,true,true};
_nj0 = 6;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j1eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x59=pz*pz;
IkReal x60=(pz*sj0);
IkReal x61=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+(((-16.6666666666667)*x60))+sj0+(((-7575757.57575758)*x59))+(((2272727.27272727)*x61))+(((909090.909090909)*pz)));
j1eval[1]=IKsign(((-522.0000000242)+(((2400.0)*pz))+(((0.00264)*sj0))+(((6000.0)*x61))+(((-360.0)*cj0))+(((-0.044)*x60))+(((-20000.0)*x59))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x62=((1.0)+(((-16.6666666666667)*pz)));
IkReal x63=pz*pz;
IkReal x64=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x65=((-197727.272736439)+(((-7575757.57575758)*x63))+(((909090.909090909)*pz)));
IkReal x66=((x64*x64)+(x62*x62));
if((((18595041323.314)+(((5165289256476.13)*x63))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x67=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x63))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x74=IKPowWithIntegerCheck(x67,-1);
if(!x74.valid){
continue;
}
IkReal x68=x74.value;
IkReal x75 = x66;
if(IKabs(x75)==0){
continue;
}
IkReal x69=pow(x75,-0.5);
IkReal x70=(x62*x69);
IkReal x71=((1.0)*x64*x69);
IkReal x72=(x65*x68);
if((((1.0)+(((-1.0)*(x72*x72))))) < -0.00001)
continue;
IkReal x73=IKsqrt(((1.0)+(((-1.0)*(x72*x72)))));
if((x66) < -0.00001)
continue;
CheckValue<IkReal> x76=IKPowWithIntegerCheck(IKabs(IKsqrt(x66)),-1);
if(!x76.valid){
continue;
}
if( ((x65*(x76.value))) < -1-IKFAST_SINCOS_THRESH || ((x65*(x76.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x77 = IKatan2WithCheck(IkReal(x64),IkReal(x62),IKFAST_ATAN2_MAGTHRESH);
if(!x77.valid){
continue;
}
IkReal gconst34=((((-1.0)*(IKasin((x65*(x76.value))))))+(((-1.0)*(x77.value))));
IkReal gconst35=((((-1.0)*x70*x72))+(((-1.0)*x71*x73)));
IkReal gconst36=((((-1.0)*x71*x72))+((x70*x73)));
IkReal x78=pz*pz;
if((((18595041323.314)+(((5165289256476.13)*x78))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x80=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x78))+(((-619834710777.135)*pz))))),-1);
if(!x80.valid){
continue;
}
IkReal x79=x80.value;
CheckValue<IkReal> x81 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x81.valid){
continue;
}
if( (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x82 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x82.valid){
continue;
}
CheckValue<IkReal> x83 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x83.valid){
continue;
}
if( (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x84 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x84.valid){
continue;
}
CheckValue<IkReal> x85 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x85.valid){
continue;
}
if( (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x86 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x86.valid){
continue;
}
if((((((-1.0)*(x81.value)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))))+(((x82.value)*(x83.value)))+((j0*(j0)))+(((-1.0)*j0*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))))+(((-1.0)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))*(j0)))+(((-1.0)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))*(x84.value)))+((j0*(x85.value)))+(((1.0)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))))+(((x86.value)*(j0))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((((-1.0)*(x81.value)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))))+(((x82.value)*(x83.value)))+((j0*(j0)))+(((-1.0)*j0*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))))+(((-1.0)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))*(j0)))+(((-1.0)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))*(x84.value)))+((j0*(x85.value)))+(((1.0)*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))*(IKasin(((((7575757.57575758)*x78*x79))+(((-909090.909090909)*pz*x79))+(((197727.272736439)*x79)))))))+(((x86.value)*(j0))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x87=gconst35*gconst35;
IkReal x88=gconst36*gconst36;
IkReal x89=pz*pz;
IkReal x90=(gconst36*pz);
IkReal x91=((590.86479112738)*py);
IkReal x92=(gconst35*pz);
IkReal x93=((99.4633802333595)*sj2);
IkReal x94=((2400.0)*pz);
IkReal x95=((1657.72300388932)*sj2);
IkReal x96=((35.4518874676428)*py);
IkReal x97=((20000.0)*x89);
CheckValue<IkReal> x98 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst35))+(((4223.0)*x92))+(((-1.0)*gconst36*x93))+(((-1.0)*gconst36*x96))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst36))+((x90*x91))+((x90*x95))+(((0.57766479112738)*x90)))),IkReal(((633.450000635431)+(((-1.0)*gconst35*x96))+(((-1.0)*gconst35*x93))+((x92*x95))+(((253.38)*gconst36))+(((-4223.0)*x90))+(((-0.0346598874676428)*gconst35))+(((0.00182349530427826)*sj2))+(((0.57766479112738)*x92))+(((0.000649951270240118)*py))+((x91*x92)))),IKFAST_ATAN2_MAGTHRESH);
if(!x98.valid){
continue;
}
CheckValue<IkReal> x99=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x87*x94))+(((0.00264)*gconst35))+(((-72.0)*x88))+(((-72.0)*x87))+(((-0.044)*x92))+(((-1.0)*x87*x97))+(((-360.0)*gconst36))+((x88*x94))+(((6000.0)*x90))+(((-1.0)*x88*x97)))),-1);
if(!x99.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x98.value)+(((1.5707963267949)*(x99.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x100=IKcos(j1);
IkReal x101=IKsin(j1);
IkReal x102=((0.12)*pz);
IkReal x103=pz*pz;
IkReal x104=gconst36*gconst36;
IkReal x105=((1.32e-7)*gconst35);
IkReal x106=((0.3)*pz);
IkReal x107=(gconst35*pz);
IkReal x108=(gconst35*gconst36);
IkReal x109=(gconst36*pz);
IkReal x110=((0.018)*gconst36);
IkReal x111=x100*x100;
IkReal x112=((1.0)*x103);
IkReal x113=((2.2e-6)*x107);
IkReal x114=((0.06)*x100);
IkReal x115=(gconst35*x101);
IkReal x116=(gconst36*x101);
IkReal x117=(x105+x102);
IkReal x118=(x100*x101);
IkReal x119=(x103*x111);
IkReal x120=(x104*x111);
IkReal x121=(x113+x112);
evalcond[0]=((-0.21115)+(((-1.1e-6)*x101))+(((-1.0)*gconst36*x114))+(((0.06)*x115))+(((-1.0)*x101*x107))+(((-0.15)*x100))+((x100*x109)));
evalcond[1]=((-2.8883239556369e-5)+((gconst35*x114))+(((-1.1e-6)*x100))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((0.06)*x116))+(((-1.0)*x101*x109))+(((-1.0)*x100*x107))+(((0.15)*x101)));
evalcond[2]=((0.0253474453653594)+(((1.32e-6)*x100*x107))+((gconst36*x106))+(((-1.98e-7)*x101))+(((-1.0)*x110))+(((-7.92e-8)*x116))+(((-1.0)*x121))+x117+(((-7.92e-8)*gconst35*x100))+(((-1.0)*(py*py)))+(((1.32e-6)*x101*x109))+(((1.452e-12)*x100))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-0.0072)*x120))+((x111*x113))+(((-3.3e-7)*x118))+(((-1.0)*x100*x106*x115))+(((-0.24)*x100*x107*x116))+(((0.018)*x100*x115))+(((0.0072)*x108*x118))+(((-2.0)*x104*x119))+(((-1.0)*x110*x111))+(((-1.0)*x121))+x117+x119+((x103*x104))+(((-1.32e-7)*x100*x116))+(((2.2e-6)*x109*x118))+(((-0.01889999999879)*x111))+((gconst36*x106*x111))+(((-1.0)*x102*x104))+(((0.0036)*x104))+(((-1.0)*x102*x111))+(((-1.0)*x105*x111))+(((0.24)*pz*x120))+(((2.0)*x103*x108*x118)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x122=(cj1*gconst35);
IkReal x123=((0.999563891228661)*cj2);
IkReal x124=((0.0295301092415339)*sj2);
IkReal x125=(gconst36*sj1);
IkReal x126=(((cj1*gconst36))+(((-1.0)*gconst35*sj1)));
IkReal x127=(((x122*x124))+((x122*x123))+((x123*x125))+((x124*x125)));
CheckValue<IkReal> x130 = IKatan2WithCheck(IkReal(x126),IkReal(x127),IKFAST_ATAN2_MAGTHRESH);
if(!x130.valid){
continue;
}
IkReal x128=((1.0)*(x130.value));
if((((x126*x126)+(x127*x127))) < -0.00001)
continue;
CheckValue<IkReal> x131=IKPowWithIntegerCheck(IKabs(IKsqrt(((x126*x126)+(x127*x127)))),-1);
if(!x131.valid){
continue;
}
if( (((x131.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x131.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x129=IKasin(((x131.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x128))+x129);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x128))+(((-1.0)*x129)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x132=((1.0)+(((-16.6666666666667)*pz)));
IkReal x133=pz*pz;
IkReal x134=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x135=((-197727.272736439)+(((-7575757.57575758)*x133))+(((909090.909090909)*pz)));
IkReal x136=((x132*x132)+(x134*x134));
if((((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x133)))) < -0.00001)
continue;
IkReal x137=IKabs(IKsqrt(((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x133)))));
CheckValue<IkReal> x144=IKPowWithIntegerCheck(x137,-1);
if(!x144.valid){
continue;
}
IkReal x138=x144.value;
IkReal x145 = x136;
if(IKabs(x145)==0){
continue;
}
IkReal x139=pow(x145,-0.5);
IkReal x140=((1.0)*x134*x139);
IkReal x141=((1.0)*x132*x139);
IkReal x142=(x135*x138);
if((((1.0)+(((-1.0)*(x142*x142))))) < -0.00001)
continue;
IkReal x143=IKsqrt(((1.0)+(((-1.0)*(x142*x142)))));
if((x136) < -0.00001)
continue;
CheckValue<IkReal> x146=IKPowWithIntegerCheck(IKabs(IKsqrt(x136)),-1);
if(!x146.valid){
continue;
}
if( ((x135*(x146.value))) < -1-IKFAST_SINCOS_THRESH || ((x135*(x146.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x147 = IKatan2WithCheck(IkReal(x134),IkReal(x132),IKFAST_ATAN2_MAGTHRESH);
if(!x147.valid){
continue;
}
IkReal gconst37=((3.14159265358979)+(IKasin((x135*(x146.value))))+(((-1.0)*(x147.value))));
IkReal gconst38=(((x140*x143))+(((-1.0)*x141*x142)));
IkReal gconst39=((((-1.0)*x140*x142))+(((-1.0)*x141*x143)));
IkReal x148=((1.0)+(((-16.6666666666667)*pz)));
IkReal x149=((-136363.636363636)+(((2272727.27272727)*pz)));
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x150=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x150.valid){
continue;
}
if( (((x150.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x150.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x151 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x151.valid){
continue;
}
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x152=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x152.valid){
continue;
}
if( (((x152.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x152.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x153=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x153.valid){
continue;
}
if( (((x153.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x153.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x154 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x154.valid){
continue;
}
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x155=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x155.valid){
continue;
}
if( (((x155.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x155.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x156=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x156.valid){
continue;
}
if( (((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x157=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x157.valid){
continue;
}
if( (((x157.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x157.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x158 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x158.valid){
continue;
}
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x159=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x159.valid){
continue;
}
if( (((x159.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x159.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x160 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x160.valid){
continue;
}
CheckValue<IkReal> x161 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x161.valid){
continue;
}
CheckValue<IkReal> x162 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x162.valid){
continue;
}
CheckValue<IkReal> x163 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x163.valid){
continue;
}
if((((x149*x149)+(x148*x148))) < -0.00001)
continue;
CheckValue<IkReal> x164=IKPowWithIntegerCheck(IKabs(IKsqrt(((x149*x149)+(x148*x148)))),-1);
if(!x164.valid){
continue;
}
if( (((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x165 = IKatan2WithCheck(IkReal(x149),IkReal(x148),IKFAST_ATAN2_MAGTHRESH);
if(!x165.valid){
continue;
}
if((((9.86960440108936)+(((-1.0)*(IKasin(((x150.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x151.value)))+((j0*(j0)))+(((-1.0)*j0*(IKasin(((x152.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x153.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(x154.value)*(IKasin(((x155.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((1.0)*(IKasin(((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x157.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x158.value)*(j0)))+(((-1.0)*(IKasin(((x159.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((x160.value)*(x161.value)))+(((-3.14159265358979)*(x162.value)))+(((-3.14159265358979)*(j0)))+((j0*(x163.value)))+(((-3.14159265358979)*j0))+(((3.14159265358979)*(IKasin(((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(x165.value))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+(((-1.0)*(IKasin(((x150.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x151.value)))+((j0*(j0)))+(((-1.0)*j0*(IKasin(((x152.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x153.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(x154.value)*(IKasin(((x155.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((1.0)*(IKasin(((x156.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x157.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x158.value)*(j0)))+(((-1.0)*(IKasin(((x159.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((x160.value)*(x161.value)))+(((-3.14159265358979)*(x162.value)))+(((-3.14159265358979)*(j0)))+((j0*(x163.value)))+(((-3.14159265358979)*j0))+(((3.14159265358979)*(IKasin(((x164.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(x165.value))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x166=gconst38*gconst38;
IkReal x167=gconst39*gconst39;
IkReal x168=pz*pz;
IkReal x169=(gconst38*pz);
IkReal x170=((99.4633802333595)*sj2);
IkReal x171=(gconst39*pz);
IkReal x172=((35.4518874676428)*py);
IkReal x173=((2400.0)*pz);
IkReal x174=((590.86479112738)*py);
IkReal x175=((1657.72300388932)*sj2);
IkReal x176=((20000.0)*x168);
CheckValue<IkReal> x177=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((-0.044)*x169))+(((6000.0)*x171))+(((0.00264)*gconst38))+((x166*x173))+((x167*x173))+(((-360.0)*gconst39))+(((-72.0)*x166))+(((-72.0)*x167))+(((-1.0)*x166*x176))+(((-1.0)*x167*x176)))),-1);
if(!x177.valid){
continue;
}
CheckValue<IkReal> x178 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst38))+(((0.57766479112738)*x171))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst39))+((x171*x175))+((x171*x174))+(((4223.0)*x169))+(((-1.0)*gconst39*x170))+(((-1.0)*gconst39*x172)))),IkReal(((633.450000635431)+(((-4223.0)*x171))+(((253.38)*gconst39))+((x169*x174))+((x169*x175))+(((0.57766479112738)*x169))+(((-0.0346598874676428)*gconst38))+(((-1.0)*gconst38*x172))+(((-1.0)*gconst38*x170))+(((0.00182349530427826)*sj2))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x178.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x177.value)))+(x178.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x179=IKsin(j1);
IkReal x180=IKcos(j1);
IkReal x181=((0.12)*pz);
IkReal x182=pz*pz;
IkReal x183=gconst39*gconst39;
IkReal x184=((1.32e-7)*gconst38);
IkReal x185=((0.3)*pz);
IkReal x186=((0.018)*gconst39);
IkReal x187=(gconst38*pz);
IkReal x188=((1.0)*pz);
IkReal x189=((1.32e-6)*pz);
IkReal x190=(gconst38*gconst39);
IkReal x191=x180*x180;
IkReal x192=((2.2e-6)*x187);
IkReal x193=((1.0)*x182);
IkReal x194=(gconst38*x180);
IkReal x195=(gconst39*x180);
IkReal x196=((2.0)*x182);
IkReal x197=((0.06)*x179);
IkReal x198=(gconst39*x179);
IkReal x199=(x184+x181);
IkReal x200=(x179*x180);
IkReal x201=(x183*x191);
IkReal x202=(x193+x192);
evalcond[0]=((-0.21115)+(((-0.06)*x195))+((gconst38*x197))+(((-0.15)*x180))+(((-1.0)*x179*x187))+(((-1.1e-6)*x179))+((pz*x195)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x188*x198))+(((0.06)*x194))+(((0.15)*x179))+((gconst39*x197))+(((-1.0)*x180*x187))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((-1.1e-6)*x180)));
evalcond[2]=((0.0253474453653594)+(((-1.98e-7)*x179))+(((-1.0)*x186))+((x189*x198))+x199+(((1.452e-12)*x180))+(((-1.0)*x202))+((gconst39*x185))+(((-1.0)*(py*py)))+(((1.32e-6)*x180*x187))+(((-7.92e-8)*x198))+(((-7.92e-8)*x194))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((0.0036)*x183))+(((-1.0)*x179*x185*x194))+(((0.018)*x179*x194))+(((-1.0)*x186*x191))+(((-0.01889999999879)*x191))+(((-0.24)*x179*x187*x195))+((gconst39*x185*x191))+x199+(((-1.0)*x202))+(((-1.0)*x184*x191))+(((0.24)*pz*x201))+((x191*x192))+(((0.0072)*x190*x200))+((x190*x196*x200))+(((-1.0)*x196*x201))+(((-0.0072)*x201))+(((2.2e-6)*pz*x179*x195))+((x182*x191))+(((-1.0)*x181*x191))+(((-3.3e-7)*x200))+((x182*x183))+(((-1.0)*x181*x183))+(((-1.32e-7)*x179*x195)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x203=((0.999563891228661)*cj2);
IkReal x204=(gconst39*sj1);
IkReal x205=(cj1*gconst38);
IkReal x206=((0.0295301092415339)*sj2);
IkReal x207=((((-1.0)*gconst38*sj1))+((cj1*gconst39)));
IkReal x208=(((x205*x206))+((x204*x206))+((x203*x205))+((x203*x204)));
CheckValue<IkReal> x211 = IKatan2WithCheck(IkReal(x207),IkReal(x208),IKFAST_ATAN2_MAGTHRESH);
if(!x211.valid){
continue;
}
IkReal x209=((1.0)*(x211.value));
if((((x208*x208)+(x207*x207))) < -0.00001)
continue;
CheckValue<IkReal> x212=IKPowWithIntegerCheck(IKabs(IKsqrt(((x208*x208)+(x207*x207)))),-1);
if(!x212.valid){
continue;
}
if( (((x212.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x212.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x210=IKasin(((x212.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x209))+x210);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x209))+(((-1.0)*x210)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x213=(pz*sj0);
IkReal x214=((590.86479112738)*py);
IkReal x215=((99.4633802333595)*sj2);
IkReal x216=(cj0*pz);
IkReal x217=((1657.72300388932)*sj2);
IkReal x218=((35.4518874676428)*py);
CheckValue<IkReal> x219=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((6000.0)*x216))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-0.044)*x213))+(((-360.0)*cj0)))),-1);
if(!x219.valid){
continue;
}
CheckValue<IkReal> x220 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*sj0))+((x214*x216))+((x216*x217))+(((0.57766479112738)*x216))+(((-248.658450583399)*sj2))+(((4223.0)*x213))+(((-1.0)*cj0*x215))+(((-1.0)*cj0*x218))+(((-0.0346598874676428)*cj0)))),IkReal(((633.450000635431)+((x213*x214))+((x213*x217))+(((253.38)*cj0))+(((-0.0346598874676428)*sj0))+(((0.57766479112738)*x213))+(((-1.0)*sj0*x215))+(((-1.0)*sj0*x218))+(((0.00182349530427826)*sj2))+(((-4223.0)*x216))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x220.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x219.value)))+(x220.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x221=IKcos(j1);
IkReal x222=IKsin(j1);
IkReal x223=((0.12)*pz);
IkReal x224=cj0*cj0;
IkReal x225=pz*pz;
IkReal x226=((1.32e-7)*sj0);
IkReal x227=((2.2e-6)*pz);
IkReal x228=((0.06)*sj0);
IkReal x229=((0.3)*pz);
IkReal x230=((1.0)*pz);
IkReal x231=x221*x221;
IkReal x232=(sj0*x227);
IkReal x233=((1.0)*x225);
IkReal x234=(cj0*x222);
IkReal x235=(cj0*x221);
IkReal x236=(sj0*x221);
IkReal x237=((2.0)*x225);
IkReal x238=(x223+x226);
IkReal x239=(x221*x222);
IkReal x240=(sj0*x231);
IkReal x241=(cj0*x231);
IkReal x242=(pz*x236);
IkReal x243=(x224*x231);
IkReal x244=(x232+x233);
evalcond[0]=((-0.21115)+(((-1.1e-6)*x222))+((x222*x228))+((pz*x235))+(((-1.0)*sj0*x222*x230))+(((-0.06)*x235))+(((-0.15)*x221)));
evalcond[1]=((-2.8883239556369e-5)+(((0.15)*x222))+(((-1.1e-6)*x221))+(((-1.0)*x230*x234))+(((-1.0)*x230*x236))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+((x221*x228))+(((0.06)*x234)));
evalcond[2]=((0.0253474453653594)+(((1.32e-6)*pz*x234))+(((1.32e-6)*x242))+((cj0*x229))+x238+(((-1.98e-7)*x222))+(((1.452e-12)*x221))+(((-7.92e-8)*x234))+(((-7.92e-8)*x236))+(((-1.0)*x244))+(((-1.0)*(py*py)))+(((-0.018)*cj0))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+((x224*x225))+(((-0.0072)*x243))+(((-0.018)*x241))+(((-1.0)*x222*x229*x236))+(((0.018)*x222*x236))+((x234*x236*x237))+(((-1.0)*x237*x243))+(((-0.01889999999879)*x231))+((x221*x227*x234))+((x229*x241))+(((-0.24)*x234*x242))+x238+(((-1.0)*x223*x224))+((x225*x231))+(((-1.0)*x226*x231))+(((0.0072)*x234*x236))+(((-1.32e-7)*x221*x234))+(((0.0036)*x224))+(((-1.0)*x223*x231))+(((-1.0)*x244))+(((0.24)*pz*x243))+((x231*x232))+(((-3.3e-7)*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x245=cj2*cj2;
IkReal x246=cj1*cj1;
IkReal x247=cj0*cj0;
IkReal x248=sj1*sj1;
IkReal x249=sj0*sj0;
IkReal x250=sj2*sj2;
IkReal x251=(cj0*cj1);
IkReal x252=(sj0*sj1);
IkReal x253=((67.6979474104201)*cj2*sj2);
IkReal x254=((1145.753020896)*x245);
IkReal x255=(x247*x248);
IkReal x256=(x246*x249);
j3eval[0]=((((-2293.50604179201)*x251*x252))+(((1146.753020896)*x246*x247))+((x250*x255))+((x250*x256))+((x253*x255))+((x253*x256))+(((1146.753020896)*x248*x249))+(((2291.50604179201)*x245*x251*x252))+(((135.39589482084)*cj2*sj2*x251*x252))+(((2.0)*x250*x251*x252))+((x254*x256))+((x254*x255)));
j3eval[1]=(x251+(((-1.0)*x252)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x257=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x257.valid){
continue;
}
sj3array[0]=((x257.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x258=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x258.valid){
continue;
}
sj3array[0]=((x258.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x259=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x259.valid){
continue;
}
sj3array[0]=((x259.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x260=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x260.valid){
continue;
}
sj3array[0]=((x260.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x261=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x261.valid){
continue;
}
sj3array[0]=((x261.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x262=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x262.valid){
continue;
}
sj3array[0]=((x262.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x263=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x263.valid){
continue;
}
sj3array[0]=((x263.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x264=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x264.valid){
continue;
}
sj3array[0]=((x264.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x265=(cj1*sj0);
IkReal x266=((0.0295301092415339)*sj2);
IkReal x267=((0.999563891228661)*cj2);
IkReal x268=(cj0*sj1);
IkReal x269=(((cj0*cj1))+(((-1.0)*sj0*sj1)));
IkReal x270=(((x267*x268))+((x266*x268))+((x265*x266))+((x265*x267)));
CheckValue<IkReal> x273 = IKatan2WithCheck(IkReal(x269),IkReal(x270),IKFAST_ATAN2_MAGTHRESH);
if(!x273.valid){
continue;
}
IkReal x271=((1.0)*(x273.value));
if((((x270*x270)+(x269*x269))) < -0.00001)
continue;
CheckValue<IkReal> x274=IKPowWithIntegerCheck(IKabs(IKsqrt(((x270*x270)+(x269*x269)))),-1);
if(!x274.valid){
continue;
}
if( (((x274.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x274.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x272=IKasin(((x274.value)*(IKcos(r00))));
j3array[0]=(x272+(((-1.0)*x271)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x272))+(((-1.0)*x271)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
    }

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x275=pz*pz;
IkReal x276=py*py;
IkReal x277=((0.00108)+(((0.3)*x275))+(((-0.036)*pz)));
IkReal x278=((-7.92e-9)+(((2.64e-7)*pz))+(((-2.2e-6)*x275)));
CheckValue<IkReal> x281 = IKatan2WithCheck(IkReal(x277),IkReal(x278),IKFAST_ATAN2_MAGTHRESH);
if(!x281.valid){
continue;
}
IkReal x279=((1.0)*(x281.value));
if((((x278*x278)+(x277*x277))) < -0.00001)
continue;
CheckValue<IkReal> x282=IKPowWithIntegerCheck(IKabs(IKsqrt(((x278*x278)+(x277*x277)))),-1);
if(!x282.valid){
continue;
}
if( (((x282.value)*(((-0.00152084671963401)+(((0.0181474453272335)*pz))+(((6.56458309540172e-9)*sj2))+(((-1.09409718256695e-7)*pz*sj2))+(((-1.0)*(pz*pz*pz)))+(((-1.0)*pz*x276))+(((0.000120002339824573)*py))+(((0.18)*x275))+(((-0.00200003899707621)*py*pz))+(((0.06)*x276)))))) < -1-IKFAST_SINCOS_THRESH || (((x282.value)*(((-0.00152084671963401)+(((0.0181474453272335)*pz))+(((6.56458309540172e-9)*sj2))+(((-1.09409718256695e-7)*pz*sj2))+(((-1.0)*(pz*pz*pz)))+(((-1.0)*pz*x276))+(((0.000120002339824573)*py))+(((0.18)*x275))+(((-0.00200003899707621)*py*pz))+(((0.06)*x276)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x280=IKasin(((x282.value)*(((-0.00152084671963401)+(((0.0181474453272335)*pz))+(((6.56458309540172e-9)*sj2))+(((-1.09409718256695e-7)*pz*sj2))+(((-1.0)*(pz*pz*pz)))+(((-1.0)*pz*x276))+(((0.000120002339824573)*py))+(((0.18)*x275))+(((-0.00200003899707621)*py*pz))+(((0.06)*x276))))));
j0array[0]=((((-1.0)*x280))+(((-1.0)*x279)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x280+(((-1.0)*x279)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x283=py*py;
IkReal x284=pz*pz;
IkReal x285=pz*pz*pz*pz;
IkReal x286=IKcos(j0);
IkReal x287=IKsin(j0);
IkReal x288=pz*pz*pz;
IkReal x289=pz*pz*pz*pz*pz;
IkReal x290=((2.16004211684231e-6)*py);
IkReal x291=((1.18162495717231e-10)*sj2);
IkReal x292=((1.58403088568436e-11)*py);
IkReal x293=((8.66524968593028e-16)*sj2);
IkReal x294=((4.72649982868924e-11)*sj2);
IkReal x295=((8.64016846736925e-7)*py);
IkReal x296=((3.8016e-9)*pz);
IkReal x297=((0.0005184)*pz);
IkReal x298=(pz*sj2);
IkReal x299=(py*pz);
IkReal x300=((4.4e-6)*x285);
IkReal x301=((1.056e-6)*x288);
IkReal x302=x286*x286;
IkReal x303=((0.6)*x285);
IkReal x304=((0.3)*x285);
IkReal x305=((0.00108)*x283);
IkReal x306=((3.93874985724103e-9)*x298);
IkReal x307=((7.20014038947437e-5)*x299);
IkReal x308=((5.28010295228121e-10)*x299);
IkReal x309=((2.88841656197676e-14)*x298);
IkReal x310=((7.92e-9)*x283);
IkReal x311=((0.000432)*x283);
IkReal x312=((2.36324991434462e-9)*x298);
IkReal x313=((4.32008423368462e-5)*x299);
IkReal x314=((2.0)*x289);
IkReal x315=x287*x287;
IkReal x316=((9.504e-8)*x284);
IkReal x317=((0.01296)*x284);
IkReal x318=((0.144)*x288);
IkReal x319=(py*x284);
IkReal x320=(sj2*x288);
IkReal x321=(sj2*x284);
IkReal x322=(pz*x283);
IkReal x323=(py*x288);
IkReal x324=((0.000600011699122864)*x319);
IkReal x325=((3.28229154770086e-8)*x321);
IkReal x326=((0.036)*x322);
IkReal x327=((2.64e-7)*x322);
IkReal x328=((2.4070138016473e-13)*x321);
IkReal x329=((4.40008579356767e-9)*x319);
IkReal x330=((0.000720014038947437)*x319);
IkReal x331=((3.93874985724103e-8)*x321);
IkReal x332=((0.0216)*x322);
IkReal x333=((2.18819436513391e-7)*x320);
IkReal x334=((0.00400007799415243)*x323);
IkReal x335=(x283*x288);
IkReal x336=(x283*x284);
IkReal x337=((0.3)*x336);
IkReal x338=((2.2e-6)*x336);
IkReal x339=((0.36)*x336);
IkReal x340=((2.0)*x335);
IkReal x341=(x301+x296);
IkReal x342=(x318+x297);
IkReal x343=(x287*x302);
IkReal x344=(x300+x316);
IkReal x345=(x303+x317);
IkReal x346=((-1.4256e-10)+(((6.6e-7)*x288))+(((7.128e-9)*pz))+(((-1.188e-7)*x284)));
IkReal x347=(x308+x309+x327);
IkReal x348=(x306+x307+x326);
IkReal x349=(x338+x328+x329+x310+x292+x293);
IkReal x350=(x305+x337+x324+x325+x290+x291);
IkReal x351=(x303+x339+x331+x330+x311+x294+x295);
IkReal x352=(x333+x332+x334+x314+x313+x312+x340);
evalcond[0]=((2.87440029992426e-5)+(((1.96937492862052e-8)*x321))+((x286*(((6.96324095471901e-6)+(((-1.0)*x350))+x348+(((-0.000232108031823967)*pz))+(((0.00193423359853306)*x284))))))+(((-0.00200003899707621)*x323))+(((0.0154474453260235)*x288))+(((-2.26804422253922e-6)*py))+(((0.18)*x336))+(((0.000360007019473719)*x319))+(((-1.24070620495149e-10)*sj2))+(((0.01169999999879)*x322))+x304+(((-1.0)*x335))+(((-1.0)*x289))+((x287*(((3.50439766982106e-10)+(((-9.78052556607021e-9)*pz))+x301+x347+(((1.81443797172518e-8)*x284))+(((-1.0)*x349))+(((-1.0)*x300))))))+((x315*(((1.04544e-15)+(((-4.84e-12)*x288))+(((8.712e-13)*x284))+(((-5.2272e-14)*pz))))))+((x343*(((5.7024e-11)+x344+(((-1.0)*x341))))))+(((-0.0011339999999274)*x283))+(((1.28009370347095e-9)*x298))+((x302*(((-8.48990361863512e-6)+(((0.104105109345533)*x288))+(((-1.0)*x351))+(((-0.0100989196821959)*x284))+x352+(((0.000476335180931756)*pz))))))+(((-0.00710054015868423)*x284))+(((x286*x286*x286)*(((-7.776e-6)+x342+(((-1.0)*x345))))))+(((2.34004562633717e-5)*x299))+(((-0.000160485110306674)*pz))+(((-1.09409718256695e-7)*x320)));
evalcond[1]=((5.01879417479224e-10)+(((-1.98e-8)*x283))+(((-2.16631242148257e-15)*sj2))+(((-5.94e-8)*x284))+((x343*(((7.776e-6)+x345+(((-1.0)*x342))))))+((x286*x315*(((-5.7024e-11)+x341+(((-1.0)*x344))))))+((x302*x346))+((x315*x346))+(((3.3e-7)*x288))+(((-5.98865695798706e-9)*pz))+(((3.3e-7)*x322))+(((6.60012869035151e-10)*x299))+((x286*(((-1.5564823300831e-10)+(((-2.2e-6)*x285))+(((-8.28356202800863e-8)*x284))+x347+(((-1.0)*x349))+(((5.28e-7)*x288))+(((6.13867443361035e-9)*pz))))))+(((-3.9600772142109e-11)*py))+((x286*x287*(((8.48990361968056e-6)+(((-1.0)*x352))+x351+(((-0.000476335180984028)*pz))+(((0.0100989196830671)*x284))+(((-0.104105109350373)*x288))))))+((x287*(((-2.73752409507986e-5)+(((-0.072)*x288))+(((0.000782908031693287)*pz))+x304+x350+(((-0.00220423359744406)*x284))+(((-1.0)*x348))))))+(((3.61052070247095e-14)*x298)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x353=pz*pz;
IkReal x354=(pz*sj0);
IkReal x355=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+sj0+(((-16.6666666666667)*x354))+(((909090.909090909)*pz))+(((-7575757.57575758)*x353))+(((2272727.27272727)*x355)));
j1eval[1]=IKsign(((-522.0000000242)+(((2400.0)*pz))+(((6000.0)*x355))+(((-0.044)*x354))+(((0.00264)*sj0))+(((-360.0)*cj0))+(((-20000.0)*x353))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x356=((1.0)+(((-16.6666666666667)*pz)));
IkReal x357=pz*pz;
IkReal x358=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x359=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x357)));
IkReal x360=((x356*x356)+(x358*x358));
if((((18595041323.314)+(((5165289256476.13)*x357))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x361=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x357))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x368=IKPowWithIntegerCheck(x361,-1);
if(!x368.valid){
continue;
}
IkReal x362=x368.value;
IkReal x369 = x360;
if(IKabs(x369)==0){
continue;
}
IkReal x363=pow(x369,-0.5);
IkReal x364=(x356*x363);
IkReal x365=((1.0)*x358*x363);
IkReal x366=(x359*x362);
if((((1.0)+(((-1.0)*(x366*x366))))) < -0.00001)
continue;
IkReal x367=IKsqrt(((1.0)+(((-1.0)*(x366*x366)))));
if((x360) < -0.00001)
continue;
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKabs(IKsqrt(x360)),-1);
if(!x370.valid){
continue;
}
if( ((x359*(x370.value))) < -1-IKFAST_SINCOS_THRESH || ((x359*(x370.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x371 = IKatan2WithCheck(IkReal(x358),IkReal(x356),IKFAST_ATAN2_MAGTHRESH);
if(!x371.valid){
continue;
}
IkReal gconst34=((((-1.0)*(IKasin((x359*(x370.value))))))+(((-1.0)*(x371.value))));
IkReal gconst35=((((-1.0)*x364*x366))+(((-1.0)*x365*x367)));
IkReal gconst36=(((x364*x367))+(((-1.0)*x365*x366)));
IkReal x372=pz*pz;
if((((18595041323.314)+(((5165289256476.13)*x372))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x374=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x372))+(((-619834710777.135)*pz))))),-1);
if(!x374.valid){
continue;
}
IkReal x373=x374.value;
CheckValue<IkReal> x375 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x375.valid){
continue;
}
CheckValue<IkReal> x376 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x376.valid){
continue;
}
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x377 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x377.valid){
continue;
}
CheckValue<IkReal> x378 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x378.valid){
continue;
}
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x379 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x379.valid){
continue;
}
if( (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) < -1-IKFAST_SINCOS_THRESH || (((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x380 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x380.valid){
continue;
}
if((((((x375.value)*(x376.value)))+((j0*(j0)))+(((1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(x377.value)))+((j0*(x378.value)))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(j0)))+(((-1.0)*j0*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(x379.value)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((x380.value)*(j0))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((((x375.value)*(x376.value)))+((j0*(j0)))+(((1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(x377.value)))+((j0*(x378.value)))+(((-1.0)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))*(j0)))+(((-1.0)*j0*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((-1.0)*(x379.value)*(IKasin(((((7575757.57575758)*x372*x373))+(((197727.272736439)*x373))+(((-909090.909090909)*pz*x373)))))))+(((x380.value)*(j0))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x381=gconst35*gconst35;
IkReal x382=gconst36*gconst36;
IkReal x383=pz*pz;
IkReal x384=(gconst36*pz);
IkReal x385=((590.86479112738)*py);
IkReal x386=(gconst35*pz);
IkReal x387=((99.4633802333595)*sj2);
IkReal x388=((2400.0)*pz);
IkReal x389=((1657.72300388932)*sj2);
IkReal x390=((35.4518874676428)*py);
IkReal x391=((20000.0)*x383);
CheckValue<IkReal> x392=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((6000.0)*x384))+(((0.00264)*gconst35))+(((-1.0)*x382*x391))+(((-0.044)*x386))+(((-360.0)*gconst36))+((x382*x388))+(((-1.0)*x381*x391))+(((-72.0)*x382))+(((-72.0)*x381))+((x381*x388)))),-1);
if(!x392.valid){
continue;
}
CheckValue<IkReal> x393 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((4223.0)*x386))+((x384*x385))+((x384*x389))+(((-253.38)*gconst35))+(((0.57766479112738)*x384))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst36))+(((-1.0)*gconst36*x387))+(((-1.0)*gconst36*x390)))),IkReal(((633.450000635431)+(((-1.0)*gconst35*x390))+(((253.38)*gconst36))+(((0.57766479112738)*x386))+((x386*x389))+(((-0.0346598874676428)*gconst35))+(((-4223.0)*x384))+(((-1.0)*gconst35*x387))+(((0.00182349530427826)*sj2))+((x385*x386))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x393.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x392.value)))+(x393.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x394=IKcos(j1);
IkReal x395=IKsin(j1);
IkReal x396=((0.12)*pz);
IkReal x397=pz*pz;
IkReal x398=gconst36*gconst36;
IkReal x399=((1.32e-7)*gconst35);
IkReal x400=((0.3)*pz);
IkReal x401=(gconst35*pz);
IkReal x402=(gconst35*gconst36);
IkReal x403=(gconst36*pz);
IkReal x404=((0.018)*gconst36);
IkReal x405=x394*x394;
IkReal x406=((1.0)*x397);
IkReal x407=((2.2e-6)*x401);
IkReal x408=((0.06)*x394);
IkReal x409=(gconst35*x395);
IkReal x410=(gconst36*x395);
IkReal x411=(x396+x399);
IkReal x412=(x394*x395);
IkReal x413=(x397*x405);
IkReal x414=(x398*x405);
IkReal x415=(x407+x406);
evalcond[0]=((-0.21115)+(((-0.15)*x394))+(((0.06)*x409))+(((-1.1e-6)*x395))+(((-1.0)*x395*x401))+(((-1.0)*gconst36*x408))+((x394*x403)));
evalcond[1]=((-2.8883239556369e-5)+(((0.15)*x395))+(((0.06)*x410))+(((-0.029543239556369)*py))+(((-1.1e-6)*x394))+(((-1.0)*x395*x403))+(((-0.0828861501944662)*sj2))+(((-1.0)*x394*x401))+((gconst35*x408)));
evalcond[2]=((0.0253474453653594)+(((1.32e-6)*x394*x401))+(((1.32e-6)*x395*x403))+(((-7.92e-8)*gconst35*x394))+x411+((gconst36*x400))+(((-1.98e-7)*x395))+(((1.452e-12)*x394))+(((-7.92e-8)*x410))+(((-1.0)*(py*py)))+(((-1.0)*x415))+(((-1.0)*x404))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-2.0)*x398*x413))+((x405*x407))+(((-0.0072)*x414))+(((0.018)*x394*x409))+(((0.24)*pz*x414))+x413+x411+(((-1.0)*x404*x405))+(((2.0)*x397*x402*x412))+(((-1.0)*x399*x405))+((gconst36*x400*x405))+(((-3.3e-7)*x412))+((x397*x398))+(((0.0072)*x402*x412))+(((-1.0)*x396*x398))+(((0.0036)*x398))+(((2.2e-6)*x403*x412))+(((-1.0)*x396*x405))+(((-0.24)*x394*x401*x410))+(((-1.0)*x415))+(((-1.0)*x394*x400*x409))+(((-0.01889999999879)*x405))+(((-1.32e-7)*x394*x410)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x416=(cj1*gconst35);
IkReal x417=((0.999563891228661)*cj2);
IkReal x418=((0.0295301092415339)*sj2);
IkReal x419=(gconst36*sj1);
IkReal x420=(((cj1*gconst36))+(((-1.0)*gconst35*sj1)));
IkReal x421=(((x416*x418))+((x416*x417))+((x417*x419))+((x418*x419)));
CheckValue<IkReal> x424 = IKatan2WithCheck(IkReal(x420),IkReal(x421),IKFAST_ATAN2_MAGTHRESH);
if(!x424.valid){
continue;
}
IkReal x422=((1.0)*(x424.value));
if((((x420*x420)+(x421*x421))) < -0.00001)
continue;
CheckValue<IkReal> x425=IKPowWithIntegerCheck(IKabs(IKsqrt(((x420*x420)+(x421*x421)))),-1);
if(!x425.valid){
continue;
}
if( (((x425.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x425.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x423=IKasin(((x425.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x422))+x423);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x423))+(((-1.0)*x422)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x426=((1.0)+(((-16.6666666666667)*pz)));
IkReal x427=pz*pz;
IkReal x428=((-136363.636363636)+(((2272727.27272727)*pz)));
IkReal x429=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x427)));
IkReal x430=((x426*x426)+(x428*x428));
if((((18595041323.314)+(((5165289256476.13)*x427))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x431=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x427))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x438=IKPowWithIntegerCheck(x431,-1);
if(!x438.valid){
continue;
}
IkReal x432=x438.value;
IkReal x439 = x430;
if(IKabs(x439)==0){
continue;
}
IkReal x433=pow(x439,-0.5);
IkReal x434=((1.0)*x428*x433);
IkReal x435=((1.0)*x426*x433);
IkReal x436=(x429*x432);
if((((1.0)+(((-1.0)*(x436*x436))))) < -0.00001)
continue;
IkReal x437=IKsqrt(((1.0)+(((-1.0)*(x436*x436)))));
CheckValue<IkReal> x440 = IKatan2WithCheck(IkReal(x428),IkReal(x426),IKFAST_ATAN2_MAGTHRESH);
if(!x440.valid){
continue;
}
if((x430) < -0.00001)
continue;
CheckValue<IkReal> x441=IKPowWithIntegerCheck(IKabs(IKsqrt(x430)),-1);
if(!x441.valid){
continue;
}
if( ((x429*(x441.value))) < -1-IKFAST_SINCOS_THRESH || ((x429*(x441.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst37=((3.14159265358979)+(((-1.0)*(x440.value)))+(IKasin((x429*(x441.value)))));
IkReal gconst38=((((-1.0)*x435*x436))+((x434*x437)));
IkReal gconst39=((((-1.0)*x435*x437))+(((-1.0)*x434*x436)));
IkReal x442=((1.0)+(((-16.6666666666667)*pz)));
IkReal x443=((-136363.636363636)+(((2272727.27272727)*pz)));
CheckValue<IkReal> x444 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x444.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x445=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x445.valid){
continue;
}
if( (((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x446 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x446.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x447=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x447.valid){
continue;
}
if( (((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x448 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x448.valid){
continue;
}
CheckValue<IkReal> x449 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x449.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x450=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x450.valid){
continue;
}
if( (((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x451 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x451.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x452=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x452.valid){
continue;
}
if( (((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x453 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x453.valid){
continue;
}
CheckValue<IkReal> x454 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x454.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x455=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x455.valid){
continue;
}
if( (((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x456.valid){
continue;
}
if( (((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x457 = IKatan2WithCheck(IkReal(x443),IkReal(x442),IKFAST_ATAN2_MAGTHRESH);
if(!x457.valid){
continue;
}
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x458=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x458.valid){
continue;
}
if( (((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x442*x442)+(x443*x443))) < -0.00001)
continue;
CheckValue<IkReal> x459=IKPowWithIntegerCheck(IKabs(IKsqrt(((x442*x442)+(x443*x443)))),-1);
if(!x459.valid){
continue;
}
if( (((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((9.86960440108936)+((j0*(j0)))+(((-3.14159265358979)*(x444.value)))+(((-1.0)*(IKasin(((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x446.value)))+(((3.14159265358979)*(IKasin(((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+((j0*(x448.value)))+(((-3.14159265358979)*(j0)))+(((-3.14159265358979)*(x449.value)))+(((-1.0)*(IKasin(((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((-1.0)*(x451.value)*(IKasin(((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x453.value)*(x454.value)))+(((-3.14159265358979)*j0))+(((-1.0)*j0*(IKasin(((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x457.value)*(j0)))+(((1.0)*(IKasin(((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz))))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((j0*(j0)))+(((-3.14159265358979)*(x444.value)))+(((-1.0)*(IKasin(((x445.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(x446.value)))+(((3.14159265358979)*(IKasin(((x447.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+((j0*(x448.value)))+(((-3.14159265358979)*(j0)))+(((-3.14159265358979)*(x449.value)))+(((-1.0)*(IKasin(((x450.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(j0)))+(((-1.0)*(x451.value)*(IKasin(((x452.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x453.value)*(x454.value)))+(((-3.14159265358979)*j0))+(((-1.0)*j0*(IKasin(((x455.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x456.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))))+(((x457.value)*(j0)))+(((1.0)*(IKasin(((x458.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz)))))))*(IKasin(((x459.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((909090.909090909)*pz))))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x460=gconst38*gconst38;
IkReal x461=gconst39*gconst39;
IkReal x462=pz*pz;
IkReal x463=(gconst38*pz);
IkReal x464=((99.4633802333595)*sj2);
IkReal x465=(gconst39*pz);
IkReal x466=((35.4518874676428)*py);
IkReal x467=((2400.0)*pz);
IkReal x468=((590.86479112738)*py);
IkReal x469=((1657.72300388932)*sj2);
IkReal x470=((20000.0)*x462);
CheckValue<IkReal> x471 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst38))+((x465*x468))+((x465*x469))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst39))+(((4223.0)*x463))+(((0.57766479112738)*x465))+(((-1.0)*gconst39*x464))+(((-1.0)*gconst39*x466)))),IkReal(((633.450000635431)+(((-4223.0)*x465))+(((253.38)*gconst39))+((x463*x468))+((x463*x469))+(((-0.0346598874676428)*gconst38))+(((0.00182349530427826)*sj2))+(((0.57766479112738)*x463))+(((-1.0)*gconst38*x466))+(((-1.0)*gconst38*x464))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x471.valid){
continue;
}
CheckValue<IkReal> x472=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x461*x467))+(((-1.0)*x460*x470))+(((0.00264)*gconst38))+(((6000.0)*x465))+(((-0.044)*x463))+(((-72.0)*x461))+(((-72.0)*x460))+(((-360.0)*gconst39))+((x460*x467))+(((-1.0)*x461*x470)))),-1);
if(!x472.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x471.value)+(((1.5707963267949)*(x472.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x473=IKsin(j1);
IkReal x474=IKcos(j1);
IkReal x475=((0.12)*pz);
IkReal x476=pz*pz;
IkReal x477=gconst39*gconst39;
IkReal x478=((1.32e-7)*gconst38);
IkReal x479=((0.3)*pz);
IkReal x480=((0.018)*gconst39);
IkReal x481=(gconst38*pz);
IkReal x482=((1.0)*pz);
IkReal x483=((1.32e-6)*pz);
IkReal x484=(gconst38*gconst39);
IkReal x485=x474*x474;
IkReal x486=((2.2e-6)*x481);
IkReal x487=((1.0)*x476);
IkReal x488=(gconst38*x474);
IkReal x489=(gconst39*x474);
IkReal x490=((2.0)*x476);
IkReal x491=((0.06)*x473);
IkReal x492=(gconst39*x473);
IkReal x493=(x475+x478);
IkReal x494=(x473*x474);
IkReal x495=(x477*x485);
IkReal x496=(x487+x486);
evalcond[0]=((-0.21115)+((pz*x489))+(((-0.15)*x474))+(((-0.06)*x489))+(((-1.1e-6)*x473))+((gconst38*x491))+(((-1.0)*x473*x481)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x482*x492))+(((0.06)*x488))+(((-1.0)*x474*x481))+(((-0.029543239556369)*py))+(((0.15)*x473))+((gconst39*x491))+(((-0.0828861501944662)*sj2))+(((-1.1e-6)*x474)));
evalcond[2]=((0.0253474453653594)+(((-1.0)*x496))+(((-1.0)*x480))+(((1.452e-12)*x474))+(((1.32e-6)*x474*x481))+((x483*x492))+x493+(((-7.92e-8)*x492))+((gconst39*x479))+(((-1.0)*(py*py)))+(((-7.92e-8)*x488))+(((-1.98e-7)*x473))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+((x485*x486))+(((-0.0072)*x495))+(((0.24)*pz*x495))+(((-0.01889999999879)*x485))+(((-1.0)*x496))+(((-1.0)*x475*x485))+(((0.018)*x473*x488))+((x476*x485))+(((-1.32e-7)*x473*x489))+(((-0.24)*x473*x481*x489))+(((-1.0)*x475*x477))+((gconst39*x479*x485))+(((0.0072)*x484*x494))+(((2.2e-6)*pz*x473*x489))+((x484*x490*x494))+(((0.0036)*x477))+(((-1.0)*x490*x495))+(((-3.3e-7)*x494))+(((-1.0)*x473*x479*x488))+x493+(((-1.0)*x480*x485))+((x476*x477))+(((-1.0)*x478*x485)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x497=((0.999563891228661)*cj2);
IkReal x498=(gconst39*sj1);
IkReal x499=(cj1*gconst38);
IkReal x500=((0.0295301092415339)*sj2);
IkReal x501=((((-1.0)*gconst38*sj1))+((cj1*gconst39)));
IkReal x502=(((x497*x499))+((x497*x498))+((x498*x500))+((x499*x500)));
CheckValue<IkReal> x505 = IKatan2WithCheck(IkReal(x501),IkReal(x502),IKFAST_ATAN2_MAGTHRESH);
if(!x505.valid){
continue;
}
IkReal x503=((1.0)*(x505.value));
if((((x501*x501)+(x502*x502))) < -0.00001)
continue;
CheckValue<IkReal> x506=IKPowWithIntegerCheck(IKabs(IKsqrt(((x501*x501)+(x502*x502)))),-1);
if(!x506.valid){
continue;
}
if( (((x506.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x506.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x504=IKasin(((x506.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x503))+x504);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x503))+(((-1.0)*x504)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x507=(pz*sj0);
IkReal x508=((590.86479112738)*py);
IkReal x509=((99.4633802333595)*sj2);
IkReal x510=(cj0*pz);
IkReal x511=((1657.72300388932)*sj2);
IkReal x512=((35.4518874676428)*py);
CheckValue<IkReal> x513 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+((x510*x511))+(((-253.38)*sj0))+(((-1.0)*cj0*x509))+(((4223.0)*x507))+(((-248.658450583399)*sj2))+(((0.57766479112738)*x510))+((x508*x510))+(((-1.0)*cj0*x512))+(((-0.0346598874676428)*cj0)))),IkReal(((633.450000635431)+(((0.57766479112738)*x507))+((x507*x511))+(((-1.0)*sj0*x509))+(((253.38)*cj0))+(((-0.0346598874676428)*sj0))+((x507*x508))+(((-4223.0)*x510))+(((0.00182349530427826)*sj2))+(((-1.0)*sj0*x512))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x513.valid){
continue;
}
CheckValue<IkReal> x514=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((-0.044)*x507))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-360.0)*cj0))+(((6000.0)*x510)))),-1);
if(!x514.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x513.value)+(((1.5707963267949)*(x514.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x515=IKcos(j1);
IkReal x516=IKsin(j1);
IkReal x517=((0.12)*pz);
IkReal x518=cj0*cj0;
IkReal x519=pz*pz;
IkReal x520=((1.32e-7)*sj0);
IkReal x521=((2.2e-6)*pz);
IkReal x522=((0.06)*sj0);
IkReal x523=((0.3)*pz);
IkReal x524=((1.0)*pz);
IkReal x525=x515*x515;
IkReal x526=(sj0*x521);
IkReal x527=((1.0)*x519);
IkReal x528=(cj0*x516);
IkReal x529=(cj0*x515);
IkReal x530=(sj0*x515);
IkReal x531=((2.0)*x519);
IkReal x532=(x520+x517);
IkReal x533=(x515*x516);
IkReal x534=(sj0*x525);
IkReal x535=(cj0*x525);
IkReal x536=(pz*x530);
IkReal x537=(x518*x525);
IkReal x538=(x526+x527);
evalcond[0]=((-0.21115)+((pz*x529))+(((-0.15)*x515))+((x516*x522))+(((-1.0)*sj0*x516*x524))+(((-0.06)*x529))+(((-1.1e-6)*x516)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x524*x528))+(((-1.0)*x524*x530))+(((0.06)*x528))+((x515*x522))+(((-0.029543239556369)*py))+(((-0.0828861501944662)*sj2))+(((-1.1e-6)*x515))+(((0.15)*x516)));
evalcond[2]=((0.0253474453653594)+(((-1.98e-7)*x516))+((cj0*x523))+(((1.452e-12)*x515))+(((1.32e-6)*pz*x528))+(((-1.0)*x538))+x532+(((-7.92e-8)*x528))+(((-7.92e-8)*x530))+(((-1.0)*(py*py)))+(((1.32e-6)*x536))+(((-0.018)*cj0))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+((x519*x525))+((x515*x521*x528))+(((-1.0)*x520*x525))+(((-0.24)*x528*x536))+(((0.018)*x516*x530))+(((0.0036)*x518))+(((-1.0)*x531*x537))+(((-1.0)*x538))+(((-0.01889999999879)*x525))+(((-3.3e-7)*x533))+(((-1.32e-7)*x515*x528))+(((-0.018)*x535))+(((-1.0)*x517*x518))+((x525*x526))+(((-1.0)*x517*x525))+((x528*x530*x531))+((x518*x519))+(((-1.0)*x516*x523*x530))+x532+(((-0.0072)*x537))+((x523*x535))+(((0.0072)*x528*x530))+(((0.24)*pz*x537)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
px=0;
pp=((py*py)+(pz*pz));
IkReal x539=cj2*cj2;
IkReal x540=cj1*cj1;
IkReal x541=cj0*cj0;
IkReal x542=sj1*sj1;
IkReal x543=sj0*sj0;
IkReal x544=sj2*sj2;
IkReal x545=(cj0*cj1);
IkReal x546=(sj0*sj1);
IkReal x547=((67.6979474104201)*cj2*sj2);
IkReal x548=((1145.753020896)*x539);
IkReal x549=(x541*x542);
IkReal x550=(x540*x543);
j3eval[0]=(((x548*x550))+(((135.39589482084)*cj2*sj2*x545*x546))+((x544*x549))+((x547*x549))+((x544*x550))+(((2291.50604179201)*x539*x545*x546))+(((2.0)*x544*x545*x546))+((x547*x550))+(((1146.753020896)*x542*x543))+(((1146.753020896)*x540*x541))+(((-2293.50604179201)*x545*x546))+((x548*x549)));
j3eval[1]=((((-1.0)*x546))+x545);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x551=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x551.valid){
continue;
}
sj3array[0]=((x551.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=0;
sj0=0;
cj0=1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x552=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x552.valid){
continue;
}
sj3array[0]=((x552.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x553=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x553.valid){
continue;
}
sj3array[0]=((x553.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x554=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x554.valid){
continue;
}
sj3array[0]=((x554.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x555=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x555.valid){
continue;
}
sj3array[0]=((x555.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x556=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x556.valid){
continue;
}
sj3array[0]=((x556.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x557=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x557.valid){
continue;
}
sj3array[0]=((x557.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
px=0;
pp=((py*py)+(pz*pz));
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x558=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x558.valid){
continue;
}
sj3array[0]=((x558.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x559=(cj1*sj0);
IkReal x560=((0.0295301092415339)*sj2);
IkReal x561=((0.999563891228661)*cj2);
IkReal x562=(cj0*sj1);
IkReal x563=(((cj0*cj1))+(((-1.0)*sj0*sj1)));
IkReal x564=(((x561*x562))+((x560*x562))+((x559*x561))+((x559*x560)));
CheckValue<IkReal> x567 = IKatan2WithCheck(IkReal(x563),IkReal(x564),IKFAST_ATAN2_MAGTHRESH);
if(!x567.valid){
continue;
}
IkReal x565=((1.0)*(x567.value));
if((((x564*x564)+(x563*x563))) < -0.00001)
continue;
CheckValue<IkReal> x568=IKPowWithIntegerCheck(IKabs(IKsqrt(((x564*x564)+(x563*x563)))),-1);
if(!x568.valid){
continue;
}
if( (((x568.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x568.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x566=IKasin(((x568.value)*(IKcos(r00))));
j3array[0]=(x566+(((-1.0)*x565)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x566))+(((-1.0)*x565)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x569=pz*pz;
IkReal x570=py*py;
IkReal x571=px*px;
IkReal x572=((1.0)*pz);
IkReal x573=(px*pz);
IkReal x574=((0.00108)+(((-2.2e-6)*x573))+(((1.32e-7)*px))+(((-0.036)*pz))+(((0.3)*x569)));
IkReal x575=((-7.92e-9)+(((0.018)*px))+(((2.64e-7)*pz))+(((-2.2e-6)*x569))+(((-0.3)*x573)));
CheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(x574),IkReal(x575),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
IkReal x576=((1.0)*(x578.value));
if((((x574*x574)+(x575*x575))) < -0.00001)
continue;
CheckValue<IkReal> x579=IKPowWithIntegerCheck(IKabs(IKsqrt(((x574*x574)+(x575*x575)))),-1);
if(!x579.valid){
continue;
}
if( (((x579.value)*(((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((6.558858504e-9)*sj2))+(((-1.0)*x572*(pz*pz)))+(((-1.0)*x570*x572))+(((-1.0)*x571*x572))+(((0.06)*x571))+(((0.06)*x570))+(((-1.93769928e-10)*cj2))+(((0.18)*x569))+(((0.00012)*py))+(((-1.093143084e-7)*pz*sj2))+(((3.2294988e-9)*cj2*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x579.value)*(((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((6.558858504e-9)*sj2))+(((-1.0)*x572*(pz*pz)))+(((-1.0)*x570*x572))+(((-1.0)*x571*x572))+(((0.06)*x571))+(((0.06)*x570))+(((-1.93769928e-10)*cj2))+(((0.18)*x569))+(((0.00012)*py))+(((-1.093143084e-7)*pz*sj2))+(((3.2294988e-9)*cj2*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x577=IKasin(((x579.value)*(((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((6.558858504e-9)*sj2))+(((-1.0)*x572*(pz*pz)))+(((-1.0)*x570*x572))+(((-1.0)*x571*x572))+(((0.06)*x571))+(((0.06)*x570))+(((-1.93769928e-10)*cj2))+(((0.18)*x569))+(((0.00012)*py))+(((-1.093143084e-7)*pz*sj2))+(((3.2294988e-9)*cj2*pz))))));
j0array[0]=((((-1.0)*x577))+(((-1.0)*x576)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x576))+x577);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x580=px*px;
IkReal x581=(px*pz);
evalcond[0]=((((0.002)*px*py))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-0.12)*x581))+(((((((0.018)*px))+(((2.2e-6)*x580))+(((-0.3)*x581))))*(IKcos(j0))))+(((((((2.2e-6)*x581))+(((0.3)*x580))+(((-1.32e-7)*px))))*(IKsin(j0))))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x581)));
IkReal x582=IKcos(j0);
IkReal x583=IKsin(j0);
IkReal x584=IKcos(j0);
IkReal x585=IKsin(j0);
IkReal x586=IKcos(j0);
evalcond[1]=((2.87440030434653e-5)+(((-0.06)*(px*px)*(py*py)))+(((0.01169999999879)*pz*(py*py)))+(((-5.81309784e-10)*cj2*(pz*pz)))+(((-0.06)*(px*px*px*px)))+(((((((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.000282996786761127)*px))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((0.0111612262253709)*px*pz))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-0.150610218544758)*px*(pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))))*(IKcos(j0))*(IKsin(j0))))+(((((6.96324099683585e-6)+(((7.92e-7)*px*(pz*pz)))+(((-0.0006)*py*(pz*pz)))+(((-1.18059453072e-10)*sj2))+(((0.00193423361023218)*(pz*pz)))+(((-0.00216)*(px*px)))+(((-1.162619568e-10)*cj2*pz))+(((-3.279429252e-8)*sj2*(pz*pz)))+(((3.487858704e-12)*cj2))+(((-0.3)*(py*py)*(pz*pz)))+(((-0.00108)*(py*py)))+(((-5.84066278818272e-9)*px))+(((-2.16e-6)*py))+(((0.036)*pz*(py*py)))+(((-0.6)*(px*px)*(pz*pz)))+(((1.44294887088e-14)*px*sj2))+(((7.2e-5)*py*pz))+(((-2.2e-6)*px*pz*(py*py)))+(((0.072)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((6.56643798030453e-8)*px*pz))+(((3.9353151024e-9)*pz*sj2))+(((2.64e-10)*px*py))+(((-0.000232108033227862)*pz))+(((-2.4049147848e-13)*px*pz*sj2))+(((1.32e-7)*px*(py*py)))+(((-4.262938416e-16)*cj2*px))+(((9.6884964e-10)*cj2*(pz*pz)))+(((7.10489736e-15)*cj2*px*pz))+(((-4.4e-9)*px*py*pz))))*(IKcos(j0))))+(((-1.23962425717664e-10)*sj2))+(((-0.0064474453674406)*pz*(px*px)))+(((0.00036)*py*(pz*pz)))+(((-3.2294988e-9)*cj2*pz*(px*px)))+(((0.3)*(pz*pz*pz*pz)))+(((-1.0)*(py*py)*(pz*pz*pz)))+((pz*(px*px*px*px)))+(((x582*x582)*(((-8.48990360178838e-6)+(((-2.186286168e-7)*pz*sj2*(px*px)))+(((-0.36)*(py*py)*(pz*pz)))+(((0.00024)*py*(px*px)))+(((2.0)*(py*py)*(pz*pz*pz)))+(((0.104105109267539)*(pz*pz*pz)))+(((0.0578948907276212)*pz*(px*px)))+(((-3.87539856e-10)*cj2*(px*px)))+(((-3.9353151024e-8)*sj2*(pz*pz)))+(((-8.64e-7)*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((0.0216)*pz*(py*py)))+(((1.162619568e-9)*cj2*(pz*pz)))+(((1.3117717008e-8)*sj2*(px*px)))+(((2.186286168e-7)*sj2*(pz*pz*pz)))+(((-0.00072)*py*(pz*pz)))+(((-2.0)*pz*(px*px*px*px)))+(((4.32e-5)*py*pz))+(((-0.00347369344365727)*(px*px)))+(((-6.4589976e-9)*cj2*(pz*pz*pz)))+(((1.3951434816e-12)*cj2))+(((-0.010098919668157)*(pz*pz)))+(((0.004)*py*(pz*pz*pz)))+(((2.0)*(pz*pz*pz*pz*pz)))+(((0.12)*(px*px)*(py*py)))+(((-2.0)*pz*(px*px)*(py*py)))+(((-6.975717408e-11)*cj2*pz))+(((0.000476335180089419)*pz))+(((-0.000432)*(py*py)))+(((0.12)*(px*px*px*px)))+(((-4.72237812288e-11)*sj2))+(((-0.004)*py*pz*(px*px)))+(((-0.6)*(pz*pz*pz*pz)))+(((2.36118906144e-9)*pz*sj2))))))+(((-0.002)*py*(pz*pz*pz)))+(((-0.0011339999999274)*(py*py)))+(((x583*x583)*(((1.04544e-15)+(((-4.84e-12)*(pz*pz*pz)))+(((-0.0054)*(px*px)))+(((0.09)*pz*(px*px)))+(((8.712e-13)*(pz*pz)))+(((-5.2272e-14)*pz))))))+(((3.2294988e-9)*cj2*(pz*pz*pz)))+(((1.93769928e-10)*cj2*(px*px)))+(((-0.00012)*py*(px*px)))+(((-2.2679999998548e-6)*py))+(((-1.093143084e-7)*sj2*(pz*pz*pz)))+((pz*(px*px)*(py*py)))+(((((3.50439767290963e-10)+(((3.279429252e-8)*px*pz*sj2))+(((1.81443798030453e-8)*(pz*pz)))+(((-4.4e-6)*(pz*pz*pz*pz)))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-9.78052557636544e-9)*pz))+(((-4.4e-9)*py*(pz*pz)))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((0.0006)*px*py*pz))+(((1.056e-6)*(pz*pz*pz)))+(((-7.92e-9)*(py*py)))))*(IKsin(j0))))+(((2.339999999758e-5)*py*pz))+(((3.66225163896554e-12)*cj2))+(((x584*x584)*(((5.7024e-11)+(((4.4e-6)*(pz*pz*pz*pz)))+(((-4.752e-8)*(px*px)))+(((-0.324)*px*(pz*pz)))+(((9.504e-8)*(pz*pz)))+(((0.036)*(px*px*px)))+(((1.8)*px*(pz*pz*pz)))+(((-3.8016e-9)*pz))+(((-1.056e-6)*(pz*pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.01944)*px*pz))+(((-0.0003888)*px))+(((-1.32e-5)*(px*px)*(pz*pz)))+(((1.584e-6)*pz*(px*px)))))*(IKsin(j0))))+(((0.000386846722046436)*(px*px)))+(((1.27897740814773e-9)*pz*sj2))+(((x585*x585)*(((((-8.8e-6)*px*(pz*pz*pz)))+(((-0.00432)*(px*px)))+(((1.584e-6)*px*(pz*pz)))+(((-9.504e-8)*px*pz))+(((-1.2)*(px*px)*(pz*pz)))+(((1.9008e-9)*px))+(((0.144)*pz*(px*px)))))*(IKcos(j0))))+(((-1.0)*(pz*pz*pz*pz*pz)))+(((-0.00016048511076294)*pz))+(((0.002)*py*pz*(px*px)))+(((-3.77851359560923e-11)*cj2*pz))+(((-6.558858504e-9)*sj2*(px*px)))+(((-0.00710054016570371)*(pz*pz)))+(((0.0154474453650206)*(pz*pz*pz)))+(((1.9676575512e-8)*sj2*(pz*pz)))+(((1.093143084e-7)*pz*sj2*(px*px)))+(((x586*x586*x586)*(((-7.776e-6)+(((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((0.144)*(pz*pz*pz)))+(((-9.504e-10)*px))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.01296)*(pz*pz)))+(((0.0005184)*pz))+(((-0.6)*(pz*pz*pz*pz)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))))+(((0.18)*(py*py)*(pz*pz))));
IkReal x587=IKsin(j0);
IkReal x588=IKcos(j0);
IkReal x589=IKsin(j0);
IkReal x590=IKcos(j0);
IkReal x591=IKcos(j0);
evalcond[2]=((((((((-2.64e-10)*px*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-0.0006)*py*(px*px)))+(((-0.6)*(px*px*px*px)))+(((-0.3)*(px*px)*(py*py)))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((-6.56643798030453e-8)*px*pz))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((9.6884964e-10)*cj2*(px*px)))+(((5.84066278818272e-9)*px))+(((4.4e-6)*px*(pz*pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.00193423361023218)*(px*px)))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKsin(j0))))+(((-1.0)*(px*px*px)*(py*py)))+(((-0.24)*px*(pz*pz*pz)))+(((3.2294988e-9)*cj2*(px*px*px)))+(((x587*x587)*(((((-5.808e-13)*px*pz))+(((-0.09)*(px*px*px)))+(((4.84e-12)*px*(pz*pz)))+(((1.7424e-14)*px))))))+(((0.000479066717391088)*px))+(((0.0064474453674406)*(px*px*px)))+(((0.002)*px*py*(pz*pz)))+(((-0.01889999999879)*px*(py*py)))+(((6.10375273160923e-11)*cj2*px))+(((-0.00024)*px*py*pz))+(((0.00530969344380247)*px*pz))+((px*(pz*pz*pz*pz)))+(((x588*x588*x588)*(((((4.4e-6)*(px*px*px*px)))+(((0.00648)*px*pz))+(((-0.0001296)*px))+(((0.036)*(px*px*px)))+(((5.28e-7)*pz*(px*px)))+(((-1.584e-8)*(px*px)))+(((-4.4e-6)*(px*px)*(pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.6)*px*(pz*pz*pz)))+(((-0.108)*px*(pz*pz)))))))+(((-1.0)*(px*px*px*px*px)))+(((-1.3117717008e-8)*px*pz*sj2))+(((-3.779999999758e-5)*px*py))+(((x589*x589)*(((((-0.072)*(px*px*px)))+(((3.168e-8)*(px*px)))+(((8.8e-6)*(px*px)*(pz*pz)))+(((1.2)*pz*(px*px*px)))+(((-1.056e-6)*pz*(px*px)))))*(IKcos(j0))))+(((x590*x590)*(((((-0.0578948907276212)*(px*px*px)))+(((-7.75079712e-10)*cj2*px*pz))+(((2.0)*(px*px*px)*(py*py)))+(((-7.8706302048e-10)*px*sj2))+(((0.004)*py*(px*px*px)))+(((0.24)*px*pz*(py*py)))+(((-2.186286168e-7)*px*sj2*(pz*pz)))+(((-2.0)*px*(pz*pz*pz*pz)))+(((-1.44e-5)*px*py))+(((6.4589976e-9)*cj2*px*(pz*pz)))+(((-0.00014149839336314)*px))+(((-0.004)*px*py*(pz*pz)))+(((0.00048)*px*py*pz))+(((-0.0072)*px*(py*py)))+(((2.325239136e-11)*cj2*px))+(((2.186286168e-7)*sj2*(px*px*px)))+(((0.00558061311210466)*px*pz))+(((2.6235434016e-8)*px*pz*sj2))+(((-6.4589976e-9)*cj2*(px*px*px)))+(((2.0)*(px*px*px*px*px)))+(((-0.0753051092675388)*px*(pz*pz)))+(((0.48)*px*(pz*pz*pz)))+(((-2.0)*px*(py*py)*(pz*pz)))))))+(((-1.093143084e-7)*sj2*(px*px*px)))+(((1.093143084e-7)*px*sj2*(pz*pz)))+(((x591*x591)*(((((7.92e-7)*px*(pz*pz)))+(((9.504e-10)*px))+(((1.32e-5)*pz*(px*px*px)))+(((-7.92e-7)*(px*px*px)))+(((0.216)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-4.752e-8)*px*pz))+(((-1.8)*(px*px)*(pz*pz)))+(((0.6)*(px*px*px*px)))))*(IKsin(j0))))+(((-0.12)*px*pz*(py*py)))+(((-0.0298474453650206)*px*(pz*pz)))+(((-0.002)*py*(px*px*px)))+(((((((-0.24)*(px*px*px*px)))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((0.107410218544758)*pz*(px*px)))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((-0.00471661311268546)*(px*px)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.008)*py*pz*(px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.06604042862773e-9)*px*sj2))+((px*(py*py)*(pz*pz)))+(((((((3.279429252e-8)*px*pz*sj2))+(((-9.73443798030453e-8)*(px*px)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((2.2e-6)*(px*px)*(py*py)))+(((2.4049147848e-13)*sj2*(px*px)))+(((-0.018)*px*(py*py)))+(((4.4e-6)*(px*px)*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((-5.28e-7)*pz*(px*px)))+(((4.4e-9)*py*(px*px)))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((-1.9676575512e-9)*px*sj2))+(((-7.10489736e-15)*cj2*(px*px)))+(((0.0006)*px*py*pz))))*(IKcos(j0))))+(((-3.2294988e-9)*cj2*px*(pz*pz)))+(((3.87539856e-10)*cj2*px*pz)));
IkReal x592=IKcos(j0);
IkReal x593=IKsin(j0);
IkReal x594=IKsin(j0);
IkReal x595=IKcos(j0);
IkReal x596=IKcos(j0);
evalcond[3]=((5.01879418251366e-10)+(((0.0072)*(px*px*px)))+(((x592*x592)*(((7.776e-6)+(((-0.0005184)*pz))+(((2.8512e-9)*px))+(((-0.144)*(pz*pz*pz)))+(((-2.64e-7)*(px*px*px)))+(((4.4e-6)*pz*(px*px*px)))+(((0.216)*pz*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((0.01296)*(pz*pz)))+(((-1.32e-5)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-1.8)*(px*px)*(pz*pz)))+(((-1.4256e-7)*px*pz))+(((2.376e-6)*px*(pz*pz)))))*(IKsin(j0))))+(((-1.065734604e-15)*cj2*pz))+(((x593*x593)*(((-5.7024e-11)+(((-4.4e-6)*(pz*pz*pz*pz)))+(((1.584e-8)*(px*px)))+(((-0.00648)*px*pz))+(((3.8016e-9)*pz))+(((4.4e-6)*(px*px)*(pz*pz)))+(((-9.504e-8)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((-5.28e-7)*pz*(px*px)))+(((0.108)*px*(pz*pz)))+(((0.6)*pz*(px*px*px)))+(((0.0001296)*px))+(((-0.036)*(px*px*px)))+(((1.056e-6)*(pz*pz*pz)))))*(IKcos(j0))))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((3.3e-7)*pz*(py*py)))+(((-2.16442330632e-15)*sj2))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((3.3e-7)*(pz*pz*pz)))+(((-0.0146948907324612)*px*(pz*pz)))+(((-0.48)*px*(pz*pz*pz)))+(((-0.00018250160663686)*px))+(((-5.94e-8)*(pz*pz)))+(((-0.24)*pz*(px*px*px)))+(((-0.00048)*px*py*pz))+(((6.6e-10)*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((((8.48990360283382e-6)+(((-6.4589976e-9)*cj2*pz*(px*px)))+(((3.87539856e-10)*cj2*(px*px)))+(((-2.186286168e-7)*sj2*(pz*pz*pz)))+(((0.004)*py*pz*(px*px)))+(((-0.0216)*pz*(py*py)))+(((0.0321051092723788)*pz*(px*px)))+(((0.36)*(py*py)*(pz*pz)))+(((-0.000476335180141691)*pz))+(((-1.3951434816e-12)*cj2))+(((0.0100989196690282)*(pz*pz)))+(((-0.104105109272379)*(pz*pz*pz)))+(((-0.004)*py*(pz*pz*pz)))+(((-1.162619568e-9)*cj2*(pz*pz)))+(((-4.32e-5)*py*pz))+(((-0.12)*(px*px)*(py*py)))+(((-2.0)*(py*py)*(pz*pz*pz)))+(((-2.36118906144e-9)*pz*sj2))+(((2.0)*pz*(px*px)*(py*py)))+(((-0.00024)*py*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((-2.0)*(pz*pz*pz*pz*pz)))+(((3.9353151024e-8)*sj2*(pz*pz)))+(((4.72237812288e-11)*sj2))+(((6.975717408e-11)*cj2*pz))+(((2.186286168e-7)*pz*sj2*(px*px)))+(((2.0)*pz*(px*px*px*px)))+(((6.4589976e-9)*cj2*(pz*pz*pz)))+(((-0.12)*(px*px*px*px)))+(((0.000432)*(py*py)))+(((8.64e-7)*py))+(((0.00072)*py*(pz*pz)))+(((-1.3117717008e-8)*sj2*(px*px)))+(((-0.00192630655634273)*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.325239136e-11)*cj2*px))+(((3.3e-7)*pz*(px*px)))+(((-1.98e-8)*(py*py)))+(((-0.24)*px*pz*(py*py)))+(((-5.9886569708561e-9)*pz))+(((2.0)*(px*px*px)*(pz*pz)))+(((x594*x594)*(((-1.4256e-10)+(((-0.0108000000005808)*px*pz))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((-1.188e-7)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((0.000324000000017424)*px))+(((0.09000000000484)*px*(pz*pz)))))))+(((-1.98e-8)*(px*px)))+(((3.6073721772e-14)*pz*sj2))+(((x595*x595*x595)*(((((-0.0002592)*px))+(((0.01296)*px*pz))+(((1.2)*px*(pz*pz*pz)))+(((-0.216)*px*(pz*pz)))+(((-3.168e-8)*(px*px)))+(((1.056e-6)*pz*(px*px)))+(((-8.8e-6)*(px*px)*(pz*pz)))))))+(((((-2.73752409929154e-5)+(((-9.6884964e-10)*cj2*(pz*pz)))+(((-3.54453721165756e-9)*px))+(((-7.2e-5)*py*pz))+(((1.06595620194293e-7)*px*pz))+(((-3.487858704e-12)*cj2))+(((0.3)*(pz*pz*pz*pz)))+(((0.0006)*py*(pz*pz)))+(((0.00108)*(py*py)))+(((-2.64e-10)*px*py))+(((6.6e-6)*px*(pz*pz*pz)))+(((2.16e-6)*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-1.32e-7)*(px*px*px)))+(((2.2e-6)*pz*(px*px*px)))+(((-0.072)*(pz*pz*pz)))+(((0.000782908033097182)*pz))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((1.162619568e-10)*cj2*pz))+(((2.2e-6)*px*pz*(py*py)))+(((0.9)*(px*px)*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-0.036)*pz*(py*py)))+(((-1.32e-7)*px*(py*py)))+(((-1.188e-6)*px*(pz*pz)))+(((0.00324)*(px*px)))+(((-0.108)*pz*(px*px)))+(((1.18059453072e-10)*sj2))+(((-0.00220423360914318)*(pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.3)*(py*py)*(pz*pz)))+(((-3.9353151024e-9)*pz*sj2))+(((3.279429252e-8)*sj2*(pz*pz)))))*(IKsin(j0))))+(((6.394407624e-17)*cj2))+(((0.00521938688789534)*px*pz))+(((2.0)*px*(pz*pz*pz*pz)))+(((((-1.55648232699454e-10)+(((3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.000585854016548591)*px))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((-0.018)*(px*px*px)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((-2.2e-6)*(pz*pz*pz*pz)))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-4.4e-9)*py*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-0.0119242336091432)*px*pz))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((6.13867442331512e-9)*pz))+(((-3.6e-5)*px*py))+(((0.3)*pz*(px*px*px)))+(((2.2e-6)*(px*px)*(pz*pz)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((7.92e-9)*(px*px)))+(((-2.64e-7)*pz*(px*px)))+(((5.28e-7)*(pz*pz*pz)))+(((-8.28356201942927e-8)*(pz*pz)))+(((0.0006)*px*py*pz))+(((-7.92e-9)*(py*py)))))*(IKcos(j0))))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-3.96e-11)*py))+(((x596*x596)*(((-1.4256e-10)+(((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.0606102185399176)*px*(pz*pz)))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((4.10032132562966e-5)*px))+(((-1.188e-7)*(pz*pz)))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))+(((0.000361226224790112)*px*pz)))))));
IkReal x597=IKcos(j0);
IkReal x598=IKsin(j0);
IkReal x599=IKcos(j0);
IkReal x600=IKcos(j0);
IkReal x601=IKsin(j0);
evalcond[4]=((((-2.186286168e-7)*pz*sj2*(px*px)))+(((x597*x597)*(((((-0.24)*(px*px*px*px)))+(((-2.376e-9)*px))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((7.92e-8)*px*pz))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((0.000683386887604944)*(px*px)))+(((-6.6e-7)*px*(pz*pz)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.0174102185399176)*pz*(px*px)))+(((0.008)*py*pz*(px*px)))+(((-6.6e-7)*(px*px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))))+(((x598*x598)*(((((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((-9.504e-10)*px))+(((-0.6)*(px*px*px*px)))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))*(IKcos(j0))))+(((((((5.90756201942927e-8)*px*pz))+(((0.00976423360914318)*(px*px)))+(((-2.64e-10)*px*py))+(((-3.96e-7)*px*(pz*pz)))+(((2.4049147848e-13)*px*pz*sj2))+(((0.3)*(px*px)*(pz*pz)))+(((-0.0006)*py*(px*px)))+(((-0.3)*(px*px)*(py*py)))+(((-0.036)*pz*(px*px)))+(((4.262938416e-16)*cj2*px))+(((-0.3)*(px*px*px*px)))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((2.2e-6)*px*(pz*pz*pz)))+(((-2.2e-6)*pz*(px*px*px)))+(((9.6884964e-10)*cj2*(px*px)))+(((-2.59413721165756e-9)*px))+(((1.32e-7)*(px*px*px)))+(((-1.44294887088e-14)*px*sj2))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKcos(j0))))+(((0.00024)*py*(px*px)))+(((x599*x599)*(((((-0.00648)*px*pz))+(((1.8)*pz*(px*px*px)))+(((1.32e-5)*(px*px)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((0.108)*px*(pz*pz)))+(((-4.4e-6)*(px*px*px*px)))+(((-1.584e-6)*pz*(px*px)))+(((0.0001296)*px))+(((-0.108)*(px*px*px)))+(((4.752e-8)*(px*px)))))*(IKsin(j0))))+(((-3.3e-7)*px*(pz*pz)))+(((-3.3e-7)*px*(py*py)))+(((-3.6073721772e-14)*px*sj2))+(((-3.87539856e-10)*cj2*(px*px)))+(((-6.6e-10)*px*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((1.3117717008e-8)*sj2*(px*px)))+(((0.0362948907324612)*pz*(px*px)))+(((-2.0)*pz*(px*px*px*px)))+(((3.96e-8)*px*pz))+(((x600*x600*x600)*(((((-0.00432)*(px*px)))+(((-1.2)*(px*px)*(pz*pz)))+(((-5.28e-7)*(px*px*px)))+(((8.8e-6)*pz*(px*px*px)))+(((0.144)*pz*(px*px)))))))+(((-2.0)*(px*px)*(pz*pz*pz)))+(((0.36)*(px*px)*(pz*pz)))+(((((((-0.00558061311268546)*px*pz))+(((-2.186286168e-7)*sj2*(px*px*px)))+(((-2.0)*(px*px*px)*(py*py)))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((0.0753051092723788)*px*(pz*pz)))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((-0.48)*px*(pz*pz*pz)))+(((0.000141498393380564)*px))+(((-0.004)*py*(px*px*px)))+(((-0.00048)*px*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((-2.325239136e-11)*cj2*px))+(((-0.24)*px*pz*(py*py)))+(((6.4589976e-9)*cj2*(px*px*px)))+(((-0.0321051092723788)*(px*px*px)))+(((2.0)*px*(pz*pz*pz*pz)))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-2.0)*(px*px*px*px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((0.12)*(px*px)*(py*py)))+(((8.3646569708561e-9)*px))+(((-2.0)*pz*(px*px)*(py*py)))+(((-0.00304169344394767)*(px*px)))+(((x601*x601)*(((((-2.376e-9)*px))+(((7.92e-8)*px*pz))+(((-6.6e-7)*px*(pz*pz)))+(((-6.6e-7)*(px*px*px)))+(((0.0054000000002904)*(px*px)))+(((-0.09000000000484)*pz*(px*px)))))))+(((1.065734604e-15)*cj2*px))+(((0.12)*(px*px*px*px)))+(((((((-2.2e-6)*(px*px*px*px)))+(((-3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.00544423360914318)*px*pz))+(((-0.9)*pz*(px*px*px)))+(((-6.6e-6)*(px*px)*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-5.90756201942927e-8)*(px*px)))+(((-2.2e-6)*(px*px)*(py*py)))+(((1.9676575512e-9)*px*sj2))+(((7.92e-7)*pz*(px*px)))+(((9.6884964e-10)*cj2*px*pz))+(((3.6e-5)*px*py))+(((-0.3)*px*pz*(py*py)))+(((-5.81309784e-11)*cj2*px))+(((-0.0006)*px*py*pz))+(((7.10489736e-15)*cj2*(px*px)))+(((0.054)*(px*px*px)))+(((-4.4e-9)*py*(px*px)))+(((0.018)*px*(py*py)))+(((-2.4049147848e-13)*sj2*(px*px)))+(((-0.000456254016548591)*px))))*(IKsin(j0))))+(((-0.004)*py*pz*(px*px)))+(((-3.3e-7)*(px*px*px))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x602=px*px;
IkReal x603=pz*pz;
IkReal x604=(cj0*px);
IkReal x605=(px*sj0);
IkReal x606=(pz*sj0);
IkReal x607=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+(((-2272727.27272727)*x605))+sj0+(((909090.909090909)*pz))+(((-7575757.57575758)*x603))+(((-7575757.57575758)*x602))+(((2272727.27272727)*x607))+(((-16.6666666666667)*x606))+(((-16.6666666666667)*x604)));
j1eval[1]=IKsign(((-522.0000000242)+(((2400.0)*pz))+(((6000.0)*x607))+(((-20000.0)*x603))+(((-20000.0)*x602))+(((0.00264)*sj0))+(((-360.0)*cj0))+(((-0.044)*x606))+(((-0.044)*x604))+(((-6000.0)*x605))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x608=pz*pz;
IkReal x609=px*px;
IkReal x610=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x611=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x612=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x609))+(((-7575757.57575758)*x608)));
IkReal x613=((x611*x611)+(x610*x610));
if((((18595041323.314)+(((5165289256476.13)*x609))+(((5165289256476.13)*x608))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x614=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x609))+(((5165289256476.13)*x608))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x620=IKPowWithIntegerCheck(x614,-1);
if(!x620.valid){
continue;
}
IkReal x615=x620.value;
IkReal x621 = x613;
if(IKabs(x621)==0){
continue;
}
IkReal x616=pow(x621,-0.5);
IkReal x617=((1.0)*x616);
IkReal x618=(x612*x615);
if((((1.0)+(((-1.0)*(x618*x618))))) < -0.00001)
continue;
IkReal x619=IKsqrt(((1.0)+(((-1.0)*(x618*x618)))));
CheckValue<IkReal> x622 = IKatan2WithCheck(IkReal(x610),IkReal(x611),IKFAST_ATAN2_MAGTHRESH);
if(!x622.valid){
continue;
}
if((x613) < -0.00001)
continue;
CheckValue<IkReal> x623=IKPowWithIntegerCheck(IKabs(IKsqrt(x613)),-1);
if(!x623.valid){
continue;
}
if( ((x612*(x623.value))) < -1-IKFAST_SINCOS_THRESH || ((x612*(x623.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst28=((((-1.0)*(x622.value)))+(((-1.0)*(IKasin((x612*(x623.value)))))));
IkReal gconst29=((((-1.0)*x610*x617*x619))+(((-1.0)*x611*x617*x618)));
IkReal gconst30=(((x611*x616*x619))+(((-1.0)*x610*x617*x618)));
IkReal x624=pz*pz;
IkReal x625=px*px;
if((((18595041323.314)+(((5165289256476.13)*x625))+(((5165289256476.13)*x624))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x628=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x625))+(((5165289256476.13)*x624))+(((-619834710777.135)*pz))))),-1);
if(!x628.valid){
continue;
}
IkReal x626=x628.value;
IkReal x627=((7575757.57575758)*x626);
if( (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x629 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x629.valid){
continue;
}
if( (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x630 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x630.valid){
continue;
}
CheckValue<IkReal> x631 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x631.valid){
continue;
}
if( (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x632 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x632.valid){
continue;
}
if( (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x633 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x633.valid){
continue;
}
CheckValue<IkReal> x634 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x634.valid){
continue;
}
if( (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) < -1-IKFAST_SINCOS_THRESH || (((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if(((((j0*(j0)))+(((1.0)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))))+(((-1.0)*(x629.value)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))))+(((x630.value)*(x631.value)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))*(j0)))+((j0*(x632.value)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))*(x633.value)))+(((x634.value)*(j0)))+(((-1.0)*j0*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j0*(j0)))+(((1.0)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))))+(((-1.0)*(x629.value)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))))+(((x630.value)*(x631.value)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))*(j0)))+((j0*(x632.value)))+(((-1.0)*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626)))))*(x633.value)))+(((x634.value)*(j0)))+(((-1.0)*j0*(IKasin(((((-909090.909090909)*pz*x626))+((x625*x627))+((x624*x627))+(((197727.272736439)*x626))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x635=gconst30*gconst30;
IkReal x636=gconst29*gconst29;
IkReal x637=px*px;
IkReal x638=pz*pz;
IkReal x639=((2400.0)*pz);
IkReal x640=(gconst29*px);
IkReal x641=((1657.72300388932)*sj2);
IkReal x642=(gconst30*px);
IkReal x643=((590.86479112738)*py);
IkReal x644=((99.4633802333595)*sj2);
IkReal x645=(gconst30*pz);
IkReal x646=((35.4518874676428)*py);
IkReal x647=(gconst29*pz);
IkReal x648=((20000.0)*x637);
IkReal x649=((20000.0)*x638);
CheckValue<IkReal> x650 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-0.57766479112738)*x640))+((x643*x645))+(((-1.0)*x640*x643))+(((-1.0)*x640*x641))+(((-253.38)*gconst29))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst30))+(((0.57766479112738)*x645))+((x641*x645))+(((-1.0)*gconst30*x644))+(((-1.0)*gconst30*x646))+(((4223.0)*x647))+(((4223.0)*x642)))),IkReal(((633.450000635431)+((x643*x647))+(((253.38)*gconst30))+(((-0.0346598874676428)*gconst29))+(((0.57766479112738)*x642))+(((0.57766479112738)*x647))+((x641*x647))+((x641*x642))+(((0.00182349530427826)*sj2))+(((-1.0)*gconst29*x644))+(((-1.0)*gconst29*x646))+(((-4223.0)*x645))+(((0.000649951270240118)*py))+((x642*x643))+(((4223.0)*x640)))),IKFAST_ATAN2_MAGTHRESH);
if(!x650.valid){
continue;
}
CheckValue<IkReal> x651=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+((x635*x639))+(((6000.0)*x645))+((x636*x639))+(((0.00264)*gconst29))+(((-0.044)*x647))+(((-0.044)*x642))+(((-360.0)*gconst30))+(((-1.0)*x635*x649))+(((-1.0)*x635*x648))+(((-1.0)*x636*x648))+(((-1.0)*x636*x649))+(((-72.0)*x636))+(((-72.0)*x635))+(((-6000.0)*x640)))),-1);
if(!x651.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x650.value)+(((1.5707963267949)*(x651.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x652=IKcos(j1);
IkReal x653=IKsin(j1);
IkReal x654=((0.12)*pz);
IkReal x655=pz*pz;
IkReal x656=gconst30*gconst30;
IkReal x657=px*px;
IkReal x658=((1.32e-7)*gconst29);
IkReal x659=(gconst29*gconst30);
IkReal x660=(px*pz);
IkReal x661=(gconst29*pz);
IkReal x662=(gconst30*px);
IkReal x663=(gconst29*px);
IkReal x664=((0.24)*pz);
IkReal x665=((0.018)*gconst30);
IkReal x666=(gconst30*pz);
IkReal x667=((0.24)*px);
IkReal x668=((0.12)*px);
IkReal x669=((0.06)*gconst29);
IkReal x670=x652*x652;
IkReal x671=((2.2e-6)*x661);
IkReal x672=((2.2e-6)*x662);
IkReal x673=((1.0)*x655);
IkReal x674=((1.0)*x652);
IkReal x675=((1.0)*x657);
IkReal x676=((1.32e-6)*x652);
IkReal x677=((1.0)*x653);
IkReal x678=(gconst30*x653);
IkReal x679=(x654+x658);
IkReal x680=(x652*x653);
IkReal x681=(x653*x666);
IkReal x682=((2.2e-6)*x670);
IkReal x683=((0.3)*x670);
IkReal x684=((2.0)*x680);
IkReal x685=(x655*x670);
IkReal x686=(x656*x670);
IkReal x687=(x672+x673+x671);
evalcond[0]=((-0.21115)+(((-1.1e-6)*x653))+(((-1.0)*x662*x677))+(((-1.0)*x663*x674))+(((-0.15)*x652))+((x653*x669))+((x652*x666))+(((-0.06)*gconst30*x652))+(((-1.0)*x661*x677)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.1e-6)*x652))+(((-1.0)*x662*x674))+(((-0.029543239556369)*py))+(((-1.0)*x666*x677))+(((-0.0828861501944662)*sj2))+((x653*x663))+((x652*x669))+(((0.06)*x678))+(((0.15)*x653))+(((-1.0)*x661*x674)));
evalcond[2]=((0.0253474453653594)+(((0.3)*x666))+((x661*x676))+(((-1.32e-6)*x653*x663))+((x662*x676))+(((-7.92e-8)*x678))+(((-1.0)*x687))+(((1.32e-6)*x681))+(((1.452e-12)*x652))+(((-1.0)*x665))+x679+(((-7.92e-8)*gconst29*x652))+(((-1.98e-7)*x653))+(((-0.3)*x663))+(((-1.0)*(py*py)))+(((-1.0)*x675))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-0.3)*x661*x680))+(((-2.2e-6)*x663*x680))+(((4.0)*x656*x660*x680))+(((4.0)*x659*x660*x670))+(((-1.0)*x687))+(((-1.0)*x657*x659*x684))+(((-1.0)*x654*x670))+((x655*x659*x684))+((x670*x671))+((x670*x672))+(((0.018)*gconst29*x680))+(((-2.0)*x656*x685))+(((-1.0)*x663*x683))+(((-0.0072)*x686))+(((-1.0)*x658*x670))+(((2.0)*x657*x686))+(((-0.3)*x662*x680))+(((-1.0)*x670*x675))+(((-3.3e-7)*x680))+(((-1.0)*x665*x670))+(((-1.0)*x660*x684))+((x666*x683))+((x664*x686))+(((-0.01889999999879)*x670))+x679+x685+((x655*x656))+(((0.0036)*x656))+(((-1.0)*x659*x667*x670))+((x659*x668))+(((-1.32e-7)*x652*x678))+(((-1.0)*x656*x675))+(((-1.0)*x659*x664*x680))+(((0.0072)*x659*x680))+((x668*x680))+(((-2.0)*x659*x660))+(((2.2e-6)*x666*x680))+(((-1.0)*x656*x667*x680))+(((-1.0)*x654*x656)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x688=(cj1*gconst29);
IkReal x689=((0.0295301092415339)*sj2);
IkReal x690=((0.999563891228661)*cj2);
IkReal x691=(gconst30*sj1);
IkReal x692=((((-1.0)*gconst29*sj1))+((cj1*gconst30)));
IkReal x693=(((x688*x690))+((x688*x689))+((x690*x691))+((x689*x691)));
CheckValue<IkReal> x696 = IKatan2WithCheck(IkReal(x692),IkReal(x693),IKFAST_ATAN2_MAGTHRESH);
if(!x696.valid){
continue;
}
IkReal x694=((1.0)*(x696.value));
if((((x692*x692)+(x693*x693))) < -0.00001)
continue;
CheckValue<IkReal> x697=IKPowWithIntegerCheck(IKabs(IKsqrt(((x692*x692)+(x693*x693)))),-1);
if(!x697.valid){
continue;
}
if( (((x697.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x697.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x695=IKasin(((x697.value)*(IKcos(r00))));
j3array[0]=(x695+(((-1.0)*x694)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x694))+(((-1.0)*x695)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x698=pz*pz;
IkReal x699=px*px;
IkReal x700=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x701=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x702=((-197727.272736439)+(((909090.909090909)*pz))+(((-7575757.57575758)*x698))+(((-7575757.57575758)*x699)));
IkReal x703=x702*x702;
IkReal x704=((x700*x700)+(x701*x701));
if((((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x698))+(((5165289256476.13)*x699)))) < -0.00001)
continue;
IkReal x705=IKabs(IKsqrt(((18595041323.314)+(((-619834710777.135)*pz))+(((5165289256476.13)*x698))+(((5165289256476.13)*x699)))));
CheckValue<IkReal> x712=IKPowWithIntegerCheck(x705,-1);
if(!x712.valid){
continue;
}
IkReal x706=x712.value;
IkReal x713 = x704;
if(IKabs(x713)==0){
continue;
}
IkReal x707=pow(x713,-0.5);
CheckValue<IkReal> x714=IKPowWithIntegerCheck(x705,-2);
if(!x714.valid){
continue;
}
IkReal x708=x714.value;
IkReal x709=((1.0)*x707);
IkReal x710=(x702*x706);
IkReal x711=(x703*x708);
CheckValue<IkReal> x715 = IKatan2WithCheck(IkReal(x700),IkReal(x701),IKFAST_ATAN2_MAGTHRESH);
if(!x715.valid){
continue;
}
if((x704) < -0.00001)
continue;
CheckValue<IkReal> x716=IKPowWithIntegerCheck(IKabs(IKsqrt(x704)),-1);
if(!x716.valid){
continue;
}
if( ((x702*(x716.value))) < -1-IKFAST_SINCOS_THRESH || ((x702*(x716.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst31=((3.14159265358979)+(((-1.0)*(x715.value)))+(IKasin((x702*(x716.value)))));
if((((1.0)+(((-1.0)*x711)))) < -0.00001)
continue;
IkReal gconst32=((((-1.0)*x701*x709*x710))+((x700*x709*(IKsqrt(((1.0)+(((-1.0)*x711))))))));
if((((1.0)+(((-1.0)*x711)))) < -0.00001)
continue;
IkReal gconst33=((((-1.0)*x700*x709*x710))+(((-1.0)*x701*x709*(IKsqrt(((1.0)+(((-1.0)*x711))))))));
IkReal x717=x700;
IkReal x718=x701;
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x719=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x719.valid){
continue;
}
if( (((x719.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x719.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x720=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x720.valid){
continue;
}
if( (((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x721 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x721.valid){
continue;
}
CheckValue<IkReal> x722 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x722.valid){
continue;
}
CheckValue<IkReal> x723 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x723.valid){
continue;
}
CheckValue<IkReal> x724 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x724.valid){
continue;
}
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x725=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x725.valid){
continue;
}
if( (((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x727=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x727.valid){
continue;
}
if( (((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x728=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x728.valid){
continue;
}
if( (((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x729 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x729.valid){
continue;
}
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x730=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x730.valid){
continue;
}
if( (((x730.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x730.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x731 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x731.valid){
continue;
}
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x732=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x732.valid){
continue;
}
if( (((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x717*x717)+(x718*x718))) < -0.00001)
continue;
CheckValue<IkReal> x733=IKPowWithIntegerCheck(IKabs(IKsqrt(((x717*x717)+(x718*x718)))),-1);
if(!x733.valid){
continue;
}
if( (((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x734 = IKatan2WithCheck(IkReal(x717),IkReal(x718),IKFAST_ATAN2_MAGTHRESH);
if(!x734.valid){
continue;
}
if((((9.86960440108936)+((j0*(j0)))+(((3.14159265358979)*(IKasin(((x719.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+((j0*(x721.value)))+(((x722.value)*(j0)))+(((x723.value)*(x724.value)))+(((-1.0)*(IKasin(((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x726.value)))+(((1.0)*(IKasin(((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(j0)))+(((-1.0)*(x729.value)*(IKasin(((x730.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(x731.value)))+(((3.14159265358979)*(IKasin(((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*j0))+(((-3.14159265358979)*(x734.value))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((j0*(j0)))+(((3.14159265358979)*(IKasin(((x719.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x720.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+((j0*(x721.value)))+(((x722.value)*(j0)))+(((x723.value)*(x724.value)))+(((-1.0)*(IKasin(((x725.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x726.value)))+(((1.0)*(IKasin(((x727.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x728.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(j0)))+(((-1.0)*(x729.value)*(IKasin(((x730.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(x731.value)))+(((3.14159265358979)*(IKasin(((x732.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*j0*(IKasin(((x733.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*j0))+(((-3.14159265358979)*(x734.value))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x735=gconst33*gconst33;
IkReal x736=gconst32*gconst32;
IkReal x737=pz*pz;
IkReal x738=px*px;
IkReal x739=(gconst32*pz);
IkReal x740=((590.86479112738)*py);
IkReal x741=(gconst33*pz);
IkReal x742=((2400.0)*pz);
IkReal x743=(gconst32*px);
IkReal x744=((35.4518874676428)*py);
IkReal x745=((99.4633802333595)*sj2);
IkReal x746=(gconst33*px);
IkReal x747=((1657.72300388932)*sj2);
IkReal x748=((20000.0)*x738);
IkReal x749=((20000.0)*x737);
CheckValue<IkReal> x750=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((-0.044)*x746))+(((-6000.0)*x743))+(((0.00264)*gconst32))+(((6000.0)*x741))+(((-360.0)*gconst33))+(((-72.0)*x736))+(((-72.0)*x735))+(((-0.044)*x739))+(((-1.0)*x735*x748))+(((-1.0)*x735*x749))+(((-1.0)*x736*x748))+(((-1.0)*x736*x749))+((x735*x742))+((x736*x742)))),-1);
if(!x750.valid){
continue;
}
CheckValue<IkReal> x751 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-253.38)*gconst32))+(((-0.57766479112738)*x743))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst33))+((x740*x741))+((x741*x747))+(((-1.0)*x740*x743))+(((4223.0)*x746))+(((0.57766479112738)*x741))+(((-1.0)*x743*x747))+(((-1.0)*gconst33*x745))+(((-1.0)*gconst33*x744))+(((4223.0)*x739)))),IkReal(((633.450000635431)+(((-1.0)*gconst32*x744))+(((-1.0)*gconst32*x745))+(((0.57766479112738)*x739))+(((253.38)*gconst33))+((x739*x747))+((x739*x740))+(((-0.0346598874676428)*gconst32))+((x746*x747))+((x740*x746))+(((0.00182349530427826)*sj2))+(((4223.0)*x743))+(((-4223.0)*x741))+(((0.57766479112738)*x746))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x751.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x750.value)))+(x751.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x752=IKsin(j1);
IkReal x753=IKcos(j1);
IkReal x754=((0.12)*pz);
IkReal x755=gconst33*gconst33;
IkReal x756=px*px;
IkReal x757=pz*pz;
IkReal x758=((1.32e-7)*gconst32);
IkReal x759=(gconst33*px);
IkReal x760=((2.2e-6)*gconst32);
IkReal x761=(gconst32*pz);
IkReal x762=((0.018)*gconst33);
IkReal x763=((1.0)*pz);
IkReal x764=((0.3)*px);
IkReal x765=(px*pz);
IkReal x766=(gconst33*pz);
IkReal x767=x753*x753;
IkReal x768=((2.2e-6)*x759);
IkReal x769=(pz*x760);
IkReal x770=((1.0)*x757);
IkReal x771=(gconst32*x752);
IkReal x772=((1.0)*x753);
IkReal x773=(gconst33*x752);
IkReal x774=((1.0)*x756);
IkReal x775=(gconst33*x753);
IkReal x776=((2.0)*gconst32*gconst33);
IkReal x777=((0.24)*x755);
IkReal x778=((1.32e-6)*x753);
IkReal x779=(gconst32*x753);
IkReal x780=(x754+x758);
IkReal x781=(x752*x753);
IkReal x782=(pz*x767);
IkReal x783=(gconst32*x767);
IkReal x784=(x757*x767);
IkReal x785=(x755*x767);
IkReal x786=(x770+x768+x769);
evalcond[0]=((-0.21115)+(((-1.0)*x752*x759))+(((-1.1e-6)*x752))+(((-1.0)*x752*x761))+(((-0.15)*x753))+(((0.06)*x771))+(((-1.0)*gconst32*px*x772))+((x753*x766))+(((-0.06)*x775)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.1e-6)*x753))+(((-0.029543239556369)*py))+((px*x771))+(((-0.0828861501944662)*sj2))+(((-1.0)*x759*x772))+(((0.06)*x773))+(((0.06)*x779))+(((-1.0)*x763*x773))+(((-1.0)*x761*x772))+(((0.15)*x752)));
evalcond[2]=((0.0253474453653594)+(((-1.0)*x786))+(((-1.0)*x762))+(((-1.98e-7)*x752))+(((-7.92e-8)*x779))+(((-7.92e-8)*x773))+((x759*x778))+(((-1.0)*gconst32*x764))+x780+(((-1.0)*x774))+(((1.32e-6)*x752*x766))+((x761*x778))+(((-1.0)*(py*py)))+(((0.3)*x766))+(((1.452e-12)*x753))+(((-1.32e-6)*px*x771))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-1.0)*x758*x767))+(((-2.0)*x755*x784))+(((-0.0072)*x785))+(((0.3)*x766*x767))+(((-1.0)*x762*x767))+(((-0.01889999999879)*x767))+(((-1.0)*px*x760*x781))+(((-1.0)*x755*x774))+(((-1.0)*x786))+(((0.12)*px*x781))+(((-1.0)*x754*x755))+(((2.0)*x756*x785))+(((-2.0)*x765*x781))+(((-0.3)*x761*x781))+(((-1.0)*x767*x774))+(((-0.24)*x759*x783))+(((-1.32e-7)*x753*x773))+(((-1.0)*x754*x767))+(((0.0072)*x771*x775))+(((-1.0)*px*x777*x781))+(((2.2e-6)*x766*x781))+(((4.0)*x755*x765*x781))+(((-1.0)*x764*x783))+(((4.0)*x759*x761*x767))+(((-0.24)*x753*x761*x773))+(((-0.3)*x759*x781))+(((-2.0)*x756*x771*x775))+(((2.0)*x757*x771*x775))+(((0.0036)*x755))+(((-2.0)*x759*x761))+(((-3.3e-7)*x781))+((x755*x757))+x780+x784+((x767*x769))+((x767*x768))+((x777*x782))+(((0.12)*gconst32*x759))+(((0.018)*x753*x771)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x787=(cj1*gconst32);
IkReal x788=((0.0295301092415339)*sj2);
IkReal x789=((0.999563891228661)*cj2);
IkReal x790=(gconst33*sj1);
IkReal x791=((((-1.0)*gconst32*sj1))+((cj1*gconst33)));
IkReal x792=(((x787*x788))+((x787*x789))+((x788*x790))+((x789*x790)));
CheckValue<IkReal> x795 = IKatan2WithCheck(IkReal(x791),IkReal(x792),IKFAST_ATAN2_MAGTHRESH);
if(!x795.valid){
continue;
}
IkReal x793=((1.0)*(x795.value));
if((((x791*x791)+(x792*x792))) < -0.00001)
continue;
CheckValue<IkReal> x796=IKPowWithIntegerCheck(IKabs(IKsqrt(((x791*x791)+(x792*x792)))),-1);
if(!x796.valid){
continue;
}
if( (((x796.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x796.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x794=IKasin(((x796.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x793))+x794);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x793))+(((-1.0)*x794)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x797=((4223.0)*pz);
IkReal x798=((0.0132)*px);
IkReal x799=((48.9318)*cj2);
IkReal x800=(pz*sj0);
IkReal x801=((2.935908)*cj2);
IkReal x802=(cj0*px);
IkReal x803=((1656.2774)*sj2);
IkReal x804=(px*sj0);
IkReal x805=(cj0*pz);
IkReal x806=((99.376644)*sj2);
CheckValue<IkReal> x807=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-6000.0)*x804))+(((6000.0)*x805))+(((-0.044)*x800))+(((-0.044)*x802))+(((-360.0)*cj0))+(((-20000.0)*(px*px))))),-1);
if(!x807.valid){
continue;
}
CheckValue<IkReal> x808 = IKatan2WithCheck(IkReal(((0.0066253)+(((-253.38)*sj0))+(((-1.0)*x799*x805))+((sj0*x798))+((sj0*x797))+(((0.000792)*cj0))+((x803*x805))+(((-248.44161)*sj2))+((x799*x804))+((cj0*x801))+(((-0.0132)*x805))+(((-1.0)*x803*x804))+(((-1.0)*cj0*x806))+(((7.33977)*cj2))+(((4223.0)*x802)))),IkReal(((633.44999998548)+(((-1.0)*cj0*x798))+(((-1.0)*cj0*x797))+(((253.38)*cj0))+(((-1.0)*x799*x802))+(((-1.0)*x799*x800))+((x800*x803))+(((-5.382498e-5)*cj2))+(((0.00182190514)*sj2))+((sj0*x801))+(((-0.0132)*x800))+(((0.000792)*sj0))+(((-1.0)*sj0*x806))+((x802*x803))+(((4223.0)*x804)))),IKFAST_ATAN2_MAGTHRESH);
if(!x808.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x807.value)))+(x808.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x809=IKcos(j1);
IkReal x810=IKsin(j1);
IkReal x811=((0.12)*pz);
IkReal x812=cj0*cj0;
IkReal x813=pz*pz;
IkReal x814=px*px;
IkReal x815=((1.32e-7)*sj0);
IkReal x816=(cj0*px);
IkReal x817=((2.2e-6)*pz);
IkReal x818=((0.3)*pz);
IkReal x819=((0.3)*px);
IkReal x820=(pz*sj0);
IkReal x821=((0.24)*pz);
IkReal x822=((4.0)*pz);
IkReal x823=x809*x809;
IkReal x824=((2.2e-6)*x816);
IkReal x825=(sj0*x817);
IkReal x826=((1.0)*x813);
IkReal x827=((1.0)*x810);
IkReal x828=((1.32e-6)*x809);
IkReal x829=(cj0*x810);
IkReal x830=(sj0*x809);
IkReal x831=(sj0*x810);
IkReal x832=(cj0*x809);
IkReal x833=(px*x812);
IkReal x834=((1.0)*x814);
IkReal x835=(x815+x811);
IkReal x836=(x809*x810);
IkReal x837=(x812*x813);
IkReal x838=(sj0*x823);
IkReal x839=(cj0*x823);
IkReal x840=(x814*x823);
IkReal x841=(x812*x823);
IkReal x842=(x826+x825+x824);
evalcond[0]=((-0.21115)+(((-1.0)*x816*x827))+(((-1.1e-6)*x810))+(((0.06)*x831))+(((-0.06)*x832))+(((-1.0)*px*x830))+((pz*x832))+(((-0.15)*x809))+(((-1.0)*x820*x827)));
evalcond[1]=((6.6e-7)+(((0.06)*x829))+(((-1.0)*cj0*pz*x827))+(((0.06)*x830))+(((0.00244659)*cj2))+(((-0.08281387)*sj2))+(((-1.0)*x809*x820))+(((-1.1e-6)*x809))+(((-1.0)*x809*x816))+(((0.15)*x810))+((px*x831)));
evalcond[2]=((0.0253474453653594)+(((-7.92e-8)*x830))+(((-1.98e-7)*x810))+((cj0*x818))+((x820*x828))+(((-1.0)*sj0*x819))+((x816*x828))+(((-1.0)*x842))+(((-1.0)*x834))+x835+(((1.452e-12)*x809))+(((-1.0)*(py*py)))+(((1.32e-6)*pz*x829))+(((-1.32e-6)*px*x831))+(((-0.018)*cj0))+(((-0.002)*py))+(((-7.92e-8)*x829)));
evalcond[3]=((0.04098432249879)+((x818*x839))+(((-0.24)*x816*x838))+(((-0.24)*x833*x836))+(((-0.018)*x839))+((x821*x841))+(((0.018)*x810*x830))+(((-0.24)*x809*x820*x829))+(((-1.0)*x823*x834))+(((-0.0072)*x841))+(((-1.0)*x815*x823))+(((-1.0)*x811*x812))+(((-1.0)*x810*x818*x830))+(((-1.0)*x819*x838))+(((-1.0)*x811*x823))+(((-0.01889999999879)*x823))+(((-2.0)*x816*x820))+((x813*x823))+(((0.0036)*x812))+(((4.0)*x816*x820*x823))+(((-1.0)*x842))+(((0.12)*sj0*x816))+(((-1.32e-7)*x809*x829))+((x809*x817*x829))+(((-2.0)*x823*x837))+(((-2.0)*x814*x829*x830))+(((-2.2e-6)*px*x810*x830))+((x823*x824))+((x823*x825))+(((2.0)*x812*x840))+(((2.0)*x813*x829*x830))+x835+x837+(((-2.0)*px*pz*x836))+(((-0.3)*x816*x836))+((x822*x833*x836))+(((-1.0)*x812*x834))+(((-3.3e-7)*x836))+(((0.0072)*x829*x830))+(((0.12)*px*x836)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
IkReal x843=cj2*cj2;
IkReal x844=cj1*cj1;
IkReal x845=cj0*cj0;
IkReal x846=sj1*sj1;
IkReal x847=sj0*sj0;
IkReal x848=sj2*sj2;
IkReal x849=(cj0*cj1);
IkReal x850=(sj0*sj1);
IkReal x851=((67.6979474104201)*cj2*sj2);
IkReal x852=((1145.753020896)*x843);
IkReal x853=(x845*x846);
IkReal x854=(x844*x847);
j3eval[0]=(((x848*x854))+((x848*x853))+(((135.39589482084)*cj2*sj2*x849*x850))+(((2.0)*x848*x849*x850))+(((-2293.50604179201)*x849*x850))+(((2291.50604179201)*x843*x849*x850))+((x851*x853))+((x851*x854))+(((1146.753020896)*x846*x847))+((x852*x853))+((x852*x854))+(((1146.753020896)*x844*x845)));
j3eval[1]=((((-1.0)*x850))+x849);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x855=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x855.valid){
continue;
}
sj3array[0]=((x855.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x856=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x856.valid){
continue;
}
sj3array[0]=((x856.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x857=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x857.valid){
continue;
}
sj3array[0]=((x857.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x858=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x858.valid){
continue;
}
sj3array[0]=((x858.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x859=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x859.valid){
continue;
}
sj3array[0]=((x859.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x860=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x860.valid){
continue;
}
sj3array[0]=((x860.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x861=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x861.valid){
continue;
}
sj3array[0]=((x861.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x862=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x862.valid){
continue;
}
sj3array[0]=((x862.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x863=(cj1*sj0);
IkReal x864=((0.0295301092415339)*sj2);
IkReal x865=((0.999563891228661)*cj2);
IkReal x866=(cj0*sj1);
IkReal x867=(((cj0*cj1))+(((-1.0)*sj0*sj1)));
IkReal x868=(((x863*x864))+((x863*x865))+((x865*x866))+((x864*x866)));
CheckValue<IkReal> x871 = IKatan2WithCheck(IkReal(x867),IkReal(x868),IKFAST_ATAN2_MAGTHRESH);
if(!x871.valid){
continue;
}
IkReal x869=((1.0)*(x871.value));
if((((x868*x868)+(x867*x867))) < -0.00001)
continue;
CheckValue<IkReal> x872=IKPowWithIntegerCheck(IKabs(IKsqrt(((x868*x868)+(x867*x867)))),-1);
if(!x872.valid){
continue;
}
if( (((x872.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x872.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x870=IKasin(((x872.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x869))+x870);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x869))+(((-1.0)*x870)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x873=px*px;
IkReal x874=(px*pz);
IkReal x875=((((-0.3)*x874))+(((0.018)*px))+(((2.2e-6)*x873)));
IkReal x876=((((0.3)*x873))+(((2.2e-6)*x874))+(((-1.32e-7)*px)));
CheckValue<IkReal> x879 = IKatan2WithCheck(IkReal(x875),IkReal(x876),IKFAST_ATAN2_MAGTHRESH);
if(!x879.valid){
continue;
}
IkReal x877=((1.0)*(x879.value));
if((((x876*x876)+(x875*x875))) < -0.00001)
continue;
CheckValue<IkReal> x880=IKPowWithIntegerCheck(IKabs(IKsqrt(((x876*x876)+(x875*x875)))),-1);
if(!x880.valid){
continue;
}
if( (((x880.value)*(((((-0.12)*x874))+(((0.002)*px*py))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x874)))))) < -1-IKFAST_SINCOS_THRESH || (((x880.value)*(((((-0.12)*x874))+(((0.002)*px*py))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x874)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x878=IKasin(((x880.value)*(((((-0.12)*x874))+(((0.002)*px*py))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.0253474453662306)*px))+(((-3.2294988e-9)*cj2*px))+((px*(py*py)))+((pz*x874))))));
j0array[0]=((((-1.0)*x878))+(((-1.0)*x877)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x878+(((-1.0)*x877)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x881=pz*pz;
IkReal x882=py*py;
IkReal x883=px*px;
IkReal x884=((1.0)*pz);
IkReal x885=(px*pz);
evalcond[0]=((-0.00152084672197384)+(((-0.002)*py*pz))+(((0.0181474453662306)*pz))+(((((0.00108)+(((-2.2e-6)*x885))+(((0.3)*x881))+(((1.32e-7)*px))+(((-0.036)*pz))))*(IKcos(j0))))+(((((-7.92e-9)+(((0.018)*px))+(((2.64e-7)*pz))+(((-2.2e-6)*x881))+(((-0.3)*x885))))*(IKsin(j0))))+(((-1.0)*x883*x884))+(((6.558858504e-9)*sj2))+(((-1.0)*x882*x884))+(((0.18)*x881))+(((-1.93769928e-10)*cj2))+(((0.00012)*py))+(((-1.093143084e-7)*pz*sj2))+(((-1.0)*x884*(pz*pz)))+(((0.06)*x883))+(((0.06)*x882))+(((3.2294988e-9)*cj2*pz)));
IkReal x886=IKcos(j0);
IkReal x887=IKsin(j0);
IkReal x888=IKcos(j0);
IkReal x889=IKsin(j0);
IkReal x890=IKcos(j0);
evalcond[1]=((2.87440030434653e-5)+(((-0.06)*(px*px)*(py*py)))+(((0.01169999999879)*pz*(py*py)))+(((-5.81309784e-10)*cj2*(pz*pz)))+(((-0.06)*(px*px*px*px)))+(((((((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.000282996786761127)*px))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((0.0111612262253709)*px*pz))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-0.150610218544758)*px*(pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))))*(IKcos(j0))*(IKsin(j0))))+(((((6.96324099683585e-6)+(((7.92e-7)*px*(pz*pz)))+(((-0.0006)*py*(pz*pz)))+(((-1.18059453072e-10)*sj2))+(((0.00193423361023218)*(pz*pz)))+(((-0.00216)*(px*px)))+(((-1.162619568e-10)*cj2*pz))+(((-3.279429252e-8)*sj2*(pz*pz)))+(((3.487858704e-12)*cj2))+(((-0.3)*(py*py)*(pz*pz)))+(((-0.00108)*(py*py)))+(((-5.84066278818272e-9)*px))+(((-2.16e-6)*py))+(((0.036)*pz*(py*py)))+(((-0.6)*(px*px)*(pz*pz)))+(((1.44294887088e-14)*px*sj2))+(((7.2e-5)*py*pz))+(((-2.2e-6)*px*pz*(py*py)))+(((0.072)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((6.56643798030453e-8)*px*pz))+(((3.9353151024e-9)*pz*sj2))+(((2.64e-10)*px*py))+(((-0.000232108033227862)*pz))+(((-2.4049147848e-13)*px*pz*sj2))+(((1.32e-7)*px*(py*py)))+(((-4.262938416e-16)*cj2*px))+(((9.6884964e-10)*cj2*(pz*pz)))+(((7.10489736e-15)*cj2*px*pz))+(((-4.4e-9)*px*py*pz))))*(IKcos(j0))))+(((-1.23962425717664e-10)*sj2))+(((-0.0064474453674406)*pz*(px*px)))+(((0.00036)*py*(pz*pz)))+(((-3.2294988e-9)*cj2*pz*(px*px)))+(((0.3)*(pz*pz*pz*pz)))+(((-1.0)*(py*py)*(pz*pz*pz)))+((pz*(px*px*px*px)))+(((x886*x886)*(((-8.48990360178838e-6)+(((-2.186286168e-7)*pz*sj2*(px*px)))+(((-0.36)*(py*py)*(pz*pz)))+(((0.00024)*py*(px*px)))+(((2.0)*(py*py)*(pz*pz*pz)))+(((0.104105109267539)*(pz*pz*pz)))+(((0.0578948907276212)*pz*(px*px)))+(((-3.87539856e-10)*cj2*(px*px)))+(((-3.9353151024e-8)*sj2*(pz*pz)))+(((-8.64e-7)*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((0.0216)*pz*(py*py)))+(((1.162619568e-9)*cj2*(pz*pz)))+(((1.3117717008e-8)*sj2*(px*px)))+(((2.186286168e-7)*sj2*(pz*pz*pz)))+(((-0.00072)*py*(pz*pz)))+(((-2.0)*pz*(px*px*px*px)))+(((4.32e-5)*py*pz))+(((-0.00347369344365727)*(px*px)))+(((-6.4589976e-9)*cj2*(pz*pz*pz)))+(((1.3951434816e-12)*cj2))+(((-0.010098919668157)*(pz*pz)))+(((0.004)*py*(pz*pz*pz)))+(((2.0)*(pz*pz*pz*pz*pz)))+(((0.12)*(px*px)*(py*py)))+(((-2.0)*pz*(px*px)*(py*py)))+(((-6.975717408e-11)*cj2*pz))+(((0.000476335180089419)*pz))+(((-0.000432)*(py*py)))+(((0.12)*(px*px*px*px)))+(((-4.72237812288e-11)*sj2))+(((-0.004)*py*pz*(px*px)))+(((-0.6)*(pz*pz*pz*pz)))+(((2.36118906144e-9)*pz*sj2))))))+(((-0.002)*py*(pz*pz*pz)))+(((-0.0011339999999274)*(py*py)))+(((x887*x887)*(((1.04544e-15)+(((-4.84e-12)*(pz*pz*pz)))+(((-0.0054)*(px*px)))+(((0.09)*pz*(px*px)))+(((8.712e-13)*(pz*pz)))+(((-5.2272e-14)*pz))))))+(((3.2294988e-9)*cj2*(pz*pz*pz)))+(((1.93769928e-10)*cj2*(px*px)))+(((-0.00012)*py*(px*px)))+(((-2.2679999998548e-6)*py))+(((-1.093143084e-7)*sj2*(pz*pz*pz)))+((pz*(px*px)*(py*py)))+(((((3.50439767290963e-10)+(((3.279429252e-8)*px*pz*sj2))+(((1.81443798030453e-8)*(pz*pz)))+(((-4.4e-6)*(pz*pz*pz*pz)))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-9.78052557636544e-9)*pz))+(((-4.4e-9)*py*(pz*pz)))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((0.0006)*px*py*pz))+(((1.056e-6)*(pz*pz*pz)))+(((-7.92e-9)*(py*py)))))*(IKsin(j0))))+(((2.339999999758e-5)*py*pz))+(((3.66225163896554e-12)*cj2))+(((x888*x888)*(((5.7024e-11)+(((4.4e-6)*(pz*pz*pz*pz)))+(((-4.752e-8)*(px*px)))+(((-0.324)*px*(pz*pz)))+(((9.504e-8)*(pz*pz)))+(((0.036)*(px*px*px)))+(((1.8)*px*(pz*pz*pz)))+(((-3.8016e-9)*pz))+(((-1.056e-6)*(pz*pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.01944)*px*pz))+(((-0.0003888)*px))+(((-1.32e-5)*(px*px)*(pz*pz)))+(((1.584e-6)*pz*(px*px)))))*(IKsin(j0))))+(((0.000386846722046436)*(px*px)))+(((1.27897740814773e-9)*pz*sj2))+(((x889*x889)*(((((-8.8e-6)*px*(pz*pz*pz)))+(((-0.00432)*(px*px)))+(((1.584e-6)*px*(pz*pz)))+(((-9.504e-8)*px*pz))+(((-1.2)*(px*px)*(pz*pz)))+(((1.9008e-9)*px))+(((0.144)*pz*(px*px)))))*(IKcos(j0))))+(((-1.0)*(pz*pz*pz*pz*pz)))+(((-0.00016048511076294)*pz))+(((0.002)*py*pz*(px*px)))+(((-3.77851359560923e-11)*cj2*pz))+(((-6.558858504e-9)*sj2*(px*px)))+(((-0.00710054016570371)*(pz*pz)))+(((0.0154474453650206)*(pz*pz*pz)))+(((1.9676575512e-8)*sj2*(pz*pz)))+(((1.093143084e-7)*pz*sj2*(px*px)))+(((x890*x890*x890)*(((-7.776e-6)+(((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((0.144)*(pz*pz*pz)))+(((-9.504e-10)*px))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.01296)*(pz*pz)))+(((0.0005184)*pz))+(((-0.6)*(pz*pz*pz*pz)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))))+(((0.18)*(py*py)*(pz*pz))));
IkReal x891=IKsin(j0);
IkReal x892=IKcos(j0);
IkReal x893=IKsin(j0);
IkReal x894=IKcos(j0);
IkReal x895=IKcos(j0);
evalcond[2]=((((((((-2.64e-10)*px*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-0.0006)*py*(px*px)))+(((-0.6)*(px*px*px*px)))+(((-0.3)*(px*px)*(py*py)))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((-6.56643798030453e-8)*px*pz))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((9.6884964e-10)*cj2*(px*px)))+(((5.84066278818272e-9)*px))+(((4.4e-6)*px*(pz*pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.00193423361023218)*(px*px)))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKsin(j0))))+(((-1.0)*(px*px*px)*(py*py)))+(((-0.24)*px*(pz*pz*pz)))+(((3.2294988e-9)*cj2*(px*px*px)))+(((x891*x891)*(((((-5.808e-13)*px*pz))+(((-0.09)*(px*px*px)))+(((4.84e-12)*px*(pz*pz)))+(((1.7424e-14)*px))))))+(((0.000479066717391088)*px))+(((0.0064474453674406)*(px*px*px)))+(((0.002)*px*py*(pz*pz)))+(((-0.01889999999879)*px*(py*py)))+(((6.10375273160923e-11)*cj2*px))+(((-0.00024)*px*py*pz))+(((0.00530969344380247)*px*pz))+((px*(pz*pz*pz*pz)))+(((x892*x892*x892)*(((((4.4e-6)*(px*px*px*px)))+(((0.00648)*px*pz))+(((-0.0001296)*px))+(((0.036)*(px*px*px)))+(((5.28e-7)*pz*(px*px)))+(((-1.584e-8)*(px*px)))+(((-4.4e-6)*(px*px)*(pz*pz)))+(((-0.6)*pz*(px*px*px)))+(((0.6)*px*(pz*pz*pz)))+(((-0.108)*px*(pz*pz)))))))+(((-1.0)*(px*px*px*px*px)))+(((-1.3117717008e-8)*px*pz*sj2))+(((-3.779999999758e-5)*px*py))+(((x893*x893)*(((((-0.072)*(px*px*px)))+(((3.168e-8)*(px*px)))+(((8.8e-6)*(px*px)*(pz*pz)))+(((1.2)*pz*(px*px*px)))+(((-1.056e-6)*pz*(px*px)))))*(IKcos(j0))))+(((x894*x894)*(((((-0.0578948907276212)*(px*px*px)))+(((-7.75079712e-10)*cj2*px*pz))+(((2.0)*(px*px*px)*(py*py)))+(((-7.8706302048e-10)*px*sj2))+(((0.004)*py*(px*px*px)))+(((0.24)*px*pz*(py*py)))+(((-2.186286168e-7)*px*sj2*(pz*pz)))+(((-2.0)*px*(pz*pz*pz*pz)))+(((-1.44e-5)*px*py))+(((6.4589976e-9)*cj2*px*(pz*pz)))+(((-0.00014149839336314)*px))+(((-0.004)*px*py*(pz*pz)))+(((0.00048)*px*py*pz))+(((-0.0072)*px*(py*py)))+(((2.325239136e-11)*cj2*px))+(((2.186286168e-7)*sj2*(px*px*px)))+(((0.00558061311210466)*px*pz))+(((2.6235434016e-8)*px*pz*sj2))+(((-6.4589976e-9)*cj2*(px*px*px)))+(((2.0)*(px*px*px*px*px)))+(((-0.0753051092675388)*px*(pz*pz)))+(((0.48)*px*(pz*pz*pz)))+(((-2.0)*px*(py*py)*(pz*pz)))))))+(((-1.093143084e-7)*sj2*(px*px*px)))+(((1.093143084e-7)*px*sj2*(pz*pz)))+(((x895*x895)*(((((7.92e-7)*px*(pz*pz)))+(((9.504e-10)*px))+(((1.32e-5)*pz*(px*px*px)))+(((-7.92e-7)*(px*px*px)))+(((0.216)*pz*(px*px)))+(((-4.4e-6)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-4.752e-8)*px*pz))+(((-1.8)*(px*px)*(pz*pz)))+(((0.6)*(px*px*px*px)))))*(IKsin(j0))))+(((-0.12)*px*pz*(py*py)))+(((-0.0298474453650206)*px*(pz*pz)))+(((-0.002)*py*(px*px*px)))+(((((((-0.24)*(px*px*px*px)))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((0.107410218544758)*pz*(px*px)))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((-0.00471661311268546)*(px*px)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.008)*py*pz*(px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.06604042862773e-9)*px*sj2))+((px*(py*py)*(pz*pz)))+(((((((3.279429252e-8)*px*pz*sj2))+(((-9.73443798030453e-8)*(px*px)))+(((0.3)*px*pz*(py*py)))+(((5.81309784e-11)*cj2*px))+(((2.2e-6)*(px*px)*(py*py)))+(((2.4049147848e-13)*sj2*(px*px)))+(((-0.018)*px*(py*py)))+(((4.4e-6)*(px*px)*(pz*pz)))+(((0.000116054016613931)*px))+(((-3.6e-5)*px*py))+(((-0.00193423361023218)*px*pz))+(((-5.28e-7)*pz*(px*px)))+(((4.4e-9)*py*(px*px)))+(((0.6)*pz*(px*px*px)))+(((-0.036)*(px*px*px)))+(((-9.6884964e-10)*cj2*px*pz))+(((-1.9676575512e-9)*px*sj2))+(((-7.10489736e-15)*cj2*(px*px)))+(((0.0006)*px*py*pz))))*(IKcos(j0))))+(((-3.2294988e-9)*cj2*px*(pz*pz)))+(((3.87539856e-10)*cj2*px*pz)));
IkReal x896=IKcos(j0);
IkReal x897=IKsin(j0);
IkReal x898=IKsin(j0);
IkReal x899=IKcos(j0);
IkReal x900=IKcos(j0);
evalcond[3]=((5.01879418251366e-10)+(((0.0072)*(px*px*px)))+(((x896*x896)*(((7.776e-6)+(((-0.0005184)*pz))+(((2.8512e-9)*px))+(((-0.144)*(pz*pz*pz)))+(((-2.64e-7)*(px*px*px)))+(((4.4e-6)*pz*(px*px*px)))+(((0.216)*pz*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((0.01296)*(pz*pz)))+(((-1.32e-5)*px*(pz*pz*pz)))+(((-0.00648)*(px*px)))+(((-1.8)*(px*px)*(pz*pz)))+(((-1.4256e-7)*px*pz))+(((2.376e-6)*px*(pz*pz)))))*(IKsin(j0))))+(((-1.065734604e-15)*cj2*pz))+(((x897*x897)*(((-5.7024e-11)+(((-4.4e-6)*(pz*pz*pz*pz)))+(((1.584e-8)*(px*px)))+(((-0.00648)*px*pz))+(((3.8016e-9)*pz))+(((4.4e-6)*(px*px)*(pz*pz)))+(((-9.504e-8)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((-5.28e-7)*pz*(px*px)))+(((0.108)*px*(pz*pz)))+(((0.6)*pz*(px*px*px)))+(((0.0001296)*px))+(((-0.036)*(px*px*px)))+(((1.056e-6)*(pz*pz*pz)))))*(IKcos(j0))))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((3.3e-7)*pz*(py*py)))+(((-2.16442330632e-15)*sj2))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((3.3e-7)*(pz*pz*pz)))+(((-0.0146948907324612)*px*(pz*pz)))+(((-0.48)*px*(pz*pz*pz)))+(((-0.00018250160663686)*px))+(((-5.94e-8)*(pz*pz)))+(((-0.24)*pz*(px*px*px)))+(((-0.00048)*px*py*pz))+(((6.6e-10)*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((((8.48990360283382e-6)+(((-6.4589976e-9)*cj2*pz*(px*px)))+(((3.87539856e-10)*cj2*(px*px)))+(((-2.186286168e-7)*sj2*(pz*pz*pz)))+(((0.004)*py*pz*(px*px)))+(((-0.0216)*pz*(py*py)))+(((0.0321051092723788)*pz*(px*px)))+(((0.36)*(py*py)*(pz*pz)))+(((-0.000476335180141691)*pz))+(((-1.3951434816e-12)*cj2))+(((0.0100989196690282)*(pz*pz)))+(((-0.104105109272379)*(pz*pz*pz)))+(((-0.004)*py*(pz*pz*pz)))+(((-1.162619568e-9)*cj2*(pz*pz)))+(((-4.32e-5)*py*pz))+(((-0.12)*(px*px)*(py*py)))+(((-2.0)*(py*py)*(pz*pz*pz)))+(((-2.36118906144e-9)*pz*sj2))+(((2.0)*pz*(px*px)*(py*py)))+(((-0.00024)*py*(px*px)))+(((0.6)*(pz*pz*pz*pz)))+(((-2.0)*(pz*pz*pz*pz*pz)))+(((3.9353151024e-8)*sj2*(pz*pz)))+(((4.72237812288e-11)*sj2))+(((6.975717408e-11)*cj2*pz))+(((2.186286168e-7)*pz*sj2*(px*px)))+(((2.0)*pz*(px*px*px*px)))+(((6.4589976e-9)*cj2*(pz*pz*pz)))+(((-0.12)*(px*px*px*px)))+(((0.000432)*(py*py)))+(((8.64e-7)*py))+(((0.00072)*py*(pz*pz)))+(((-1.3117717008e-8)*sj2*(px*px)))+(((-0.00192630655634273)*(px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((-2.325239136e-11)*cj2*px))+(((3.3e-7)*pz*(px*px)))+(((-1.98e-8)*(py*py)))+(((-0.24)*px*pz*(py*py)))+(((-5.9886569708561e-9)*pz))+(((2.0)*(px*px*px)*(pz*pz)))+(((x898*x898)*(((-1.4256e-10)+(((-0.0108000000005808)*px*pz))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((-1.188e-7)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((0.000324000000017424)*px))+(((0.09000000000484)*px*(pz*pz)))))))+(((-1.98e-8)*(px*px)))+(((3.6073721772e-14)*pz*sj2))+(((x899*x899*x899)*(((((-0.0002592)*px))+(((0.01296)*px*pz))+(((1.2)*px*(pz*pz*pz)))+(((-0.216)*px*(pz*pz)))+(((-3.168e-8)*(px*px)))+(((1.056e-6)*pz*(px*px)))+(((-8.8e-6)*(px*px)*(pz*pz)))))))+(((((-2.73752409929154e-5)+(((-9.6884964e-10)*cj2*(pz*pz)))+(((-3.54453721165756e-9)*px))+(((-7.2e-5)*py*pz))+(((1.06595620194293e-7)*px*pz))+(((-3.487858704e-12)*cj2))+(((0.3)*(pz*pz*pz*pz)))+(((0.0006)*py*(pz*pz)))+(((0.00108)*(py*py)))+(((-2.64e-10)*px*py))+(((6.6e-6)*px*(pz*pz*pz)))+(((2.16e-6)*py))+(((2.4049147848e-13)*px*pz*sj2))+(((-1.32e-7)*(px*px*px)))+(((2.2e-6)*pz*(px*px*px)))+(((-0.072)*(pz*pz*pz)))+(((0.000782908033097182)*pz))+(((4.262938416e-16)*cj2*px))+(((-7.10489736e-15)*cj2*px*pz))+(((1.162619568e-10)*cj2*pz))+(((2.2e-6)*px*pz*(py*py)))+(((0.9)*(px*px)*(pz*pz)))+(((4.4e-9)*px*py*pz))+(((-0.036)*pz*(py*py)))+(((-1.32e-7)*px*(py*py)))+(((-1.188e-6)*px*(pz*pz)))+(((0.00324)*(px*px)))+(((-0.108)*pz*(px*px)))+(((1.18059453072e-10)*sj2))+(((-0.00220423360914318)*(pz*pz)))+(((-1.44294887088e-14)*px*sj2))+(((0.3)*(py*py)*(pz*pz)))+(((-3.9353151024e-9)*pz*sj2))+(((3.279429252e-8)*sj2*(pz*pz)))))*(IKsin(j0))))+(((6.394407624e-17)*cj2))+(((0.00521938688789534)*px*pz))+(((2.0)*px*(pz*pz*pz*pz)))+(((((-1.55648232699454e-10)+(((3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.000585854016548591)*px))+(((-2.2e-6)*(py*py)*(pz*pz)))+(((-8.525876832e-16)*cj2*pz))+(((2.5577630496e-17)*cj2))+(((7.10489736e-15)*cj2*(pz*pz)))+(((0.3)*px*pz*(py*py)))+(((-0.018)*(px*px*px)))+(((5.81309784e-11)*cj2*px))+(((-1.584e-11)*py))+(((-2.2e-6)*(pz*pz*pz*pz)))+(((5.28e-10)*py*pz))+(((-0.018)*px*(py*py)))+(((-4.4e-9)*py*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-0.0119242336091432)*px*pz))+(((2.88589774176e-14)*pz*sj2))+(((-2.4049147848e-13)*sj2*(pz*pz)))+(((6.13867442331512e-9)*pz))+(((-3.6e-5)*px*py))+(((0.3)*pz*(px*px*px)))+(((2.2e-6)*(px*px)*(pz*pz)))+(((-9.6884964e-10)*cj2*px*pz))+(((2.64e-7)*pz*(py*py)))+(((-8.65769322528e-16)*sj2))+(((-1.9676575512e-9)*px*sj2))+(((7.92e-9)*(px*px)))+(((-2.64e-7)*pz*(px*px)))+(((5.28e-7)*(pz*pz*pz)))+(((-8.28356201942927e-8)*(pz*pz)))+(((0.0006)*px*py*pz))+(((-7.92e-9)*(py*py)))))*(IKcos(j0))))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-3.96e-11)*py))+(((x900*x900)*(((-1.4256e-10)+(((4.650478272e-11)*cj2*px))+(((0.48)*pz*(px*px*px)))+(((0.48)*px*pz*(py*py)))+(((-0.008)*px*py*(pz*pz)))+(((-0.0606102185399176)*px*(pz*pz)))+(((6.6e-7)*pz*(px*px)))+(((7.128e-9)*pz))+(((4.10032132562966e-5)*px))+(((-1.188e-7)*(pz*pz)))+(((1.29179952e-8)*cj2*px*(pz*pz)))+(((5.2470868032e-8)*px*pz*sj2))+(((0.00096)*px*py*pz))+(((-2.88e-5)*px*py))+(((-1.550159424e-9)*cj2*px*pz))+(((-4.372572336e-7)*px*sj2*(pz*pz)))+(((-4.0)*px*(pz*pz*pz*pz)))+(((-0.0144)*(px*px*px)))+(((-1.57412604096e-9)*px*sj2))+(((-4.0)*px*(py*py)*(pz*pz)))+(((-3.96e-8)*(px*px)))+(((6.6e-7)*(pz*pz*pz)))+(((-4.0)*(px*px*px)*(pz*pz)))+(((-0.0144)*px*(py*py)))+(((0.96)*px*(pz*pz*pz)))+(((0.000361226224790112)*px*pz)))))));
IkReal x901=IKcos(j0);
IkReal x902=IKsin(j0);
IkReal x903=IKcos(j0);
IkReal x904=IKcos(j0);
IkReal x905=IKsin(j0);
evalcond[4]=((((-2.186286168e-7)*pz*sj2*(px*px)))+(((x901*x901)*(((((-0.24)*(px*px*px*px)))+(((-2.376e-9)*px))+(((-2.6235434016e-8)*sj2*(px*px)))+(((7.75079712e-10)*cj2*(px*px)))+(((-0.72)*(px*px)*(pz*pz)))+(((7.92e-8)*px*pz))+(((4.0)*(px*px)*(pz*pz*pz)))+(((4.0)*pz*(px*px)*(py*py)))+(((-0.00048)*py*(px*px)))+(((0.000683386887604944)*(px*px)))+(((-6.6e-7)*px*(pz*pz)))+(((-1.29179952e-8)*cj2*pz*(px*px)))+(((4.0)*pz*(px*px*px*px)))+(((-0.24)*(px*px)*(py*py)))+(((0.0174102185399176)*pz*(px*px)))+(((0.008)*py*pz*(px*px)))+(((-6.6e-7)*(px*px*px)))+(((4.372572336e-7)*pz*sj2*(px*px)))))))+(((x902*x902)*(((((0.00216)*(px*px)))+(((4.752e-8)*px*pz))+(((-9.504e-10)*px))+(((-0.6)*(px*px*px*px)))+(((2.64e-7)*(px*px*px)))+(((-7.92e-7)*px*(pz*pz)))+(((4.4e-6)*px*(pz*pz*pz)))+(((-4.4e-6)*pz*(px*px*px)))+(((-0.072)*pz*(px*px)))+(((0.6)*(px*px)*(pz*pz)))))*(IKcos(j0))))+(((((((5.90756201942927e-8)*px*pz))+(((0.00976423360914318)*(px*px)))+(((-2.64e-10)*px*py))+(((-3.96e-7)*px*(pz*pz)))+(((2.4049147848e-13)*px*pz*sj2))+(((0.3)*(px*px)*(pz*pz)))+(((-0.0006)*py*(px*px)))+(((-0.3)*(px*px)*(py*py)))+(((-0.036)*pz*(px*px)))+(((4.262938416e-16)*cj2*px))+(((-0.3)*(px*px*px*px)))+(((-7.10489736e-15)*cj2*px*pz))+(((2.2e-6)*px*pz*(py*py)))+(((4.4e-9)*px*py*pz))+(((-1.32e-7)*px*(py*py)))+(((2.2e-6)*px*(pz*pz*pz)))+(((-2.2e-6)*pz*(px*px*px)))+(((9.6884964e-10)*cj2*(px*px)))+(((-2.59413721165756e-9)*px))+(((1.32e-7)*(px*px*px)))+(((-1.44294887088e-14)*px*sj2))+(((-3.279429252e-8)*sj2*(px*px)))))*(IKcos(j0))))+(((0.00024)*py*(px*px)))+(((x903*x903)*(((((-0.00648)*px*pz))+(((1.8)*pz*(px*px*px)))+(((1.32e-5)*(px*px)*(pz*pz)))+(((-0.6)*px*(pz*pz*pz)))+(((0.108)*px*(pz*pz)))+(((-4.4e-6)*(px*px*px*px)))+(((-1.584e-6)*pz*(px*px)))+(((0.0001296)*px))+(((-0.108)*(px*px*px)))+(((4.752e-8)*(px*px)))))*(IKsin(j0))))+(((-3.3e-7)*px*(pz*pz)))+(((-3.3e-7)*px*(py*py)))+(((-3.6073721772e-14)*px*sj2))+(((-3.87539856e-10)*cj2*(px*px)))+(((-6.6e-10)*px*py))+(((6.4589976e-9)*cj2*pz*(px*px)))+(((1.3117717008e-8)*sj2*(px*px)))+(((0.0362948907324612)*pz*(px*px)))+(((-2.0)*pz*(px*px*px*px)))+(((3.96e-8)*px*pz))+(((x904*x904*x904)*(((((-0.00432)*(px*px)))+(((-1.2)*(px*px)*(pz*pz)))+(((-5.28e-7)*(px*px*px)))+(((8.8e-6)*pz*(px*px*px)))+(((0.144)*pz*(px*px)))))))+(((-2.0)*(px*px)*(pz*pz*pz)))+(((0.36)*(px*px)*(pz*pz)))+(((((((-0.00558061311268546)*px*pz))+(((-2.186286168e-7)*sj2*(px*px*px)))+(((-2.0)*(px*px*px)*(py*py)))+(((0.0072)*px*(py*py)))+(((2.186286168e-7)*px*sj2*(pz*pz)))+(((2.0)*px*(py*py)*(pz*pz)))+(((0.0753051092723788)*px*(pz*pz)))+(((-2.6235434016e-8)*px*pz*sj2))+(((7.75079712e-10)*cj2*px*pz))+(((-0.48)*px*(pz*pz*pz)))+(((0.000141498393380564)*px))+(((-0.004)*py*(px*px*px)))+(((-0.00048)*px*py*pz))+(((-6.4589976e-9)*cj2*px*(pz*pz)))+(((-2.325239136e-11)*cj2*px))+(((-0.24)*px*pz*(py*py)))+(((6.4589976e-9)*cj2*(px*px*px)))+(((-0.0321051092723788)*(px*px*px)))+(((2.0)*px*(pz*pz*pz*pz)))+(((1.44e-5)*px*py))+(((0.004)*px*py*(pz*pz)))+(((7.8706302048e-10)*px*sj2))+(((-2.0)*(px*px*px*px*px)))))*(IKcos(j0))*(IKsin(j0))))+(((0.12)*(px*px)*(py*py)))+(((8.3646569708561e-9)*px))+(((-2.0)*pz*(px*px)*(py*py)))+(((-0.00304169344394767)*(px*px)))+(((x905*x905)*(((((-2.376e-9)*px))+(((7.92e-8)*px*pz))+(((-6.6e-7)*px*(pz*pz)))+(((-6.6e-7)*(px*px*px)))+(((0.0054000000002904)*(px*px)))+(((-0.09000000000484)*pz*(px*px)))))))+(((1.065734604e-15)*cj2*px))+(((0.12)*(px*px*px*px)))+(((((((-2.2e-6)*(px*px*px*px)))+(((-3.279429252e-8)*px*pz*sj2))+(((-0.3)*px*(pz*pz*pz)))+(((0.00544423360914318)*px*pz))+(((-0.9)*pz*(px*px*px)))+(((-6.6e-6)*(px*px)*(pz*pz)))+(((0.054)*px*(pz*pz)))+(((-5.90756201942927e-8)*(px*px)))+(((-2.2e-6)*(px*px)*(py*py)))+(((1.9676575512e-9)*px*sj2))+(((7.92e-7)*pz*(px*px)))+(((9.6884964e-10)*cj2*px*pz))+(((3.6e-5)*px*py))+(((-0.3)*px*pz*(py*py)))+(((-5.81309784e-11)*cj2*px))+(((-0.0006)*px*py*pz))+(((7.10489736e-15)*cj2*(px*px)))+(((0.054)*(px*px*px)))+(((-4.4e-9)*py*(px*px)))+(((0.018)*px*(py*py)))+(((-2.4049147848e-13)*sj2*(px*px)))+(((-0.000456254016548591)*px))))*(IKsin(j0))))+(((-0.004)*py*pz*(px*px)))+(((-3.3e-7)*(px*px*px))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x906=px*px;
IkReal x907=pz*pz;
IkReal x908=(cj0*px);
IkReal x909=(px*sj0);
IkReal x910=(pz*sj0);
IkReal x911=(cj0*pz);
j1eval[0]=((-197727.272736439)+(((-136363.636363636)*cj0))+(((-7575757.57575758)*x906))+(((-7575757.57575758)*x907))+sj0+(((-16.6666666666667)*x908))+(((-16.6666666666667)*x910))+(((-2272727.27272727)*x909))+(((909090.909090909)*pz))+(((2272727.27272727)*x911)));
j1eval[1]=IKsign(((-522.0000000242)+(((-0.044)*x910))+(((2400.0)*pz))+(((0.00264)*sj0))+(((-0.044)*x908))+(((6000.0)*x911))+(((-20000.0)*x906))+(((-20000.0)*x907))+(((-360.0)*cj0))+(((-6000.0)*x909))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x912=pz*pz;
IkReal x913=px*px;
IkReal x914=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x915=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x916=((-197727.272736439)+(((-7575757.57575758)*x913))+(((-7575757.57575758)*x912))+(((909090.909090909)*pz)));
IkReal x917=((x915*x915)+(x914*x914));
if((((18595041323.314)+(((5165289256476.13)*x912))+(((5165289256476.13)*x913))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x918=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x912))+(((5165289256476.13)*x913))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x924=IKPowWithIntegerCheck(x918,-1);
if(!x924.valid){
continue;
}
IkReal x919=x924.value;
IkReal x925 = x917;
if(IKabs(x925)==0){
continue;
}
IkReal x920=pow(x925,-0.5);
IkReal x921=((1.0)*x920);
IkReal x922=(x916*x919);
if((((1.0)+(((-1.0)*(x922*x922))))) < -0.00001)
continue;
IkReal x923=IKsqrt(((1.0)+(((-1.0)*(x922*x922)))));
if((x917) < -0.00001)
continue;
CheckValue<IkReal> x926=IKPowWithIntegerCheck(IKabs(IKsqrt(x917)),-1);
if(!x926.valid){
continue;
}
if( ((x916*(x926.value))) < -1-IKFAST_SINCOS_THRESH || ((x916*(x926.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x927 = IKatan2WithCheck(IkReal(x914),IkReal(x915),IKFAST_ATAN2_MAGTHRESH);
if(!x927.valid){
continue;
}
IkReal gconst28=((((-1.0)*(IKasin((x916*(x926.value))))))+(((-1.0)*(x927.value))));
IkReal gconst29=((((-1.0)*x914*x921*x923))+(((-1.0)*x915*x921*x922)));
IkReal gconst30=((((-1.0)*x914*x921*x922))+((x915*x920*x923)));
IkReal x928=pz*pz;
IkReal x929=px*px;
if((((18595041323.314)+(((5165289256476.13)*x928))+(((5165289256476.13)*x929))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
CheckValue<IkReal> x932=IKPowWithIntegerCheck(IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x928))+(((5165289256476.13)*x929))+(((-619834710777.135)*pz))))),-1);
if(!x932.valid){
continue;
}
IkReal x930=x932.value;
IkReal x931=((7575757.57575758)*x930);
if( ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) < -1-IKFAST_SINCOS_THRESH || ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x933 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x933.valid){
continue;
}
CheckValue<IkReal> x934 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x934.valid){
continue;
}
if( ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) < -1-IKFAST_SINCOS_THRESH || ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x935 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x935.valid){
continue;
}
CheckValue<IkReal> x936 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x936.valid){
continue;
}
CheckValue<IkReal> x937 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x937.valid){
continue;
}
CheckValue<IkReal> x938 = IKatan2WithCheck(IkReal(((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)))),IkReal(((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x938.valid){
continue;
}
if( ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) < -1-IKFAST_SINCOS_THRESH || ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) < -1-IKFAST_SINCOS_THRESH || ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) < -1-IKFAST_SINCOS_THRESH || ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if( ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) < -1-IKFAST_SINCOS_THRESH || ((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if(((((j0*(j0)))+(((-1.0)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))*(x933.value)))+(((-1.0)*(x934.value)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))))+(((x935.value)*(x936.value)))+((j0*(x937.value)))+(((x938.value)*(j0)))+(((-1.0)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))*(j0)))+(((-1.0)*j0*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))))+(((1.0)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930))))))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt((((j0*(j0)))+(((-1.0)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))*(x933.value)))+(((-1.0)*(x934.value)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))))+(((x935.value)*(x936.value)))+((j0*(x937.value)))+(((x938.value)*(j0)))+(((-1.0)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))*(j0)))+(((-1.0)*j0*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))))+(((1.0)*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930)))))*(IKasin((((x928*x931))+(((197727.272736439)*x930))+((x929*x931))+(((-909090.909090909)*pz*x930))))))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x939=gconst30*gconst30;
IkReal x940=gconst29*gconst29;
IkReal x941=px*px;
IkReal x942=pz*pz;
IkReal x943=((2400.0)*pz);
IkReal x944=(gconst29*px);
IkReal x945=((1657.72300388932)*sj2);
IkReal x946=(gconst30*px);
IkReal x947=((590.86479112738)*py);
IkReal x948=((99.4633802333595)*sj2);
IkReal x949=(gconst30*pz);
IkReal x950=((35.4518874676428)*py);
IkReal x951=(gconst29*pz);
IkReal x952=((20000.0)*x941);
IkReal x953=((20000.0)*x942);
CheckValue<IkReal> x954=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((-6000.0)*x944))+(((-72.0)*x939))+(((-1.0)*x940*x953))+(((-1.0)*x940*x952))+(((0.00264)*gconst29))+((x939*x943))+(((-72.0)*x940))+(((-360.0)*gconst30))+(((-1.0)*x939*x952))+(((-1.0)*x939*x953))+(((-0.044)*x951))+(((6000.0)*x949))+(((-0.044)*x946))+((x940*x943)))),-1);
if(!x954.valid){
continue;
}
CheckValue<IkReal> x955 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((0.57766479112738)*x949))+((x945*x949))+(((-1.0)*gconst30*x950))+(((4223.0)*x946))+((x947*x949))+(((-253.38)*gconst29))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst30))+(((4223.0)*x951))+(((-0.57766479112738)*x944))+(((-1.0)*x944*x945))+(((-1.0)*x944*x947))+(((-1.0)*gconst30*x948)))),IkReal(((633.450000635431)+(((0.57766479112738)*x946))+((x946*x947))+(((-1.0)*gconst29*x948))+(((253.38)*gconst30))+((x945*x946))+(((4223.0)*x944))+(((-0.0346598874676428)*gconst29))+(((-1.0)*gconst29*x950))+(((0.57766479112738)*x951))+((x947*x951))+(((0.00182349530427826)*sj2))+((x945*x951))+(((-4223.0)*x949))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x955.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x954.value)))+(x955.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x956=IKcos(j1);
IkReal x957=IKsin(j1);
IkReal x958=((0.12)*pz);
IkReal x959=pz*pz;
IkReal x960=gconst30*gconst30;
IkReal x961=px*px;
IkReal x962=((1.32e-7)*gconst29);
IkReal x963=(gconst29*gconst30);
IkReal x964=(px*pz);
IkReal x965=(gconst29*pz);
IkReal x966=(gconst30*px);
IkReal x967=(gconst29*px);
IkReal x968=((0.24)*pz);
IkReal x969=((0.018)*gconst30);
IkReal x970=(gconst30*pz);
IkReal x971=((0.24)*px);
IkReal x972=((0.12)*px);
IkReal x973=((0.06)*gconst29);
IkReal x974=x956*x956;
IkReal x975=((2.2e-6)*x965);
IkReal x976=((2.2e-6)*x966);
IkReal x977=((1.0)*x959);
IkReal x978=((1.0)*x956);
IkReal x979=((1.0)*x961);
IkReal x980=((1.32e-6)*x956);
IkReal x981=((1.0)*x957);
IkReal x982=(gconst30*x957);
IkReal x983=(x962+x958);
IkReal x984=(x956*x957);
IkReal x985=(x957*x970);
IkReal x986=((2.2e-6)*x974);
IkReal x987=((0.3)*x974);
IkReal x988=((2.0)*x984);
IkReal x989=(x959*x974);
IkReal x990=(x960*x974);
IkReal x991=(x975+x977+x976);
evalcond[0]=((-0.21115)+(((-1.0)*x965*x981))+(((-0.15)*x956))+(((-0.06)*gconst30*x956))+(((-1.0)*x966*x981))+(((-1.0)*x967*x978))+((x956*x970))+((x957*x973))+(((-1.1e-6)*x957)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x965*x978))+(((0.06)*x982))+(((-1.0)*x966*x978))+(((-0.029543239556369)*py))+(((-1.0)*x970*x981))+(((-0.0828861501944662)*sj2))+((x957*x967))+((x956*x973))+(((0.15)*x957))+(((-1.1e-6)*x956)));
evalcond[2]=((0.0253474453653594)+(((-1.32e-6)*x957*x967))+(((0.3)*x970))+((x965*x980))+(((-1.0)*x991))+((x966*x980))+(((-7.92e-8)*gconst29*x956))+(((1.452e-12)*x956))+(((-7.92e-8)*x982))+(((-1.98e-7)*x957))+(((-1.0)*(py*py)))+x983+(((-1.0)*x969))+(((-0.3)*x967))+(((-1.0)*x979))+(((1.32e-6)*x985))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+((x972*x984))+(((-2.0)*x960*x989))+((x959*x963*x988))+(((2.0)*x961*x990))+(((0.0072)*x963*x984))+(((-1.0)*x969*x974))+(((4.0)*x963*x964*x974))+(((-2.0)*x963*x964))+(((-1.0)*x962*x974))+(((-0.01889999999879)*x974))+((x968*x990))+(((-1.32e-7)*x956*x982))+(((-0.3)*x965*x984))+(((-1.0)*x963*x971*x974))+((x963*x972))+(((-1.0)*x974*x979))+(((-1.0)*x967*x987))+(((-1.0)*x958*x974))+(((-0.0072)*x990))+(((-1.0)*x991))+(((-1.0)*x958*x960))+(((-1.0)*x964*x988))+(((-1.0)*x960*x971*x984))+((x959*x960))+(((0.018)*gconst29*x984))+(((0.0036)*x960))+((x974*x975))+((x974*x976))+(((2.2e-6)*x970*x984))+(((4.0)*x960*x964*x984))+(((-1.0)*x963*x968*x984))+(((-1.0)*x961*x963*x988))+x989+x983+((x970*x987))+(((-0.3)*x966*x984))+(((-2.2e-6)*x967*x984))+(((-1.0)*x960*x979))+(((-3.3e-7)*x984)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x992=(cj1*gconst29);
IkReal x993=((0.0295301092415339)*sj2);
IkReal x994=((0.999563891228661)*cj2);
IkReal x995=(gconst30*sj1);
IkReal x996=((((-1.0)*gconst29*sj1))+((cj1*gconst30)));
IkReal x997=(((x993*x995))+((x994*x995))+((x992*x994))+((x992*x993)));
CheckValue<IkReal> x1000 = IKatan2WithCheck(IkReal(x996),IkReal(x997),IKFAST_ATAN2_MAGTHRESH);
if(!x1000.valid){
continue;
}
IkReal x998=((1.0)*(x1000.value));
if((((x996*x996)+(x997*x997))) < -0.00001)
continue;
CheckValue<IkReal> x1001=IKPowWithIntegerCheck(IKabs(IKsqrt(((x996*x996)+(x997*x997)))),-1);
if(!x1001.valid){
continue;
}
if( (((x1001.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x1001.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x999=IKasin(((x1001.value)*(IKcos(r00))));
j3array[0]=((((-1.0)*x998))+x999);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x999))+(((-1.0)*x998)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1002=pz*pz;
IkReal x1003=px*px;
IkReal x1004=((-136363.636363636)+(((-16.6666666666667)*px))+(((2272727.27272727)*pz)));
IkReal x1005=((1.0)+(((-2272727.27272727)*px))+(((-16.6666666666667)*pz)));
IkReal x1006=((-197727.272736439)+(((-7575757.57575758)*x1003))+(((-7575757.57575758)*x1002))+(((909090.909090909)*pz)));
IkReal x1007=x1006*x1006;
IkReal x1008=((x1004*x1004)+(x1005*x1005));
if((((18595041323.314)+(((5165289256476.13)*x1002))+(((5165289256476.13)*x1003))+(((-619834710777.135)*pz)))) < -0.00001)
continue;
IkReal x1009=IKabs(IKsqrt(((18595041323.314)+(((5165289256476.13)*x1002))+(((5165289256476.13)*x1003))+(((-619834710777.135)*pz)))));
CheckValue<IkReal> x1016=IKPowWithIntegerCheck(x1009,-1);
if(!x1016.valid){
continue;
}
IkReal x1010=x1016.value;
IkReal x1017 = x1008;
if(IKabs(x1017)==0){
continue;
}
IkReal x1011=pow(x1017,-0.5);
CheckValue<IkReal> x1018=IKPowWithIntegerCheck(x1009,-2);
if(!x1018.valid){
continue;
}
IkReal x1012=x1018.value;
IkReal x1013=((1.0)*x1011);
IkReal x1014=(x1006*x1010);
IkReal x1015=(x1007*x1012);
CheckValue<IkReal> x1019 = IKatan2WithCheck(IkReal(x1004),IkReal(x1005),IKFAST_ATAN2_MAGTHRESH);
if(!x1019.valid){
continue;
}
if((x1008) < -0.00001)
continue;
CheckValue<IkReal> x1020=IKPowWithIntegerCheck(IKabs(IKsqrt(x1008)),-1);
if(!x1020.valid){
continue;
}
if( ((x1006*(x1020.value))) < -1-IKFAST_SINCOS_THRESH || ((x1006*(x1020.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst31=((3.14159265358979)+(((-1.0)*(x1019.value)))+(IKasin((x1006*(x1020.value)))));
if((((1.0)+(((-1.0)*x1015)))) < -0.00001)
continue;
IkReal gconst32=((((-1.0)*x1005*x1013*x1014))+((x1004*x1013*(IKsqrt(((1.0)+(((-1.0)*x1015))))))));
if((((1.0)+(((-1.0)*x1015)))) < -0.00001)
continue;
IkReal gconst33=((((-1.0)*x1004*x1013*x1014))+(((-1.0)*x1005*x1013*(IKsqrt(((1.0)+(((-1.0)*x1015))))))));
IkReal x1021=x1004;
IkReal x1022=x1005;
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1023=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1023.valid){
continue;
}
if( (((x1023.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1023.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1024 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1024.valid){
continue;
}
CheckValue<IkReal> x1025 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1025.valid){
continue;
}
CheckValue<IkReal> x1026 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1026.valid){
continue;
}
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1027=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1027.valid){
continue;
}
if( (((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1028 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1028.valid){
continue;
}
CheckValue<IkReal> x1029 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1029.valid){
continue;
}
CheckValue<IkReal> x1030 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1030.valid){
continue;
}
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1031=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1031.valid){
continue;
}
if( (((x1031.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1031.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1032=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1032.valid){
continue;
}
if( (((x1032.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1032.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1033 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1033.valid){
continue;
}
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1034=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1034.valid){
continue;
}
if( (((x1034.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1034.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1035=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1035.valid){
continue;
}
if( (((x1035.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1035.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1036=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1036.valid){
continue;
}
if( (((x1036.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1036.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
if((((x1021*x1021)+(x1022*x1022))) < -0.00001)
continue;
CheckValue<IkReal> x1037=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1021*x1021)+(x1022*x1022)))),-1);
if(!x1037.valid){
continue;
}
if( (((x1037.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) < -1-IKFAST_SINCOS_THRESH || (((x1037.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1038 = IKatan2WithCheck(IkReal(x1021),IkReal(x1022),IKFAST_ATAN2_MAGTHRESH);
if(!x1038.valid){
continue;
}
if((((9.86960440108936)+((j0*(j0)))+(((-1.0)*(IKasin(((x1023.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+(((-3.14159265358979)*(x1024.value)))+(((-3.14159265358979)*(x1025.value)))+((j0*(x1026.value)))+(((3.14159265358979)*(IKasin(((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((x1028.value)*(x1029.value)))+(((-1.0)*(x1030.value)*(IKasin(((x1031.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x1032.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(j0)))+(((x1033.value)*(j0)))+(((-1.0)*j0*(IKasin(((x1034.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*j0))+(((1.0)*(IKasin(((x1035.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x1036.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x1037.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x1038.value))))) < -0.00001)
continue;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKsqrt(((9.86960440108936)+((j0*(j0)))+(((-1.0)*(IKasin(((x1023.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(j0)))+(((-3.14159265358979)*(x1024.value)))+(((-3.14159265358979)*(x1025.value)))+((j0*(x1026.value)))+(((3.14159265358979)*(IKasin(((x1027.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((x1028.value)*(x1029.value)))+(((-1.0)*(x1030.value)*(IKasin(((x1031.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((3.14159265358979)*(IKasin(((x1032.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*(j0)))+(((x1033.value)*(j0)))+(((-1.0)*j0*(IKasin(((x1034.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-3.14159265358979)*j0))+(((1.0)*(IKasin(((x1035.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(IKasin(((x1036.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))))+(((-1.0)*(IKasin(((x1037.value)*(((-197727.272736439)+(((-7575757.57575758)*(pz*pz)))+(((-7575757.57575758)*(px*px)))+(((909090.909090909)*pz)))))))*(x1038.value))))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1039=gconst33*gconst33;
IkReal x1040=gconst32*gconst32;
IkReal x1041=pz*pz;
IkReal x1042=px*px;
IkReal x1043=(gconst32*pz);
IkReal x1044=((590.86479112738)*py);
IkReal x1045=(gconst33*pz);
IkReal x1046=((2400.0)*pz);
IkReal x1047=(gconst32*px);
IkReal x1048=((35.4518874676428)*py);
IkReal x1049=((99.4633802333595)*sj2);
IkReal x1050=(gconst33*px);
IkReal x1051=((1657.72300388932)*sj2);
IkReal x1052=((20000.0)*x1042);
IkReal x1053=((20000.0)*x1041);
CheckValue<IkReal> x1054 = IKatan2WithCheck(IkReal(((-0.082004418669107)+(((-88.629718669107)*py))+(((-1.0)*gconst33*x1048))+(((-1.0)*gconst33*x1049))+(((-253.38)*gconst32))+(((-1.0)*x1044*x1047))+(((-0.57766479112738)*x1047))+(((4223.0)*x1043))+(((0.57766479112738)*x1045))+(((4223.0)*x1050))+(((-248.658450583399)*sj2))+(((-0.0346598874676428)*gconst33))+((x1045*x1051))+(((-1.0)*x1047*x1051))+((x1044*x1045)))),IkReal(((633.450000635431)+((x1044*x1050))+((x1043*x1051))+((x1043*x1044))+(((-1.0)*gconst32*x1048))+(((-1.0)*gconst32*x1049))+(((253.38)*gconst33))+(((0.57766479112738)*x1050))+(((4223.0)*x1047))+(((0.57766479112738)*x1043))+(((-0.0346598874676428)*gconst32))+((x1050*x1051))+(((0.00182349530427826)*sj2))+(((-4223.0)*x1045))+(((0.000649951270240118)*py)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1054.valid){
continue;
}
CheckValue<IkReal> x1055=IKPowWithIntegerCheck(IKsign(((-450.0000000242)+(((0.00264)*gconst32))+((x1040*x1046))+((x1039*x1046))+(((-1.0)*x1039*x1053))+(((-1.0)*x1039*x1052))+(((-72.0)*x1039))+(((-360.0)*gconst33))+(((-6000.0)*x1047))+(((-1.0)*x1040*x1052))+(((-1.0)*x1040*x1053))+(((-72.0)*x1040))+(((6000.0)*x1045))+(((-0.044)*x1043))+(((-0.044)*x1050)))),-1);
if(!x1055.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1054.value)+(((1.5707963267949)*(x1055.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1056=IKsin(j1);
IkReal x1057=IKcos(j1);
IkReal x1058=((0.12)*pz);
IkReal x1059=gconst33*gconst33;
IkReal x1060=px*px;
IkReal x1061=pz*pz;
IkReal x1062=((1.32e-7)*gconst32);
IkReal x1063=(gconst33*px);
IkReal x1064=((2.2e-6)*gconst32);
IkReal x1065=(gconst32*pz);
IkReal x1066=((0.018)*gconst33);
IkReal x1067=((1.0)*pz);
IkReal x1068=((0.3)*px);
IkReal x1069=(px*pz);
IkReal x1070=(gconst33*pz);
IkReal x1071=x1057*x1057;
IkReal x1072=((2.2e-6)*x1063);
IkReal x1073=(pz*x1064);
IkReal x1074=((1.0)*x1061);
IkReal x1075=(gconst32*x1056);
IkReal x1076=((1.0)*x1057);
IkReal x1077=(gconst33*x1056);
IkReal x1078=((1.0)*x1060);
IkReal x1079=(gconst33*x1057);
IkReal x1080=((2.0)*gconst32*gconst33);
IkReal x1081=((0.24)*x1059);
IkReal x1082=((1.32e-6)*x1057);
IkReal x1083=(gconst32*x1057);
IkReal x1084=(x1058+x1062);
IkReal x1085=(x1056*x1057);
IkReal x1086=(pz*x1071);
IkReal x1087=(gconst32*x1071);
IkReal x1088=(x1061*x1071);
IkReal x1089=(x1059*x1071);
IkReal x1090=(x1074+x1072+x1073);
evalcond[0]=((-0.21115)+(((-1.0)*x1056*x1063))+(((-1.0)*x1056*x1065))+(((-0.06)*x1079))+(((0.06)*x1075))+((x1057*x1070))+(((-1.1e-6)*x1056))+(((-1.0)*gconst32*px*x1076))+(((-0.15)*x1057)));
evalcond[1]=((-2.8883239556369e-5)+(((-1.0)*x1063*x1076))+(((0.06)*x1083))+((px*x1075))+(((0.06)*x1077))+(((-0.029543239556369)*py))+(((-1.1e-6)*x1057))+(((-0.0828861501944662)*sj2))+(((-1.0)*x1067*x1077))+(((0.15)*x1056))+(((-1.0)*x1065*x1076)));
evalcond[2]=((0.0253474453653594)+(((-7.92e-8)*x1077))+(((0.3)*x1070))+x1084+(((-1.98e-7)*x1056))+((x1063*x1082))+(((-1.0)*x1090))+(((-7.92e-8)*x1083))+(((-1.32e-6)*px*x1075))+(((1.32e-6)*x1056*x1070))+(((-1.0)*x1066))+(((-1.0)*(py*py)))+(((-1.0)*x1078))+((x1065*x1082))+(((1.452e-12)*x1057))+(((-1.0)*gconst32*x1068))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-2.0)*x1060*x1075*x1079))+(((-0.01889999999879)*x1071))+(((-3.3e-7)*x1085))+(((-2.0)*x1059*x1088))+(((0.12)*gconst32*x1063))+(((-2.0)*x1069*x1085))+x1084+x1088+(((2.0)*x1061*x1075*x1079))+((x1081*x1086))+(((0.0072)*x1075*x1079))+(((-1.0)*x1071*x1078))+((x1071*x1073))+((x1071*x1072))+(((4.0)*x1059*x1069*x1085))+(((-1.0)*x1059*x1078))+(((0.0036)*x1059))+(((-1.0)*x1058*x1059))+(((-1.0)*px*x1081*x1085))+(((-1.0)*x1090))+(((0.018)*x1057*x1075))+(((-0.24)*x1057*x1065*x1077))+(((-1.0)*x1068*x1087))+(((-1.0)*px*x1064*x1085))+(((-1.0)*x1062*x1071))+(((-1.0)*x1058*x1071))+(((-0.3)*x1063*x1085))+(((0.3)*x1070*x1071))+(((2.2e-6)*x1070*x1085))+(((-0.24)*x1063*x1087))+(((-0.0072)*x1089))+(((2.0)*x1060*x1089))+(((-1.32e-7)*x1057*x1077))+(((-1.0)*x1066*x1071))+(((0.12)*px*x1085))+((x1059*x1061))+(((-2.0)*x1063*x1065))+(((-0.3)*x1065*x1085))+(((4.0)*x1063*x1065*x1071)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x1091=(cj1*gconst32);
IkReal x1092=((0.0295301092415339)*sj2);
IkReal x1093=((0.999563891228661)*cj2);
IkReal x1094=(gconst33*sj1);
IkReal x1095=((((-1.0)*gconst32*sj1))+((cj1*gconst33)));
IkReal x1096=(((x1092*x1094))+((x1093*x1094))+((x1091*x1093))+((x1091*x1092)));
CheckValue<IkReal> x1099 = IKatan2WithCheck(IkReal(x1095),IkReal(x1096),IKFAST_ATAN2_MAGTHRESH);
if(!x1099.valid){
continue;
}
IkReal x1097=((1.0)*(x1099.value));
if((((x1096*x1096)+(x1095*x1095))) < -0.00001)
continue;
CheckValue<IkReal> x1100=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1096*x1096)+(x1095*x1095)))),-1);
if(!x1100.valid){
continue;
}
if( (((x1100.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x1100.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1098=IKasin(((x1100.value)*(IKcos(r00))));
j3array[0]=(x1098+(((-1.0)*x1097)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x1097))+(((-1.0)*x1098)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1101=((4223.0)*pz);
IkReal x1102=((0.0132)*px);
IkReal x1103=((48.9318)*cj2);
IkReal x1104=(pz*sj0);
IkReal x1105=((2.935908)*cj2);
IkReal x1106=(cj0*px);
IkReal x1107=((1656.2774)*sj2);
IkReal x1108=(px*sj0);
IkReal x1109=(cj0*pz);
IkReal x1110=((99.376644)*sj2);
CheckValue<IkReal> x1111=IKPowWithIntegerCheck(IKsign(((-522.0000000242)+(((2400.0)*pz))+(((0.00264)*sj0))+(((-20000.0)*(pz*pz)))+(((-360.0)*cj0))+(((-20000.0)*(px*px)))+(((-0.044)*x1106))+(((-0.044)*x1104))+(((6000.0)*x1109))+(((-6000.0)*x1108)))),-1);
if(!x1111.valid){
continue;
}
CheckValue<IkReal> x1112 = IKatan2WithCheck(IkReal(((0.0066253)+(((-1.0)*x1103*x1109))+(((-253.38)*sj0))+(((-0.0132)*x1109))+(((4223.0)*x1106))+(((0.000792)*cj0))+(((-248.44161)*sj2))+(((-1.0)*x1107*x1108))+((sj0*x1101))+((sj0*x1102))+((x1103*x1108))+((x1107*x1109))+(((7.33977)*cj2))+((cj0*x1105))+(((-1.0)*cj0*x1110)))),IkReal(((633.44999998548)+(((-1.0)*sj0*x1110))+(((-1.0)*x1103*x1104))+(((-1.0)*x1103*x1106))+(((-0.0132)*x1104))+(((4223.0)*x1108))+(((253.38)*cj0))+(((-5.382498e-5)*cj2))+(((0.00182190514)*sj2))+((x1104*x1107))+((sj0*x1105))+(((0.000792)*sj0))+((x1106*x1107))+(((-1.0)*cj0*x1101))+(((-1.0)*cj0*x1102)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1112.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1111.value)))+(x1112.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x1113=IKcos(j1);
IkReal x1114=IKsin(j1);
IkReal x1115=((0.12)*pz);
IkReal x1116=cj0*cj0;
IkReal x1117=pz*pz;
IkReal x1118=px*px;
IkReal x1119=((1.32e-7)*sj0);
IkReal x1120=(cj0*px);
IkReal x1121=((2.2e-6)*pz);
IkReal x1122=((0.3)*pz);
IkReal x1123=((0.3)*px);
IkReal x1124=(pz*sj0);
IkReal x1125=((0.24)*pz);
IkReal x1126=((4.0)*pz);
IkReal x1127=x1113*x1113;
IkReal x1128=((2.2e-6)*x1120);
IkReal x1129=(sj0*x1121);
IkReal x1130=((1.0)*x1117);
IkReal x1131=((1.0)*x1114);
IkReal x1132=((1.32e-6)*x1113);
IkReal x1133=(cj0*x1114);
IkReal x1134=(sj0*x1113);
IkReal x1135=(sj0*x1114);
IkReal x1136=(cj0*x1113);
IkReal x1137=(px*x1116);
IkReal x1138=((1.0)*x1118);
IkReal x1139=(x1115+x1119);
IkReal x1140=(x1113*x1114);
IkReal x1141=(x1116*x1117);
IkReal x1142=(sj0*x1127);
IkReal x1143=(cj0*x1127);
IkReal x1144=(x1118*x1127);
IkReal x1145=(x1116*x1127);
IkReal x1146=(x1128+x1129+x1130);
evalcond[0]=((-0.21115)+(((-0.06)*x1136))+(((-1.1e-6)*x1114))+(((-0.15)*x1113))+(((-1.0)*px*x1134))+((pz*x1136))+(((-1.0)*x1120*x1131))+(((0.06)*x1135))+(((-1.0)*x1124*x1131)));
evalcond[1]=((6.6e-7)+(((-1.0)*cj0*pz*x1131))+(((-1.1e-6)*x1113))+(((0.00244659)*cj2))+(((-0.08281387)*sj2))+(((0.15)*x1114))+((px*x1135))+(((-1.0)*x1113*x1120))+(((-1.0)*x1113*x1124))+(((0.06)*x1134))+(((0.06)*x1133)));
evalcond[2]=((0.0253474453653594)+x1139+((cj0*x1122))+((x1120*x1132))+(((-1.0)*x1146))+((x1124*x1132))+(((-1.0)*x1138))+(((1.32e-6)*pz*x1133))+(((-1.0)*sj0*x1123))+(((-7.92e-8)*x1133))+(((-7.92e-8)*x1134))+(((-1.98e-7)*x1114))+(((-1.0)*(py*py)))+(((1.452e-12)*x1113))+(((-0.018)*cj0))+(((-1.32e-6)*px*x1135))+(((-0.002)*py)));
evalcond[3]=((0.04098432249879)+(((-2.0)*x1118*x1133*x1134))+(((2.0)*x1116*x1144))+(((-1.32e-7)*x1113*x1133))+((x1127*x1129))+((x1127*x1128))+(((-0.0072)*x1145))+x1141+x1139+(((-0.3)*x1120*x1140))+(((-2.0)*x1120*x1124))+(((-0.24)*x1137*x1140))+(((0.12)*sj0*x1120))+(((-0.01889999999879)*x1127))+(((0.12)*px*x1140))+(((-1.0)*x1123*x1142))+((x1125*x1145))+(((4.0)*x1120*x1124*x1127))+(((2.0)*x1117*x1133*x1134))+(((-0.24)*x1113*x1124*x1133))+(((-1.0)*x1127*x1138))+(((-1.0)*x1116*x1138))+(((-1.0)*x1146))+(((-0.018)*x1143))+((x1122*x1143))+(((0.018)*x1114*x1134))+(((-2.0)*px*pz*x1140))+(((-2.2e-6)*px*x1114*x1134))+(((0.0072)*x1133*x1134))+((x1117*x1127))+(((-1.0)*x1119*x1127))+((x1126*x1137*x1140))+(((-2.0)*x1127*x1141))+(((-0.24)*x1120*x1142))+(((-1.0)*x1114*x1122*x1134))+(((0.0036)*x1116))+(((-1.0)*x1115*x1127))+(((-1.0)*x1115*x1116))+((x1113*x1121*x1133))+(((-3.3e-7)*x1140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[2];
IkReal x1147=cj2*cj2;
IkReal x1148=cj1*cj1;
IkReal x1149=cj0*cj0;
IkReal x1150=sj1*sj1;
IkReal x1151=sj0*sj0;
IkReal x1152=sj2*sj2;
IkReal x1153=(cj0*cj1);
IkReal x1154=(sj0*sj1);
IkReal x1155=((67.6979474104201)*cj2*sj2);
IkReal x1156=((1145.753020896)*x1147);
IkReal x1157=(x1149*x1150);
IkReal x1158=(x1148*x1151);
j3eval[0]=((((2291.50604179201)*x1147*x1153*x1154))+(((135.39589482084)*cj2*sj2*x1153*x1154))+((x1152*x1158))+((x1152*x1157))+(((1146.753020896)*x1148*x1149))+(((1146.753020896)*x1150*x1151))+(((-2293.50604179201)*x1153*x1154))+((x1156*x1157))+((x1156*x1158))+(((2.0)*x1152*x1153*x1154))+((x1155*x1157))+((x1155*x1158)));
j3eval[1]=(x1153+(((-1.0)*x1154)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1159=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1159.valid){
continue;
}
sj3array[0]=((x1159.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=0;
sj0=0;
cj0=1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1160=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1160.valid){
continue;
}
sj3array[0]=((x1160.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1161=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1161.valid){
continue;
}
sj3array[0]=((x1161.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=1.5707963267949;
sj0=1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1162=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1162.valid){
continue;
}
sj3array[0]=((x1162.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j1), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=1.5707963267949;
sj1=1.0;
cj1=0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1163=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1163.valid){
continue;
}
sj3array[0]=((x1163.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j0, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=3.14159265358979;
sj0=0;
cj0=-1.0;
j1=-1.5707963267949;
sj1=-1.0;
cj1=0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1164=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1164.valid){
continue;
}
sj3array[0]=((x1164.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j1), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=0;
sj1=0;
cj1=1.0;
j3eval[0]=((((-33.8489737052101)*cj2))+(((-1.0)*sj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-4.7419233831551)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1165=IKPowWithIntegerCheck(((((-0.0295301092415339)*sj2))+(((-0.999563891228661)*cj2))),-1);
if(!x1165.valid){
continue;
}
sj3array[0]=((x1165.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j1, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j0), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
j0=-1.5707963267949;
sj0=-1.0;
cj0=0;
j1=3.14159265358979;
sj1=0;
cj1=-1.0;
j3eval[0]=(sj2+(((33.8489737052101)*cj2)));
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.54126192402449)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.6003307295653)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
sj3array[0]=((-1271768350.42046)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x1166=IKPowWithIntegerCheck(((((0.0295301092415339)*sj2))+(((0.999563891228661)*cj2))),-1);
if(!x1166.valid){
continue;
}
sj3array[0]=((x1166.value)*(IKcos(r00)));
if( sj3array[0] >= -1-IKFAST_SINCOS_THRESH && sj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKasin(sj3array[0]);
    cj3array[0] = IKcos(j3array[0]);
    sj3array[1] = sj3array[0];
    j3array[1] = j3array[0] > 0 ? (IKPI-j3array[0]) : (-IKPI-j3array[0]);
    cj3array[1] = -cj3array[0];
}
else if( isnan(sj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
IkReal x1167=(cj1*sj0);
IkReal x1168=((0.0295301092415339)*sj2);
IkReal x1169=((0.999563891228661)*cj2);
IkReal x1170=(cj0*sj1);
IkReal x1171=(((cj0*cj1))+(((-1.0)*sj0*sj1)));
IkReal x1172=(((x1168*x1170))+((x1167*x1169))+((x1167*x1168))+((x1169*x1170)));
CheckValue<IkReal> x1175 = IKatan2WithCheck(IkReal(x1171),IkReal(x1172),IKFAST_ATAN2_MAGTHRESH);
if(!x1175.valid){
continue;
}
IkReal x1173=((1.0)*(x1175.value));
if((((x1171*x1171)+(x1172*x1172))) < -0.00001)
continue;
CheckValue<IkReal> x1176=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1171*x1171)+(x1172*x1172)))),-1);
if(!x1176.valid){
continue;
}
if( (((x1176.value)*(IKcos(r00)))) < -1-IKFAST_SINCOS_THRESH || (((x1176.value)*(IKcos(r00)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1174=IKasin(((x1176.value)*(IKcos(r00))));
j3array[0]=(x1174+(((-1.0)*x1173)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+(((-1.0)*x1173))+(((-1.0)*x1174)));
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}
}
}

} else
{
continue; // verifyAllEquations

}

}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "53a4976966144c9440d86012ca359708"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
