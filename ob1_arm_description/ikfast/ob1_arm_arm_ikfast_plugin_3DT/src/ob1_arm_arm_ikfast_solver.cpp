/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2022-09-15 23:37:04.577528
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[0]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[2]);
x6=((0.21115)*x2);
x7=(x0*x1);
x8=(x2*x3);
x9=(x0*x3);
x10=(x1*x2);
eetrans[0]=((((6.6e-7)*x7))+(((-1.1e-6)*x0))+(((-0.21115)*x9))+(((-0.15)*x2))+(((-1.0)*x1*x6))+((x4*(((((-0.08281387)*x7))+(((0.08281387)*x8))))))+((x5*(((((0.00244659)*x7))+(((-0.00244659)*x8))))))+(((-6.6e-7)*x8)));
eetrans[1]=((-0.001)+(((-0.08281387)*x5))+(((-0.00244659)*x4)));
eetrans[2]=((0.06)+(((6.6e-7)*x9))+(((-1.1e-6)*x2))+(((0.21115)*x7))+(((0.15)*x0))+((x5*(((((0.00244659)*x9))+(((0.00244659)*x10))))))+((x4*(((((-0.08281387)*x9))+(((-0.08281387)*x10))))))+(((-1.0)*x3*x6))+(((6.6e-7)*x10)));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3, 4}; return freeparams; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j4,cj4,sj4,htj4,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0;  _ij4[0] = -1; _ij4[1] = -1; _nj4 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]);
j4=pfree[1]; cj4=cos(pfree[1]); sj4=sin(pfree[1]);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=px;
new_py=((-0.06)+pz);
new_pz=((0.0465)+(((-1.0)*py)));
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
if( (((-0.573325271335612)+(((12.0700057123287)*pz)))) < -1-IKFAST_SINCOS_THRESH || (((-0.573325271335612)+(((12.0700057123287)*pz)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x11=IKasin(((-0.573325271335612)+(((12.0700057123287)*pz))));
j2array[0]=((-1.54126167788295)+(((1.0)*x11)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((1.60033097570684)+(((-1.0)*x11)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[1];
j0eval[0]=((px*px)+(py*py));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[4];
IkReal x12=px*px;
IkReal x13=py*py;
j0eval[0]=((x12*x12)+((x12*x13)));
j0eval[1]=0.09000000000484;
j0eval[2]=px;
j0eval[3]=(x13+x12);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal j0eval[4];
IkReal x14=px*px;
IkReal x15=py*py;
j0eval[0]=((x15*x15)+((x14*x15)));
j0eval[1]=0.09000000000484;
j0eval[2]=py;
j0eval[3]=(x15+x14);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))))+IKsqr(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))), ((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x16=IKsin(j1);
IkReal x17=IKcos(j1);
IkReal x18=((0.029543239556369)*pz);
IkReal x19=((0.0828861501944662)*sj2);
evalcond[0]=((-0.21115)+(((-0.15)*x17))+(((-1.1e-6)*x16)));
evalcond[1]=((-0.00140264387892753)+(((-1.0)*x19))+(((-1.1e-6)*x17))+x18+(((0.15)*x16)));
evalcond[2]=((0.0266921953653594)+(((0.095)*pz))+(((1.452e-12)*x17))+(((-1.0)*(pz*pz)))+(((-1.98e-7)*x16)));
evalcond[3]=((1.1e-6)+(((0.21115)*x16))+(((-1.0)*x17*x18))+(((0.00140264387892753)*x17))+((x17*x19)));
evalcond[4]=((0.15)+(((0.21115)*x17))+(((-1.0)*x16*x19))+(((-0.00140264387892753)*x16))+((x16*x18)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))))+IKsqr(((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((0.00934063630345898)+(((-0.196954930365202)*pz))+(((0.552574334600059)*sj2))), ((-1.40766673516467)+(((-4.0522117870671e-6)*sj2))+(((1.44433615601148e-6)*pz))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x20=IKsin(j1);
IkReal x21=IKcos(j1);
IkReal x22=((0.029543239556369)*pz);
IkReal x23=((0.0828861501944662)*sj2);
evalcond[0]=((-0.21115)+(((-0.15)*x21))+(((-1.1e-6)*x20)));
evalcond[1]=((-0.00140264387892753)+(((-1.0)*x23))+(((-1.1e-6)*x21))+x22+(((0.15)*x20)));
evalcond[2]=((0.0266921953653594)+(((0.095)*pz))+(((1.452e-12)*x21))+(((-1.0)*(pz*pz)))+(((-1.98e-7)*x20)));
evalcond[3]=((1.1e-6)+((x21*x23))+(((-1.0)*x21*x22))+(((0.21115)*x20))+(((0.00140264387892753)*x21)));
evalcond[4]=((0.15)+(((-1.0)*x20*x23))+(((0.21115)*x21))+(((-0.00140264387892753)*x20))+((x20*x22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x24=py*py;
IkReal x25=(px*py);
IkReal x26=((1.0)*py);
IkReal x27=((((0.3)*x24))+(((-2.2e-6)*x25)));
IkReal x28=((((-0.3)*x25))+(((-2.2e-6)*x24)));
CheckValue<IkReal> x31 = IKatan2WithCheck(IkReal(x27),IkReal(x28),IKFAST_ATAN2_MAGTHRESH);
if(!x31.valid){
continue;
}
IkReal x29=((1.0)*(x31.value));
if((((x28*x28)+(x27*x27))) < -0.00001)
continue;
CheckValue<IkReal> x32=IKPowWithIntegerCheck(IKabs(IKsqrt(((x28*x28)+(x27*x27)))),-1);
if(!x32.valid){
continue;
}
if( (((x32.value)*(((((-1.0)*x26*(py*py)))+(((-1.0)*px*x25))+(((0.0266921953662306)*py))+(((0.095)*py*pz))+(((-1.093143084e-7)*py*sj2))+(((-1.0)*x26*(pz*pz)))+(((3.2294988e-9)*cj2*py)))))) < -1-IKFAST_SINCOS_THRESH || (((x32.value)*(((((-1.0)*x26*(py*py)))+(((-1.0)*px*x25))+(((0.0266921953662306)*py))+(((0.095)*py*pz))+(((-1.093143084e-7)*py*sj2))+(((-1.0)*x26*(pz*pz)))+(((3.2294988e-9)*cj2*py)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x30=IKasin(((x32.value)*(((((-1.0)*x26*(py*py)))+(((-1.0)*px*x25))+(((0.0266921953662306)*py))+(((0.095)*py*pz))+(((-1.093143084e-7)*py*sj2))+(((-1.0)*x26*(pz*pz)))+(((3.2294988e-9)*cj2*py))))));
j0array[0]=((((-1.0)*x30))+(((-1.0)*x29)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x29))+x30);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x33=IKcos(j0);
IkReal x34=px*px;
IkReal x35=IKsin(j0);
IkReal x36=pz*pz;
IkReal x37=py*py;
IkReal x38=((0.3)*px);
IkReal x39=((2.2e-6)*py);
evalcond[0]=((0.0312046953662306)+(((-1.0)*x37))+(((-1.0)*x36))+(((-1.0)*x34))+((x35*(((((-1.0)*x38))+(((-1.0)*x39))))))+((x33*(((((0.3)*py))+(((-2.2e-6)*px))))))+(((0.0078673208794988)*cj2))+(((0.0002323167356916)*sj2)));
evalcond[1]=(((x35*((((px*x39))+(((0.3)*x34))))))+(px*px*px)+(((1.093143084e-7)*px*sj2))+(((-0.095)*px*pz))+((px*x36))+((px*x37))+((x33*(((((2.2e-6)*x34))+(((-1.0)*py*x38))))))+(((-3.2294988e-9)*cj2*px))+(((-0.0266921953662306)*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x40=cj2*cj2;
IkReal x41=(cj2*sj2);
j1eval[0]=((-15928929.7660716)+(((2121738.29008662)*x40))+(((33.8486914440098)*sj2))+(((-1.0)*cj2))+(((125475.560606061)*x41)));
j1eval[1]=IKsign(((-20576983.825925)+(((2740860.50469952)*x40))+(((-1.29179952)*cj2))+(((43.72572336)*sj2))+(((162089.26896264)*x41))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x42=(cj0*py);
IkReal x43=(px*sj0);
IkReal x44=((18358.833902375)*cj2);
IkReal x45=(cj0*px);
IkReal x46=((1656.2774)*sj2);
IkReal x47=(py*sj0);
IkReal x48=((621422.504033317)*sj2);
IkReal x49=((48.9318)*cj2);
j1eval[0]=((1.0)+(((-4.95253817581511)*x43))+(((93213.3756049976)*sj2))+(((-2753.82508535624)*cj2))+(((-1.0)*x42*x48))+((x43*x48))+(((-1.0)*x43*x44))+(((4.95253817581511)*x42))+((x42*x44))+(((1584437.02397479)*x47))+(((1584437.02397479)*x45)));
j1eval[1]=IKsign(((0.0026653)+(((-1.0)*x42*x46))+((x43*x46))+(((4223.0)*x47))+(((4223.0)*x45))+(((-1.0)*x43*x49))+((x42*x49))+(((248.44161)*sj2))+(((-0.0132)*x43))+(((0.0132)*x42))+(((-7.33977)*cj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x50=(py*sj0);
IkReal x51=((30771537.6763726)*sj2);
IkReal x52=((909090.909090909)*cj2);
IkReal x53=(cj0*px);
j1eval[0]=((11768699.217622)+(((78457994.7823483)*px*sj0))+cj2+(((-1.0)*x51*x53))+(((-78457994.7823483)*cj0*py))+(((-33.8486914440098)*sj2))+((x50*x52))+((x52*x53))+(((245.239292239403)*x50))+(((245.239292239403)*x53))+(((-1.0)*x50*x51)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x54=cj0*cj0;
IkReal x55=px*px;
IkReal x56=py*py;
IkReal x57=(cj0*px);
IkReal x58=((33125548.0)*sj2);
IkReal x59=(cj0*py);
IkReal x60=(py*sj0);
IkReal x61=(px*py);
IkReal x62=((978636.0)*cj2);
IkReal x63=((1656.2774)*sj2);
IkReal x64=(px*sj0);
IkReal x65=((48.9318)*cj2);
IkReal x66=((20000.0)*cj0*sj0);
IkReal x67=((400000000.0)*x56);
CheckValue<IkReal> x68=IKPowWithIntegerCheck(((633.45000001452)+(((4223.0)*x64))+((x60*x65))+((x57*x65))+(((0.0132)*x60))+(((5.382498e-5)*cj2))+(((-4223.0)*x59))+(((-1.0)*x57*x63))+(((0.0132)*x57))+(((-1.0)*x60*x63))+(((-0.00182190514)*sj2))),-1);
if(!x68.valid){
continue;
}
CheckValue<IkReal> x69=IKPowWithIntegerCheck(((12669000.0002904)+(((-36.4381028)*sj2))+(((1.0764996)*cj2))+((x60*x62))+(((264.0)*x60))+(((264.0)*x57))+((x57*x62))+(((-1.0)*x58*x60))+(((84460000.0)*x64))+(((-84460000.0)*x59))+(((-1.0)*x57*x58))),-1);
if(!x69.valid){
continue;
}
if( IKabs(((x68.value)*(((-0.00608718)+(((0.022)*x59))+(((40000.0)*x54*x61))+(((-3000.0)*x57))+(((-3000.0)*x60))+(((-10.33194957)*cj2))+(((-1.0)*x55*x66))+(((-20000.0)*x61))+((x56*x66))+(((-0.022)*x64))+(((349.72297301)*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x69.value)*(((-17833728.999516)+(((400000000.0)*x54*x55))+(((880.0)*x60))+(((-1.0)*x54*x67))+(((880.0)*x57))+x67+(((800000000.0)*x57*x60)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x68.value)*(((-0.00608718)+(((0.022)*x59))+(((40000.0)*x54*x61))+(((-3000.0)*x57))+(((-3000.0)*x60))+(((-10.33194957)*cj2))+(((-1.0)*x55*x66))+(((-20000.0)*x61))+((x56*x66))+(((-0.022)*x64))+(((349.72297301)*sj2))))))+IKsqr(((x69.value)*(((-17833728.999516)+(((400000000.0)*x54*x55))+(((880.0)*x60))+(((-1.0)*x54*x67))+(((880.0)*x57))+x67+(((800000000.0)*x57*x60))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x68.value)*(((-0.00608718)+(((0.022)*x59))+(((40000.0)*x54*x61))+(((-3000.0)*x57))+(((-3000.0)*x60))+(((-10.33194957)*cj2))+(((-1.0)*x55*x66))+(((-20000.0)*x61))+((x56*x66))+(((-0.022)*x64))+(((349.72297301)*sj2))))), ((x69.value)*(((-17833728.999516)+(((400000000.0)*x54*x55))+(((880.0)*x60))+(((-1.0)*x54*x67))+(((880.0)*x57))+x67+(((800000000.0)*x57*x60))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x70=IKcos(j1);
IkReal x71=IKsin(j1);
IkReal x72=((0.08281387)*sj2);
IkReal x73=(py*sj0);
IkReal x74=((1.32e-6)*px);
IkReal x75=(px*sj0);
IkReal x76=(cj0*py);
IkReal x77=((0.00244659)*cj2);
IkReal x78=(cj0*px);
IkReal x79=((1.0)*x78);
IkReal x80=(cj0*x70);
IkReal x81=((1.0)*x70);
IkReal x82=((1.0)*x71);
evalcond[0]=((1.1e-6)+(((0.21115)*x71))+(((-1.0)*x70*x77))+(((-6.6e-7)*x70))+x73+x78+((x70*x72)));
evalcond[1]=((0.15)+(((6.6e-7)*x71))+(((0.21115)*x70))+x75+(((-1.0)*x71*x72))+(((-1.0)*x76))+((x71*x77)));
evalcond[2]=((-0.21115)+(((-0.15)*x70))+(((-1.0)*x73*x82))+(((-1.0)*x71*x79))+((x70*x76))+(((-1.0)*x75*x81))+(((-1.1e-6)*x71)));
evalcond[3]=((6.6e-7)+(((-1.0)*x73*x81))+(((-1.0)*x72))+(((0.15)*x71))+(((-1.0)*x70*x79))+x77+(((-1.0)*x76*x82))+(((-1.1e-6)*x70))+((x71*x75)));
evalcond[4]=((0.0266921953653594)+(((-1.98e-7)*x71))+(((-1.0)*sj0*x71*x74))+(((-1.0)*(px*px)))+(((0.095)*pz))+(((1.32e-6)*x71*x76))+((x74*x80))+(((-2.2e-6)*x78))+(((-2.2e-6)*x73))+(((1.452e-12)*x70))+(((-0.3)*x75))+(((-1.0)*(pz*pz)))+(((1.32e-6)*x70*x73))+(((0.3)*x76))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x83=py*py;
IkReal x84=cj0*cj0;
IkReal x85=px*px;
IkReal x86=(cj0*py);
IkReal x87=((48.9318)*cj2);
IkReal x88=(px*sj0);
IkReal x89=(cj0*px);
IkReal x90=((1656.2774)*sj2);
IkReal x91=(py*sj0);
IkReal x92=(px*py);
IkReal x93=((20000.0)*x84);
IkReal x94=((20000.0)*cj0*sj0);
CheckValue<IkReal> x95=IKPowWithIntegerCheck(IKsign(((0.0026653)+(((0.0132)*x86))+(((4223.0)*x91))+(((4223.0)*x89))+((x86*x87))+(((-1.0)*x86*x90))+(((-0.0132)*x88))+((x88*x90))+(((-1.0)*x87*x88))+(((248.44161)*sj2))+(((-7.33977)*cj2)))),-1);
if(!x95.valid){
continue;
}
CheckValue<IkReal> x96 = IKatan2WithCheck(IkReal(((137.16274127205)+(((-137.043025234976)*(cj2*cj2)))+(((-0.044)*x91))+(((-8.104463448132)*cj2*sj2))+(((-0.044)*x89))+(((-40000.0)*x86*x88))+(((-0.002186286168)*sj2))+((x83*x93))+(((-20000.0)*x83))+(((6.4589976e-5)*cj2))+(((-1.0)*x85*x93)))),IkReal(((-0.00051282)+(((10.33194957)*cj2))+(((-349.72297301)*sj2))+(((-3000.0)*x89))+(((-3000.0)*x91))+(((40000.0)*x84*x92))+(((-20000.0)*x92))+((x83*x94))+(((-0.022)*x88))+(((0.022)*x86))+(((-1.0)*x85*x94)))),IKFAST_ATAN2_MAGTHRESH);
if(!x96.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x95.value)))+(x96.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x97=IKcos(j1);
IkReal x98=IKsin(j1);
IkReal x99=((0.08281387)*sj2);
IkReal x100=(py*sj0);
IkReal x101=((1.32e-6)*px);
IkReal x102=(px*sj0);
IkReal x103=(cj0*py);
IkReal x104=((0.00244659)*cj2);
IkReal x105=(cj0*px);
IkReal x106=((1.0)*x105);
IkReal x107=(cj0*x97);
IkReal x108=((1.0)*x97);
IkReal x109=((1.0)*x98);
evalcond[0]=((1.1e-6)+((x97*x99))+(((-6.6e-7)*x97))+x105+x100+(((0.21115)*x98))+(((-1.0)*x104*x97)));
evalcond[1]=((0.15)+(((6.6e-7)*x98))+(((-1.0)*x98*x99))+x102+(((0.21115)*x97))+(((-1.0)*x103))+((x104*x98)));
evalcond[2]=((-0.21115)+(((-1.0)*x100*x109))+((x103*x97))+(((-0.15)*x97))+(((-1.0)*x102*x108))+(((-1.0)*x106*x98))+(((-1.1e-6)*x98)));
evalcond[3]=((6.6e-7)+(((-1.0)*x100*x108))+(((0.15)*x98))+((x102*x98))+x104+(((-1.0)*x99))+(((-1.0)*x103*x109))+(((-1.0)*x106*x97))+(((-1.1e-6)*x97)));
evalcond[4]=((0.0266921953653594)+(((1.452e-12)*x97))+(((-1.98e-7)*x98))+(((-1.0)*(px*px)))+(((0.095)*pz))+(((0.3)*x103))+(((-2.2e-6)*x105))+(((-2.2e-6)*x100))+(((1.32e-6)*x100*x97))+(((-1.0)*sj0*x101*x98))+(((-1.0)*(pz*pz)))+(((-0.3)*x102))+(((-1.0)*(py*py)))+((x101*x107))+(((1.32e-6)*x103*x98)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x110=(py*sj0);
IkReal x111=((978636.0)*cj2);
IkReal x112=(px*sj0);
IkReal x113=((264.0)*cj0);
IkReal x114=((33125548.0)*sj2);
IkReal x115=(cj0*px);
IkReal x116=(cj0*py);
IkReal x117=(px*x114);
CheckValue<IkReal> x118=IKPowWithIntegerCheck(IKsign(((-20576983.825925)+(((2740860.50469952)*(cj2*cj2)))+(((-1.29179952)*cj2))+(((162089.26896264)*cj2*sj2))+(((43.72572336)*sj2)))),-1);
if(!x118.valid){
continue;
}
CheckValue<IkReal> x119 = IKatan2WithCheck(IkReal(((132.506)+(((-1.0)*x111*x116))+(((-1.0)*x112*x114))+(((264.0)*x112))+((x111*x112))+(((84460000.0)*x115))+(((84460000.0)*x110))+(((146795.4)*cj2))+((x114*x116))+(((-4968832.2)*sj2))+(((-1.0)*py*x113)))),IkReal(((12668999.9997096)+(((-1.0)*x111*x115))+((x110*x114))+(((-264.0)*x110))+(((84460000.0)*x112))+(((-1.0)*px*x113))+((x114*x115))+(((-1.0764996)*cj2))+(((-1.0)*x110*x111))+(((-84460000.0)*x116))+(((36.4381028)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x119.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x118.value)))+(x119.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x120=IKcos(j1);
IkReal x121=IKsin(j1);
IkReal x122=((0.08281387)*sj2);
IkReal x123=(py*sj0);
IkReal x124=((1.32e-6)*px);
IkReal x125=(px*sj0);
IkReal x126=(cj0*py);
IkReal x127=((0.00244659)*cj2);
IkReal x128=(cj0*px);
IkReal x129=((1.0)*x128);
IkReal x130=(cj0*x120);
IkReal x131=((1.0)*x120);
IkReal x132=((1.0)*x121);
evalcond[0]=((1.1e-6)+(((-1.0)*x120*x127))+x123+x128+((x120*x122))+(((0.21115)*x121))+(((-6.6e-7)*x120)));
evalcond[1]=((0.15)+((x121*x127))+(((6.6e-7)*x121))+x125+(((-1.0)*x121*x122))+(((0.21115)*x120))+(((-1.0)*x126)));
evalcond[2]=((-0.21115)+(((-1.0)*x123*x132))+(((-1.1e-6)*x121))+((x120*x126))+(((-1.0)*x125*x131))+(((-0.15)*x120))+(((-1.0)*x121*x129)));
evalcond[3]=((6.6e-7)+(((-1.0)*x123*x131))+(((-1.0)*x120*x129))+((x121*x125))+(((-1.1e-6)*x120))+(((-1.0)*x126*x132))+(((-1.0)*x122))+x127+(((0.15)*x121)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+(((-2.2e-6)*x128))+(((-2.2e-6)*x123))+(((0.095)*pz))+(((1.32e-6)*x120*x123))+(((0.3)*x126))+(((-1.98e-7)*x121))+((x124*x130))+(((1.32e-6)*x121*x126))+(((-0.3)*x125))+(((-1.0)*(pz*pz)))+(((-1.0)*sj0*x121*x124))+(((1.452e-12)*x120))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x133=px*px;
IkReal x134=(px*py);
IkReal x135=((((-0.3)*x134))+(((2.2e-6)*x133)));
IkReal x136=((((0.3)*x133))+(((2.2e-6)*x134)));
CheckValue<IkReal> x139 = IKatan2WithCheck(IkReal(x135),IkReal(x136),IKFAST_ATAN2_MAGTHRESH);
if(!x139.valid){
continue;
}
IkReal x137=((1.0)*(x139.value));
if((((x135*x135)+(x136*x136))) < -0.00001)
continue;
CheckValue<IkReal> x140=IKPowWithIntegerCheck(IKabs(IKsqrt(((x135*x135)+(x136*x136)))),-1);
if(!x140.valid){
continue;
}
if( (((x140.value)*(((px*px*px)+((py*x134))+(((1.093143084e-7)*px*sj2))+(((-0.095)*px*pz))+(((-3.2294988e-9)*cj2*px))+((px*(pz*pz)))+(((-0.0266921953662306)*px)))))) < -1-IKFAST_SINCOS_THRESH || (((x140.value)*(((px*px*px)+((py*x134))+(((1.093143084e-7)*px*sj2))+(((-0.095)*px*pz))+(((-3.2294988e-9)*cj2*px))+((px*(pz*pz)))+(((-0.0266921953662306)*px)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x138=IKasin(((x140.value)*(((px*px*px)+((py*x134))+(((1.093143084e-7)*px*sj2))+(((-0.095)*px*pz))+(((-3.2294988e-9)*cj2*px))+((px*(pz*pz)))+(((-0.0266921953662306)*px))))));
j0array[0]=((((-1.0)*x137))+(((-1.0)*x138)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x138+(((-1.0)*x137)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x141=IKcos(j0);
IkReal x142=py*py;
IkReal x143=IKsin(j0);
IkReal x144=px*px;
IkReal x145=pz*pz;
IkReal x146=((0.3)*px);
IkReal x147=((2.2e-6)*py);
IkReal x148=((1.0)*x145);
IkReal x149=((1.0)*x144);
evalcond[0]=((0.0312046953662306)+(((-1.0)*x149))+(((-1.0)*x148))+(((0.0078673208794988)*cj2))+((x141*(((((0.3)*py))+(((-2.2e-6)*px))))))+(((0.0002323167356916)*sj2))+((x143*(((((-1.0)*x147))+(((-1.0)*x146))))))+(((-1.0)*x142)));
evalcond[1]=((((-1.0)*(py*py*py)))+(((-1.0)*py*x148))+(((-1.0)*py*x149))+(((0.0266921953662306)*py))+((x141*(((((0.3)*x142))+(((-1.0)*px*x147))))))+(((0.095)*py*pz))+(((-1.093143084e-7)*py*sj2))+((x143*(((((-1.0)*py*x146))+(((-2.2e-6)*x142))))))+(((3.2294988e-9)*cj2*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x150=cj2*cj2;
IkReal x151=(cj2*sj2);
j1eval[0]=((-15928929.7660716)+(((33.8486914440098)*sj2))+(((125475.560606061)*x151))+(((2121738.29008662)*x150))+(((-1.0)*cj2)));
j1eval[1]=IKsign(((-20576983.825925)+(((162089.26896264)*x151))+(((2740860.50469952)*x150))+(((-1.29179952)*cj2))+(((43.72572336)*sj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x152=(cj0*py);
IkReal x153=(px*sj0);
IkReal x154=((18358.833902375)*cj2);
IkReal x155=(cj0*px);
IkReal x156=((1656.2774)*sj2);
IkReal x157=(py*sj0);
IkReal x158=((621422.504033317)*sj2);
IkReal x159=((48.9318)*cj2);
j1eval[0]=((1.0)+((x153*x158))+(((93213.3756049976)*sj2))+(((-2753.82508535624)*cj2))+(((-1.0)*x153*x154))+(((-4.95253817581511)*x153))+((x152*x154))+(((-1.0)*x152*x158))+(((4.95253817581511)*x152))+(((1584437.02397479)*x155))+(((1584437.02397479)*x157)));
j1eval[1]=IKsign(((0.0026653)+((x153*x156))+(((-1.0)*x153*x159))+((x152*x159))+(((-1.0)*x152*x156))+(((4223.0)*x157))+(((4223.0)*x155))+(((248.44161)*sj2))+(((-0.0132)*x153))+(((0.0132)*x152))+(((-7.33977)*cj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x160=(py*sj0);
IkReal x161=((30771537.6763726)*sj2);
IkReal x162=((909090.909090909)*cj2);
IkReal x163=(cj0*px);
j1eval[0]=((11768699.217622)+(((78457994.7823483)*px*sj0))+cj2+(((-1.0)*x160*x161))+(((245.239292239403)*x160))+(((245.239292239403)*x163))+((x162*x163))+(((-78457994.7823483)*cj0*py))+(((-33.8486914440098)*sj2))+(((-1.0)*x161*x163))+((x160*x162)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x164=cj0*cj0;
IkReal x165=px*px;
IkReal x166=py*py;
IkReal x167=(cj0*px);
IkReal x168=((33125548.0)*sj2);
IkReal x169=(cj0*py);
IkReal x170=(py*sj0);
IkReal x171=(px*py);
IkReal x172=((978636.0)*cj2);
IkReal x173=((1656.2774)*sj2);
IkReal x174=(px*sj0);
IkReal x175=((48.9318)*cj2);
IkReal x176=((20000.0)*cj0*sj0);
IkReal x177=((400000000.0)*x166);
CheckValue<IkReal> x178=IKPowWithIntegerCheck(((633.45000001452)+(((-4223.0)*x169))+((x167*x175))+(((-1.0)*x170*x173))+(((0.0132)*x167))+(((0.0132)*x170))+((x170*x175))+(((4223.0)*x174))+(((5.382498e-5)*cj2))+(((-0.00182190514)*sj2))+(((-1.0)*x167*x173))),-1);
if(!x178.valid){
continue;
}
CheckValue<IkReal> x179=IKPowWithIntegerCheck(((12669000.0002904)+(((-36.4381028)*sj2))+(((1.0764996)*cj2))+(((264.0)*x167))+((x167*x172))+(((264.0)*x170))+(((-84460000.0)*x169))+((x170*x172))+(((-1.0)*x168*x170))+(((84460000.0)*x174))+(((-1.0)*x167*x168))),-1);
if(!x179.valid){
continue;
}
if( IKabs(((x178.value)*(((-0.00608718)+(((-20000.0)*x171))+(((-10.33194957)*cj2))+(((-0.022)*x174))+(((-3000.0)*x170))+(((-3000.0)*x167))+((x166*x176))+(((40000.0)*x164*x171))+(((349.72297301)*sj2))+(((0.022)*x169))+(((-1.0)*x165*x176)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x179.value)*(((-17833728.999516)+(((800000000.0)*x167*x170))+(((880.0)*x167))+(((880.0)*x170))+x177+(((-1.0)*x164*x177))+(((400000000.0)*x164*x165)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x178.value)*(((-0.00608718)+(((-20000.0)*x171))+(((-10.33194957)*cj2))+(((-0.022)*x174))+(((-3000.0)*x170))+(((-3000.0)*x167))+((x166*x176))+(((40000.0)*x164*x171))+(((349.72297301)*sj2))+(((0.022)*x169))+(((-1.0)*x165*x176))))))+IKsqr(((x179.value)*(((-17833728.999516)+(((800000000.0)*x167*x170))+(((880.0)*x167))+(((880.0)*x170))+x177+(((-1.0)*x164*x177))+(((400000000.0)*x164*x165))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x178.value)*(((-0.00608718)+(((-20000.0)*x171))+(((-10.33194957)*cj2))+(((-0.022)*x174))+(((-3000.0)*x170))+(((-3000.0)*x167))+((x166*x176))+(((40000.0)*x164*x171))+(((349.72297301)*sj2))+(((0.022)*x169))+(((-1.0)*x165*x176))))), ((x179.value)*(((-17833728.999516)+(((800000000.0)*x167*x170))+(((880.0)*x167))+(((880.0)*x170))+x177+(((-1.0)*x164*x177))+(((400000000.0)*x164*x165))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x180=IKcos(j1);
IkReal x181=IKsin(j1);
IkReal x182=((0.08281387)*sj2);
IkReal x183=(py*sj0);
IkReal x184=((1.32e-6)*px);
IkReal x185=(px*sj0);
IkReal x186=(cj0*py);
IkReal x187=((0.00244659)*cj2);
IkReal x188=(cj0*px);
IkReal x189=((1.0)*x188);
IkReal x190=(cj0*x180);
IkReal x191=((1.0)*x180);
IkReal x192=((1.0)*x181);
evalcond[0]=((1.1e-6)+(((-6.6e-7)*x180))+((x180*x182))+(((-1.0)*x180*x187))+x183+x188+(((0.21115)*x181)));
evalcond[1]=((0.15)+(((-1.0)*x186))+x185+(((6.6e-7)*x181))+(((0.21115)*x180))+((x181*x187))+(((-1.0)*x181*x182)));
evalcond[2]=((-0.21115)+((x180*x186))+(((-1.0)*x185*x191))+(((-0.15)*x180))+(((-1.1e-6)*x181))+(((-1.0)*x183*x192))+(((-1.0)*x181*x189)));
evalcond[3]=((6.6e-7)+(((-1.0)*x182))+(((-1.0)*x186*x192))+(((0.15)*x181))+(((-1.0)*x180*x189))+x187+(((-1.1e-6)*x180))+(((-1.0)*x183*x191))+((x181*x185)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+(((-1.98e-7)*x181))+(((1.32e-6)*x181*x186))+(((0.095)*pz))+(((-1.0)*sj0*x181*x184))+(((0.3)*x186))+(((-2.2e-6)*x188))+(((-2.2e-6)*x183))+((x184*x190))+(((1.452e-12)*x180))+(((-1.0)*(pz*pz)))+(((-0.3)*x185))+(((-1.0)*(py*py)))+(((1.32e-6)*x180*x183)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x193=py*py;
IkReal x194=cj0*cj0;
IkReal x195=px*px;
IkReal x196=(cj0*py);
IkReal x197=((48.9318)*cj2);
IkReal x198=(px*sj0);
IkReal x199=(cj0*px);
IkReal x200=((1656.2774)*sj2);
IkReal x201=(py*sj0);
IkReal x202=(px*py);
IkReal x203=((20000.0)*x194);
IkReal x204=((20000.0)*cj0*sj0);
CheckValue<IkReal> x205 = IKatan2WithCheck(IkReal(((137.16274127205)+(((-1.0)*x195*x203))+(((-20000.0)*x193))+(((-137.043025234976)*(cj2*cj2)))+(((-0.044)*x199))+(((-8.104463448132)*cj2*sj2))+(((-40000.0)*x196*x198))+(((-0.002186286168)*sj2))+((x193*x203))+(((6.4589976e-5)*cj2))+(((-0.044)*x201)))),IkReal(((-0.00051282)+(((-1.0)*x195*x204))+(((10.33194957)*cj2))+(((-349.72297301)*sj2))+(((0.022)*x196))+(((-0.022)*x198))+(((-3000.0)*x199))+(((40000.0)*x194*x202))+(((-3000.0)*x201))+((x193*x204))+(((-20000.0)*x202)))),IKFAST_ATAN2_MAGTHRESH);
if(!x205.valid){
continue;
}
CheckValue<IkReal> x206=IKPowWithIntegerCheck(IKsign(((0.0026653)+((x198*x200))+(((-1.0)*x197*x198))+((x196*x197))+(((4223.0)*x199))+(((248.44161)*sj2))+(((0.0132)*x196))+(((-0.0132)*x198))+(((4223.0)*x201))+(((-1.0)*x196*x200))+(((-7.33977)*cj2)))),-1);
if(!x206.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x205.value)+(((1.5707963267949)*(x206.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x207=IKcos(j1);
IkReal x208=IKsin(j1);
IkReal x209=((0.08281387)*sj2);
IkReal x210=(py*sj0);
IkReal x211=((1.32e-6)*px);
IkReal x212=(px*sj0);
IkReal x213=(cj0*py);
IkReal x214=((0.00244659)*cj2);
IkReal x215=(cj0*px);
IkReal x216=((1.0)*x215);
IkReal x217=(cj0*x207);
IkReal x218=((1.0)*x207);
IkReal x219=((1.0)*x208);
evalcond[0]=((1.1e-6)+(((-1.0)*x207*x214))+(((-6.6e-7)*x207))+x210+x215+(((0.21115)*x208))+((x207*x209)));
evalcond[1]=((0.15)+((x208*x214))+(((6.6e-7)*x208))+(((-1.0)*x208*x209))+x212+(((-1.0)*x213))+(((0.21115)*x207)));
evalcond[2]=((-0.21115)+(((-1.1e-6)*x208))+(((-0.15)*x207))+((x207*x213))+(((-1.0)*x210*x219))+(((-1.0)*x212*x218))+(((-1.0)*x208*x216)));
evalcond[3]=((6.6e-7)+(((-1.1e-6)*x207))+((x208*x212))+(((-1.0)*x207*x216))+(((-1.0)*x209))+x214+(((-1.0)*x210*x218))+(((-1.0)*x213*x219))+(((0.15)*x208)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+(((-0.3)*x212))+(((0.095)*pz))+(((-2.2e-6)*x215))+(((-2.2e-6)*x210))+(((1.32e-6)*x207*x210))+((x211*x217))+(((-1.0)*sj0*x208*x211))+(((1.452e-12)*x207))+(((0.3)*x213))+(((1.32e-6)*x208*x213))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-1.98e-7)*x208)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x220=(py*sj0);
IkReal x221=((978636.0)*cj2);
IkReal x222=(px*sj0);
IkReal x223=((264.0)*cj0);
IkReal x224=((33125548.0)*sj2);
IkReal x225=(cj0*px);
IkReal x226=(cj0*py);
IkReal x227=(px*x224);
CheckValue<IkReal> x228=IKPowWithIntegerCheck(IKsign(((-20576983.825925)+(((2740860.50469952)*(cj2*cj2)))+(((-1.29179952)*cj2))+(((162089.26896264)*cj2*sj2))+(((43.72572336)*sj2)))),-1);
if(!x228.valid){
continue;
}
CheckValue<IkReal> x229 = IKatan2WithCheck(IkReal(((132.506)+((x224*x226))+(((146795.4)*cj2))+(((-1.0)*x222*x224))+(((-4968832.2)*sj2))+(((-1.0)*py*x223))+((x221*x222))+(((-1.0)*x221*x226))+(((84460000.0)*x220))+(((84460000.0)*x225))+(((264.0)*x222)))),IkReal(((12668999.9997096)+((x224*x225))+(((-84460000.0)*x226))+(((-1.0764996)*cj2))+((x220*x224))+(((-1.0)*x220*x221))+(((-264.0)*x220))+(((-1.0)*x221*x225))+(((84460000.0)*x222))+(((36.4381028)*sj2))+(((-1.0)*px*x223)))),IKFAST_ATAN2_MAGTHRESH);
if(!x229.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x228.value)))+(x229.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x230=IKcos(j1);
IkReal x231=IKsin(j1);
IkReal x232=((0.08281387)*sj2);
IkReal x233=(py*sj0);
IkReal x234=((1.32e-6)*px);
IkReal x235=(px*sj0);
IkReal x236=(cj0*py);
IkReal x237=((0.00244659)*cj2);
IkReal x238=(cj0*px);
IkReal x239=((1.0)*x238);
IkReal x240=(cj0*x230);
IkReal x241=((1.0)*x230);
IkReal x242=((1.0)*x231);
evalcond[0]=((1.1e-6)+(((-1.0)*x230*x237))+(((-6.6e-7)*x230))+((x230*x232))+x238+x233+(((0.21115)*x231)));
evalcond[1]=((0.15)+(((6.6e-7)*x231))+x235+(((-1.0)*x231*x232))+(((0.21115)*x230))+(((-1.0)*x236))+((x231*x237)));
evalcond[2]=((-0.21115)+(((-1.1e-6)*x231))+(((-0.15)*x230))+((x230*x236))+(((-1.0)*x233*x242))+(((-1.0)*x231*x239))+(((-1.0)*x235*x241)));
evalcond[3]=((6.6e-7)+(((-1.1e-6)*x230))+(((-1.0)*x230*x239))+(((-1.0)*x236*x242))+(((-1.0)*x233*x241))+(((-1.0)*x232))+x237+((x231*x235))+(((0.15)*x231)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+(((1.32e-6)*x230*x233))+(((0.3)*x236))+(((-1.0)*sj0*x231*x234))+(((0.095)*pz))+((x234*x240))+(((1.32e-6)*x231*x236))+(((-2.2e-6)*x233))+(((-2.2e-6)*x238))+(((1.452e-12)*x230))+(((-0.3)*x235))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((-1.98e-7)*x231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x243=((((0.3)*py))+(((-2.2e-6)*px)));
IkReal x244=((((-0.3)*px))+(((-2.2e-6)*py)));
CheckValue<IkReal> x247 = IKatan2WithCheck(IkReal(x243),IkReal(x244),IKFAST_ATAN2_MAGTHRESH);
if(!x247.valid){
continue;
}
IkReal x245=((1.0)*(x247.value));
if((((x243*x243)+(x244*x244))) < -0.00001)
continue;
CheckValue<IkReal> x248=IKPowWithIntegerCheck(IKabs(IKsqrt(((x243*x243)+(x244*x244)))),-1);
if(!x248.valid){
continue;
}
if( (((x248.value)*(((0.0312046953662306)+(((-1.0)*(px*px)))+(((0.0078673208794988)*cj2))+(((0.0002323167356916)*sj2))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x248.value)*(((0.0312046953662306)+(((-1.0)*(px*px)))+(((0.0078673208794988)*cj2))+(((0.0002323167356916)*sj2))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x246=IKasin(((x248.value)*(((0.0312046953662306)+(((-1.0)*(px*px)))+(((0.0078673208794988)*cj2))+(((0.0002323167356916)*sj2))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j0array[0]=((((-1.0)*x246))+(((-1.0)*x245)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x246+(((-1.0)*x245)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[2];
IkReal x249=cj2*cj2;
IkReal x250=(cj2*sj2);
j1eval[0]=((-15928929.7660716)+(((33.8486914440098)*sj2))+(((2121738.29008662)*x249))+(((125475.560606061)*x250))+(((-1.0)*cj2)));
j1eval[1]=IKsign(((-20576983.825925)+(((-1.29179952)*cj2))+(((2740860.50469952)*x249))+(((43.72572336)*sj2))+(((162089.26896264)*x250))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x251=(cj0*py);
IkReal x252=(px*sj0);
IkReal x253=((18358.833902375)*cj2);
IkReal x254=(cj0*px);
IkReal x255=((1656.2774)*sj2);
IkReal x256=(py*sj0);
IkReal x257=((621422.504033317)*sj2);
IkReal x258=((48.9318)*cj2);
j1eval[0]=((1.0)+(((93213.3756049976)*sj2))+(((-1.0)*x252*x253))+(((-2753.82508535624)*cj2))+(((-1.0)*x251*x257))+((x251*x253))+(((4.95253817581511)*x251))+(((1584437.02397479)*x254))+(((1584437.02397479)*x256))+((x252*x257))+(((-4.95253817581511)*x252)));
j1eval[1]=IKsign(((0.0026653)+(((4223.0)*x254))+(((4223.0)*x256))+(((-1.0)*x252*x258))+(((-1.0)*x251*x255))+((x251*x258))+(((-0.0132)*x252))+((x252*x255))+(((248.44161)*sj2))+(((0.0132)*x251))+(((-7.33977)*cj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
IkReal x259=(py*sj0);
IkReal x260=((30771537.6763726)*sj2);
IkReal x261=((909090.909090909)*cj2);
IkReal x262=(cj0*px);
j1eval[0]=((11768699.217622)+(((78457994.7823483)*px*sj0))+cj2+((x259*x261))+(((-78457994.7823483)*cj0*py))+(((-33.8486914440098)*sj2))+(((-1.0)*x259*x260))+(((245.239292239403)*x262))+((x261*x262))+(((245.239292239403)*x259))+(((-1.0)*x260*x262)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x263=cj0*cj0;
IkReal x264=px*px;
IkReal x265=py*py;
IkReal x266=(cj0*px);
IkReal x267=((33125548.0)*sj2);
IkReal x268=(cj0*py);
IkReal x269=(py*sj0);
IkReal x270=(px*py);
IkReal x271=((978636.0)*cj2);
IkReal x272=((1656.2774)*sj2);
IkReal x273=(px*sj0);
IkReal x274=((48.9318)*cj2);
IkReal x275=((20000.0)*cj0*sj0);
IkReal x276=((400000000.0)*x265);
CheckValue<IkReal> x277=IKPowWithIntegerCheck(((633.45000001452)+((x266*x274))+(((0.0132)*x269))+(((0.0132)*x266))+(((-1.0)*x269*x272))+(((4223.0)*x273))+(((-1.0)*x266*x272))+(((5.382498e-5)*cj2))+((x269*x274))+(((-0.00182190514)*sj2))+(((-4223.0)*x268))),-1);
if(!x277.valid){
continue;
}
CheckValue<IkReal> x278=IKPowWithIntegerCheck(((12669000.0002904)+(((-36.4381028)*sj2))+(((1.0764996)*cj2))+((x266*x271))+(((264.0)*x266))+(((264.0)*x269))+(((-1.0)*x267*x269))+(((-1.0)*x266*x267))+(((-84460000.0)*x268))+((x269*x271))+(((84460000.0)*x273))),-1);
if(!x278.valid){
continue;
}
if( IKabs(((x277.value)*(((-0.00608718)+(((40000.0)*x263*x270))+(((-10.33194957)*cj2))+(((-0.022)*x273))+(((-3000.0)*x269))+(((-3000.0)*x266))+(((349.72297301)*sj2))+(((-20000.0)*x270))+((x265*x275))+(((-1.0)*x264*x275))+(((0.022)*x268)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x278.value)*(((-17833728.999516)+(((-1.0)*x263*x276))+(((880.0)*x269))+(((880.0)*x266))+(((800000000.0)*x266*x269))+x276+(((400000000.0)*x263*x264)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x277.value)*(((-0.00608718)+(((40000.0)*x263*x270))+(((-10.33194957)*cj2))+(((-0.022)*x273))+(((-3000.0)*x269))+(((-3000.0)*x266))+(((349.72297301)*sj2))+(((-20000.0)*x270))+((x265*x275))+(((-1.0)*x264*x275))+(((0.022)*x268))))))+IKsqr(((x278.value)*(((-17833728.999516)+(((-1.0)*x263*x276))+(((880.0)*x269))+(((880.0)*x266))+(((800000000.0)*x266*x269))+x276+(((400000000.0)*x263*x264))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x277.value)*(((-0.00608718)+(((40000.0)*x263*x270))+(((-10.33194957)*cj2))+(((-0.022)*x273))+(((-3000.0)*x269))+(((-3000.0)*x266))+(((349.72297301)*sj2))+(((-20000.0)*x270))+((x265*x275))+(((-1.0)*x264*x275))+(((0.022)*x268))))), ((x278.value)*(((-17833728.999516)+(((-1.0)*x263*x276))+(((880.0)*x269))+(((880.0)*x266))+(((800000000.0)*x266*x269))+x276+(((400000000.0)*x263*x264))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x279=IKcos(j1);
IkReal x280=IKsin(j1);
IkReal x281=((0.08281387)*sj2);
IkReal x282=(py*sj0);
IkReal x283=((1.32e-6)*px);
IkReal x284=(px*sj0);
IkReal x285=(cj0*py);
IkReal x286=((0.00244659)*cj2);
IkReal x287=(cj0*px);
IkReal x288=((1.0)*x287);
IkReal x289=(cj0*x279);
IkReal x290=((1.0)*x279);
IkReal x291=((1.0)*x280);
evalcond[0]=((1.1e-6)+((x279*x281))+(((-6.6e-7)*x279))+x287+x282+(((0.21115)*x280))+(((-1.0)*x279*x286)));
evalcond[1]=((0.15)+(((6.6e-7)*x280))+(((-1.0)*x280*x281))+x284+(((0.21115)*x279))+(((-1.0)*x285))+((x280*x286)));
evalcond[2]=((-0.21115)+(((-1.0)*x284*x290))+(((-0.15)*x279))+((x279*x285))+(((-1.0)*x280*x288))+(((-1.1e-6)*x280))+(((-1.0)*x282*x291)));
evalcond[3]=((6.6e-7)+(((-1.0)*x285*x291))+(((-1.1e-6)*x279))+x286+(((0.15)*x280))+(((-1.0)*x281))+((x280*x284))+(((-1.0)*x279*x288))+(((-1.0)*x282*x290)));
evalcond[4]=((0.0266921953653594)+(((-1.0)*(px*px)))+(((-1.0)*sj0*x280*x283))+(((-1.98e-7)*x280))+(((-0.3)*x284))+(((0.095)*pz))+(((-2.2e-6)*x287))+(((-2.2e-6)*x282))+(((0.3)*x285))+(((1.32e-6)*x280*x285))+(((-1.0)*(pz*pz)))+(((1.32e-6)*x279*x282))+(((1.452e-12)*x279))+(((-1.0)*(py*py)))+((x283*x289)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x292=py*py;
IkReal x293=cj0*cj0;
IkReal x294=px*px;
IkReal x295=(cj0*py);
IkReal x296=((48.9318)*cj2);
IkReal x297=(px*sj0);
IkReal x298=(cj0*px);
IkReal x299=((1656.2774)*sj2);
IkReal x300=(py*sj0);
IkReal x301=(px*py);
IkReal x302=((20000.0)*x293);
IkReal x303=((20000.0)*cj0*sj0);
CheckValue<IkReal> x304 = IKatan2WithCheck(IkReal(((137.16274127205)+(((-20000.0)*x292))+(((-0.044)*x298))+(((-137.043025234976)*(cj2*cj2)))+(((-1.0)*x294*x302))+((x292*x302))+(((-0.044)*x300))+(((-8.104463448132)*cj2*sj2))+(((-40000.0)*x295*x297))+(((-0.002186286168)*sj2))+(((6.4589976e-5)*cj2)))),IkReal(((-0.00051282)+(((40000.0)*x293*x301))+(((10.33194957)*cj2))+(((-349.72297301)*sj2))+(((-1.0)*x294*x303))+((x292*x303))+(((0.022)*x295))+(((-3000.0)*x300))+(((-0.022)*x297))+(((-20000.0)*x301))+(((-3000.0)*x298)))),IKFAST_ATAN2_MAGTHRESH);
if(!x304.valid){
continue;
}
CheckValue<IkReal> x305=IKPowWithIntegerCheck(IKsign(((0.0026653)+(((4223.0)*x300))+(((-1.0)*x296*x297))+((x297*x299))+((x295*x296))+(((4223.0)*x298))+(((0.0132)*x295))+(((-1.0)*x295*x299))+(((248.44161)*sj2))+(((-0.0132)*x297))+(((-7.33977)*cj2)))),-1);
if(!x305.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x304.value)+(((1.5707963267949)*(x305.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x306=IKcos(j1);
IkReal x307=IKsin(j1);
IkReal x308=((0.08281387)*sj2);
IkReal x309=(py*sj0);
IkReal x310=((1.32e-6)*px);
IkReal x311=(px*sj0);
IkReal x312=(cj0*py);
IkReal x313=((0.00244659)*cj2);
IkReal x314=(cj0*px);
IkReal x315=((1.0)*x314);
IkReal x316=(cj0*x306);
IkReal x317=((1.0)*x306);
IkReal x318=((1.0)*x307);
evalcond[0]=((1.1e-6)+(((-6.6e-7)*x306))+x309+x314+(((-1.0)*x306*x313))+(((0.21115)*x307))+((x306*x308)));
evalcond[1]=((0.15)+x311+((x307*x313))+(((-1.0)*x307*x308))+(((-1.0)*x312))+(((0.21115)*x306))+(((6.6e-7)*x307)));
evalcond[2]=((-0.21115)+(((-0.15)*x306))+((x306*x312))+(((-1.0)*x307*x315))+(((-1.1e-6)*x307))+(((-1.0)*x309*x318))+(((-1.0)*x311*x317)));
evalcond[3]=((6.6e-7)+(((-1.0)*x312*x318))+x313+(((0.15)*x307))+(((-1.0)*x306*x315))+((x307*x311))+(((-1.1e-6)*x306))+(((-1.0)*x309*x317))+(((-1.0)*x308)));
evalcond[4]=((0.0266921953653594)+(((1.452e-12)*x306))+((x310*x316))+(((-1.0)*(px*px)))+(((-0.3)*x311))+(((0.095)*pz))+(((-1.98e-7)*x307))+(((-2.2e-6)*x314))+(((-1.0)*(pz*pz)))+(((1.32e-6)*x306*x309))+(((0.3)*x312))+(((1.32e-6)*x307*x312))+(((-1.0)*(py*py)))+(((-2.2e-6)*x309))+(((-1.0)*sj0*x307*x310)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x319=(py*sj0);
IkReal x320=((978636.0)*cj2);
IkReal x321=(px*sj0);
IkReal x322=((264.0)*cj0);
IkReal x323=((33125548.0)*sj2);
IkReal x324=(cj0*px);
IkReal x325=(cj0*py);
IkReal x326=(px*x323);
CheckValue<IkReal> x327=IKPowWithIntegerCheck(IKsign(((-20576983.825925)+(((2740860.50469952)*(cj2*cj2)))+(((-1.29179952)*cj2))+(((162089.26896264)*cj2*sj2))+(((43.72572336)*sj2)))),-1);
if(!x327.valid){
continue;
}
CheckValue<IkReal> x328 = IKatan2WithCheck(IkReal(((132.506)+((x323*x325))+(((146795.4)*cj2))+(((-1.0)*x321*x323))+((x320*x321))+(((264.0)*x321))+(((-1.0)*x320*x325))+(((84460000.0)*x324))+(((-4968832.2)*sj2))+(((84460000.0)*x319))+(((-1.0)*py*x322)))),IkReal(((12668999.9997096)+((x323*x324))+(((-84460000.0)*x325))+(((-1.0764996)*cj2))+(((-1.0)*px*x322))+(((-264.0)*x319))+(((-1.0)*x320*x324))+(((84460000.0)*x321))+(((-1.0)*x319*x320))+(((36.4381028)*sj2))+((x319*x323)))),IKFAST_ATAN2_MAGTHRESH);
if(!x328.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x327.value)))+(x328.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x329=IKcos(j1);
IkReal x330=IKsin(j1);
IkReal x331=((0.08281387)*sj2);
IkReal x332=(py*sj0);
IkReal x333=((1.32e-6)*px);
IkReal x334=(px*sj0);
IkReal x335=(cj0*py);
IkReal x336=((0.00244659)*cj2);
IkReal x337=(cj0*px);
IkReal x338=((1.0)*x337);
IkReal x339=(cj0*x329);
IkReal x340=((1.0)*x329);
IkReal x341=((1.0)*x330);
evalcond[0]=((1.1e-6)+(((-1.0)*x329*x336))+x332+x337+((x329*x331))+(((-6.6e-7)*x329))+(((0.21115)*x330)));
evalcond[1]=((0.15)+(((6.6e-7)*x330))+((x330*x336))+(((0.21115)*x329))+x334+(((-1.0)*x335))+(((-1.0)*x330*x331)));
evalcond[2]=((-0.21115)+(((-1.0)*x334*x340))+(((-1.0)*x332*x341))+(((-1.0)*x330*x338))+((x329*x335))+(((-1.1e-6)*x330))+(((-0.15)*x329)));
evalcond[3]=((6.6e-7)+(((-1.0)*x335*x341))+((x330*x334))+(((-1.0)*x329*x338))+(((-1.0)*x332*x340))+x336+(((0.15)*x330))+(((-1.0)*x331))+(((-1.1e-6)*x329)));
evalcond[4]=((0.0266921953653594)+(((-2.2e-6)*x332))+(((-2.2e-6)*x337))+(((-1.0)*(px*px)))+(((-1.98e-7)*x330))+(((0.3)*x335))+(((0.095)*pz))+(((-1.0)*sj0*x330*x333))+(((1.32e-6)*x329*x332))+(((-0.3)*x334))+(((1.452e-12)*x329))+((x333*x339))+(((-1.0)*(pz*pz)))+(((1.32e-6)*x330*x335))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "53a4976966144c9440d86012ca359708"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
